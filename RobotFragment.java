package fun.unifun.insbot.robot.brain.robot;

import static com.aliyun.vod.common.utils.FileUtils.deleteFile;
import static fun.unifun.insbot.robot.brain.event.BluetoothEvent.BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION;
import static fun.unifun.insbot.robot.brain.robot.InspectManager.targetInspectDirection;
import static fun.unifun.insbot.robot.brain.robot.InspectManager.targetInspectLocation;
import static fun.unifun.library.android.MqttCommand.CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION;
import static fun.unifun.library.android.MqttCommand.CONFIG_GAS_SENSOR_BOARD_FOR_LOWER_ACTION;
import static fun.unifun.library.android.MqttCommand.CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION;
import static fun.unifun.library.android.MqttCommand.CONFIG_GAS_SENSOR_BOARD_RESET_ACTION;
import static fun.unifun.library.android.MqttCommand.CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION;
import static fun.unifun.library.android.MqttCommand.CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_AUTO_BUILD_MAP_PHONE_NOTIFY_ROBOT_FIND_MISSING_NODE_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_AUTO_BUILD_MAP_PHONE_NOTIFY_ROBOT_UPLOAD_ONE_NODE_INFO_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_AUTO_BUILD_MAP_SEND_HEART_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_AUTO_BUILD_MAP_SYNC_DATA_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_AUTO_BUILD_MAP_TYPE;
import static fun.unifun.library.android.MqttCommand.ROBOT_CHECK_AUTO_BUILD_MAP_ACCOUNT_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE;
import static fun.unifun.library.android.MqttCommand.ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE;
import static fun.unifun.library.android.MqttCommand.ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE;
import static fun.unifun.library.android.MqttCommand.ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE;
import static fun.unifun.library.android.MqttCommand.ROBOT_CONTINUE_AUTO_BUILD_MAP_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_ENTER_AUTO_BUILD_MAP_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_INSPECTION_INDEX_TYPE;
import static fun.unifun.library.android.MqttCommand.ROBOT_QUIT_AUTO_BUILD_MAP_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_START_AUTO_BUILD_MAP_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_START_TO_FRONT_AUTO_BUILD_MAP_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_STOP_AUTO_BUILD_MAP_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_REFRESH_FOCUS_AND_ZOOM_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_SAVE_FOCUS_AND_ZOOM_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_SETTING_FOCAL_AND_RANGE_VALUE_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_SETTING_FOCAL_VALUE_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_SETTING_MAX_SHUTTER_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_SETTING_MIN_SHUTTER_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_SETTING_RANGE_VALUE_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_SET_FOCUS_MODE_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION;
import static fun.unifun.library.android.MqttCommand.ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE;
import static fun.unifun.library.android.UConstants.DEFAULT_DISTANCE;
import static fun.unifun.library.android.bean.RobotMode.MODE_AGING_TEST;
import static fun.unifun.library.android.bean.RobotMode.MODE_AUTO_BUILD_MAP;
import static fun.unifun.library.android.bean.RobotMode.MODE_BATCH_PRODUCTION_TEST;
import static fun.unifun.library.android.bean.RobotMode.MODE_CHECKING_STOP;
import static fun.unifun.library.android.bean.RobotMode.MODE_COLLECTION_RAW_DATA_MP4;
import static fun.unifun.library.android.bean.RobotMode.MODE_DEVICE_CLEAN;
import static fun.unifun.library.android.bean.RobotMode.MODE_GOTO_CHARGER;
import static fun.unifun.library.android.bean.RobotMode.MODE_INSPECTION;
import static fun.unifun.library.android.bean.RobotMode.MODE_MOVE_TO_TARGET;
import static fun.unifun.library.android.bean.RobotMode.MODE_RECLAIMER;
import static fun.unifun.library.android.bean.RobotMode.MODE_UN_KNOW;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_1;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_10;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_11;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_12;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_13;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_14;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_15;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_16;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_2;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_3;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_4;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_5;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_6;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_7;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_8;
import static fun.unifun.library.android.bluetooth.BleDataHelper.BleMsgCode.MSG_CODE_9;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_CLOSE_OBSTACLE;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_CURRENT_LOG_CLOSE;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_CURRENT_LOG_OPEN;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_CURRENT_LOG_UPLOAD;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_CURRENT_TEST_CLOSE;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_CURRENT_TEST_OPEN;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_EMERGENCY_STOP;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_ENABLE_MOTOR;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_MOVE_BACK;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_MOVE_FRONT;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_MOVE_STOP;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_OPEN_OBSTACLE;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_SET_SPEED;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_STANDBY;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_WAKEUP_EMERGENCY_STOP;
import static fun.unifun.library.android.bluetooth.BleDataHelper.FunctionCode.CMD_WAKEUP_STANDBY;
import static fun.unifun.robot.brain.platform.MainApp.environmentalTemperature;
import static fun.unifun.robot.brain.platform.MainApp.isBeltConveyorStart;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_LOWER_ALARM_VALUE;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_TYPE_CH4;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_TYPE_CO;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_TYPE_CO2;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.GAS_SENSOR_BOARD_TYPE_O2;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.MOVE_END;
import static fun.unifun.robot.brain.platform.serial_port.stm32.StmTask.MOVE_FRONT;

import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.icu.text.DecimalFormat;
import android.net.wifi.ScanResult;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.IBinder;
import android.os.Message;
import android.os.PowerManager;
import android.os.RemoteException;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Log;
import android.util.SparseArray;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import androidx.annotation.RequiresApi;
import androidx.appcompat.app.AlertDialog;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.alibaba.sdk.android.oss.ClientException;
import com.alibaba.sdk.android.oss.ServiceException;
import com.aliyun.openservices.shade.org.apache.commons.lang3.ArrayUtils;
import com.blankj.utilcode.util.AppUtils;
import com.blankj.utilcode.util.CollectionUtils;
import com.blankj.utilcode.util.NetworkUtils;
import com.blankj.utilcode.util.ToastUtils;
import com.fasterxml.jackson.core.type.TypeReference;
import com.google.gson.Gson;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.huafang.sunmyapplication.VideoUtils;
import com.manager.device.DeviceManager;
import com.tencent.bugly.crashreport.CrashReport;
import com.xuhao.didi.core.pojo.OriginalData;
import com.xuhao.didi.socket.client.sdk.client.ConnectionInfo;

import org.opencv.osgi.OpenCVNativeLoader;
import org.quartz.CronExpression;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.nio.ByteBuffer;
import java.text.MessageFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import java.util.zip.Deflater;

import fun.unifun.insbot.robot.brain.BaseFragment;
import fun.unifun.insbot.robot.brain.R;
import fun.unifun.insbot.robot.brain.alarm.AlarmManager;
import fun.unifun.insbot.robot.brain.aruco.TakeImgInspectManager;
import fun.unifun.insbot.robot.brain.bluetooth.RobotBluetoothManager;
import fun.unifun.insbot.robot.brain.charger.adapter.MyBaseAdapter;
import fun.unifun.insbot.robot.brain.checker.HealthChecker;
import fun.unifun.insbot.robot.brain.checker.rfid.RfidLostChecker;
import fun.unifun.insbot.robot.brain.common.BrainApplication;
import fun.unifun.insbot.robot.brain.common.RobotInfoManager;
import fun.unifun.insbot.robot.brain.devices.MotorController;
import fun.unifun.insbot.robot.brain.devices.ObstacleController;
import fun.unifun.insbot.robot.brain.devices.SteerControlTag;
import fun.unifun.insbot.robot.brain.devices.SteerController;
import fun.unifun.insbot.robot.brain.devices.bms.BaseBmsCommunicator;
import fun.unifun.insbot.robot.brain.devices.bms.BmsDataActionConstants;
import fun.unifun.insbot.robot.brain.devices.bms.BmsDataDetail;
import fun.unifun.insbot.robot.brain.devices.bms.BmsDataEvent;
import fun.unifun.insbot.robot.brain.devices.bms.BmsDataEventListener;
import fun.unifun.insbot.robot.brain.devices.elevator.ElevatorController;
import fun.unifun.insbot.robot.brain.devices.rfid.RfidController;
import fun.unifun.insbot.robot.brain.devices.room.CicadaRoomController;
import fun.unifun.insbot.robot.brain.devices.room.CicadaRoomDoorState;
import fun.unifun.insbot.robot.brain.devices.room.RoomControlSource;
import fun.unifun.insbot.robot.brain.devices.switchtrack.SwitchTrackController;
import fun.unifun.insbot.robot.brain.event.AlarmEvent;
import fun.unifun.insbot.robot.brain.event.BluetoothEvent;
import fun.unifun.insbot.robot.brain.event.InspectionAlarmEvent;
import fun.unifun.insbot.robot.brain.event.LoraEvent;
import fun.unifun.insbot.robot.brain.event.MapEvent;
import fun.unifun.insbot.robot.brain.event.RobotChargeEvent;
import fun.unifun.insbot.robot.brain.event.RobotHeartEvent;
import fun.unifun.insbot.robot.brain.map.AutoBuildRfidMapManager;
import fun.unifun.insbot.robot.brain.map.ChargerNodeType;
import fun.unifun.insbot.robot.brain.map.MapInfo;
import fun.unifun.insbot.robot.brain.map.MapManager;
import fun.unifun.insbot.robot.brain.performance.PerformanceManager;
import fun.unifun.insbot.robot.brain.robot.bean.ApnConfig;
import fun.unifun.insbot.robot.brain.robot.bean.BeltConfig;
import fun.unifun.insbot.robot.brain.robot.bean.BeltConfigSub;
import fun.unifun.insbot.robot.brain.robot.bean.BeltRunStatus;
import fun.unifun.insbot.robot.brain.robot.bean.RfidInfo;
import fun.unifun.insbot.robot.brain.robot.bean.SensorStatusRecord;
import fun.unifun.insbot.robot.brain.robot.bean.UploadTempFrameData;
import fun.unifun.insbot.robot.brain.robot.guardmode.GuardModeManager;
import fun.unifun.insbot.robot.brain.robot.scenes.reclaimer.ReclaimerInspection;
import fun.unifun.insbot.robot.brain.sensors.RobotSensorDetector;
import fun.unifun.insbot.robot.brain.service.ChatSocketClient;
import fun.unifun.insbot.robot.brain.stm.StmLogHelper;
import fun.unifun.insbot.robot.brain.tts.TtsManager;
import fun.unifun.insbot.robot.brain.utils.MotorMaxSpeedParser;
import fun.unifun.insbot.robot.brain.utils.Recorder;
import fun.unifun.insbot.robot.brain.utils.RgbSharpnessChecker;
import fun.unifun.insbot.robot.brain.utils.RobotPreferences;
import fun.unifun.insbot.robot.brain.utils.RobotSetSpeedLogTags;
import fun.unifun.insbot.robot.brain.webcamera.FillLightController;
import fun.unifun.insbot.robot.brain.webcamera.FillLightSwitchMode;
import fun.unifun.insbot.robot.brain.yolov7obb.ir.IrYoloV7ObbUtil;
import fun.unifun.insbot.robot.brain.yolov7obb.rgb.RgbYoloV7Obb;
import fun.unifun.insbot.robot.brain.yolov7obb.rgb.RgbYoloV7ObbUtil;
import fun.unifun.library.android.MqttCommand;
import fun.unifun.library.android.MqttCommands;
import fun.unifun.library.android.UByte;
import fun.unifun.library.android.UConstants;
import fun.unifun.library.android.UFile;
import fun.unifun.library.android.UImg;
import fun.unifun.library.android.ULog;
import fun.unifun.library.android.UNet;
import fun.unifun.library.android.UOss;
import fun.unifun.library.android.UPreferences;
import fun.unifun.library.android.URootCmd;
import fun.unifun.library.android.UShare;
import fun.unifun.library.android.USystemProperties;
import fun.unifun.library.android.UrlManager;
import fun.unifun.library.android.alarm.AlarmTypeEnum;
import fun.unifun.library.android.api.rfid_node.RfidNodeServiceImpl;
import fun.unifun.library.android.api.robot.RobotServiceImpl;
import fun.unifun.library.android.bean.ChargerStatus;
import fun.unifun.library.android.bean.ChargingStrategy;
import fun.unifun.library.android.bean.CleanDeviceType;
import fun.unifun.library.android.bean.MoveToTarget;
import fun.unifun.library.android.bean.NodeType;
import fun.unifun.library.android.bean.RobotConfigParams;
import fun.unifun.library.android.bean.StmLogRequest;
import fun.unifun.library.android.bean.TaskNodeMold;
import fun.unifun.library.android.bean.TimeType;
import fun.unifun.library.android.bean.sensor.Sensor;
import fun.unifun.library.android.bean.sensor.SensorData;
import fun.unifun.library.android.common.BaseApplication;
import fun.unifun.library.android.common.CommonResult;
import fun.unifun.library.android.common.JsonHelper;
import fun.unifun.library.android.common.MqttMsgCode;
import fun.unifun.library.android.common.ResultCode;
import fun.unifun.library.android.common.RxBus;
import fun.unifun.library.android.common.SensorConstants;
import fun.unifun.library.android.common.Stm32RebootReason;
import fun.unifun.library.android.common.UExecutorService;
import fun.unifun.library.android.constants.KeyConstant;
import fun.unifun.library.android.event.AlarmTypeEvent;
import fun.unifun.library.android.event.BmsEvent;
import fun.unifun.library.android.event.DeviceEvent;
import fun.unifun.library.android.event.ElevatorEvent;
import fun.unifun.library.android.event.FillLightEvent;
import fun.unifun.library.android.event.MqttEvent;
import fun.unifun.library.android.event.NetworkEvent;
import fun.unifun.library.android.event.PushEvent;
import fun.unifun.library.android.event.RfidEvent;
import fun.unifun.library.android.event.RobotEvent;
import fun.unifun.library.android.event.RobotEventConstants;
import fun.unifun.library.android.event.SegmentEvent;
import fun.unifun.library.android.event.Stm32Event;
import fun.unifun.library.android.event.WebCameraEvent;
import fun.unifun.library.android.map.RfidMapType;
import fun.unifun.library.android.map.bean.DistanceArea;
import fun.unifun.library.android.map.bean.DistanceAreaType;
import fun.unifun.library.android.mqtt.MqttManager;
import fun.unifun.library.android.robot.RobotMainType;
import fun.unifun.library.android.robot.RobotSubType;
import fun.unifun.library.android.robot.RobotType;
import fun.unifun.library.android.rxjava.NextErrorObserver;
import fun.unifun.library.android.rxjava.NextObserver;
import fun.unifun.library.android.rxjava.ObserverFactory;
import fun.unifun.library.android.sensor.BmsConfigConstants;
import fun.unifun.library.android.sensor.BmsInfo;
import fun.unifun.library.android.sensor.Ch4SensorInfo;
import fun.unifun.library.android.sensor.CleanDeviceInfo;
import fun.unifun.library.android.sensor.CoSensorInfo;
import fun.unifun.library.android.sensor.EmergencyStopButtonInfo;
import fun.unifun.library.android.sensor.GasCollectionBoardSensorInfo;
import fun.unifun.library.android.sensor.H2SensorInfo;
import fun.unifun.library.android.sensor.H2sSensorInfo;
import fun.unifun.library.android.sensor.LeakSensorConfigConstants;
import fun.unifun.library.android.sensor.LeakSensorInfo;
import fun.unifun.library.android.sensor.MotorConfigConstants;
import fun.unifun.library.android.sensor.MotorInfo;
import fun.unifun.library.android.sensor.Nh3SensorInfo;
import fun.unifun.library.android.sensor.O2SensorInfo;
import fun.unifun.library.android.sensor.Pm10SensorInfo;
import fun.unifun.library.android.sensor.SensorInfoProvider;
import fun.unifun.library.android.sensor.SensorManager;
import fun.unifun.library.android.sensor.SensorType;
import fun.unifun.library.android.sensor.Sf6SensorInfo;
import fun.unifun.library.android.sensor.SixInOneSensorConfigConstants;
import fun.unifun.library.android.sensor.SixInOneSensorInfo;
import fun.unifun.library.android.sensor.SmokeSensorInfo;
import fun.unifun.library.android.sensor.TemperatureHumiditySensorConfigConstants;
import fun.unifun.library.android.sensor.TemperatureHumiditySensorInfo;
import fun.unifun.library.android.sensor.WebCameraSensorInfo;
import fun.unifun.library.android.storage.StorageCenter;
import fun.unifun.library.android.tools.AppUtil;
import fun.unifun.library.android.tools.BoolUtil;
import fun.unifun.library.android.tools.CollUtil;
import fun.unifun.library.android.tools.IntUtil;
import fun.unifun.library.android.tools.NumUtil;
import fun.unifun.library.android.tools.NumberUtil;
import fun.unifun.library.android.tools.StrUtil;
import fun.unifun.library.android.tools.Utils;
import fun.unifun.library.android.utils.AudioUtil;
import fun.unifun.library.android.utils.CpuUtils;
import fun.unifun.library.android.utils.FormatUtils;
import fun.unifun.library.android.utils.UAppUtil;
import fun.unifun.library.android.utils.UFileUtils;
import fun.unifun.library.android.utils.UGZIPOutputStream;
import fun.unifun.library.cloud.client.bean.AngleBean;
import fun.unifun.library.cloud.client.bean.CurrentCameraAngle;
import fun.unifun.library.cloud.client.bean.FireAlarmConfig;
import fun.unifun.library.cloud.client.bean.GasBoardStandardGasValue;
import fun.unifun.library.cloud.client.bean.OfflineLocation;
import fun.unifun.library.cloud.client.bean.TaskNodeLocation;
import fun.unifun.library.cloud.client.bean.WebCameraArgumentBean;
import fun.unifun.library.cloud.client.entity.Charger;
import fun.unifun.library.cloud.client.entity.HistoryTime;
import fun.unifun.library.cloud.client.entity.RfidNode;
import fun.unifun.library.cloud.client.entity.Robot;
import fun.unifun.library.cloud.client.entity.Segment;
import fun.unifun.library.cloud.client.entity.SensorHistoryRecord;
import fun.unifun.library.cloud.client.entity.TSensorHistoryRecordException;
import fun.unifun.library.cloud.client.entity.TaskNode;
import fun.unifun.library.cloud.client.entity.TaskObj;
import fun.unifun.library.cloud.client.inparam.mapnode.UpdateAllExceptionByMapId;
import fun.unifun.library.cloud.client.inparam.rfidnode.DeleteByMapId;
import fun.unifun.library.cloud.client.inparam.robot.ConnectTest;
import fun.unifun.library.cloud.client.inparam.robot.FindById;
import fun.unifun.library.cloud.client.inparam.robot.UpdateById;
import fun.unifun.library.cloud.client.inparam.robot.UpdatePushEnableByRobotId;
import fun.unifun.library.cloud.client.inparam.robot.UpdateRobotRgbLensDirtyStateAndCheckAlarm;
import fun.unifun.library.cloud.client.inparam.robotStatisticsData.RobotStatisticsDataPara;
import fun.unifun.library.cloud.client.inparam.segment.FindSegmentAndChargeByRobotId;
import fun.unifun.library.cloud.client.inparam.segmentsensor.FindByMapId;
import fun.unifun.library.cloud.client.inparam.sensorhistoryrecord.Create;
import fun.unifun.library.cloud.client.inparam.tasknode.CreateAndSaveSamplingImage;
import fun.unifun.library.java.storage.Minio;
import fun.unifun.library.java.util.UConstant;
import fun.unifun.library.java.util.UGson;
import fun.unifun.library.java.util.UOKHttp;
import fun.unifun.library.java.util.UString;
import fun.unifun.library.java.util.UTime;
import fun.unifun.robot.brain.platform.MainApp;
import fun.unifun.robot.brain.platform.audio.AudioFileBean;
import fun.unifun.robot.brain.platform.audio.AudioManager;
import fun.unifun.robot.brain.platform.audio.AudioRecorder;
import fun.unifun.robot.brain.platform.audio.OnAudioDataListener;
import fun.unifun.robot.brain.platform.audio.OnDecibelListener;
import fun.unifun.robot.brain.platform.bean.StatisticInfo;
import fun.unifun.robot.brain.platform.bean.StmStandardHeartData;
import fun.unifun.robot.brain.platform.camera.VideoBuff;
import fun.unifun.robot.brain.platform.camera.ir.IrFrameTempCallback;
import fun.unifun.robot.brain.platform.camera.ir.IrManager;
import fun.unifun.robot.brain.platform.camera.ir.RecordIrData;
import fun.unifun.robot.brain.platform.media_codec.AvcEncoder;
import fun.unifun.robot.brain.platform.push_stream.PushFps;
import fun.unifun.robot.brain.platform.push_stream.PushManager;
import fun.unifun.robot.brain.platform.push_stream.SmartPlayer;
import fun.unifun.robot.brain.platform.push_stream.SmartPusher;
import fun.unifun.robot.brain.platform.push_stream.SmartRtspToRtmp;
import fun.unifun.robot.brain.platform.push_stream.WebCameraPusher;
import fun.unifun.robot.brain.platform.push_stream.ZhstWebCameraManager;
import fun.unifun.robot.brain.platform.serial_port.lora.LoraTask;
import fun.unifun.robot.brain.platform.serial_port.lora.LoraTaskExecute;
import fun.unifun.robot.brain.platform.serial_port.modbus.ModBusManager;
import fun.unifun.robot.brain.platform.serial_port.modbus.ModBusTask;
import fun.unifun.robot.brain.platform.serial_port.robot.decibel.DecibelTask;
import fun.unifun.robot.brain.platform.serial_port.robot.decibel.DecibelTaskExecute;
import fun.unifun.robot.brain.platform.serial_port.robot.rfid.RFIDTask;
import fun.unifun.robot.brain.platform.serial_port.stm32.StmTask;
import fun.unifun.robot.brain.platform.serial_port.stm32.StmTaskExecute;
import fun.unifun.robot.brain.platform.services.IRService;
import fun.unifun.robot.brain.platform.services.MediaService;
import fun.unifun.robot.brain.platform.services.RgbService;
import fun.unifun.robot.brain.platform.services.SoundPoolService;
import fun.unifun.robot.brain.platform.utils.NetWorkUtils;
import fun.unifun.robot.brain.platform.utils.SerialManagerUtil;
import fun.unifun.robot.brain.platform.web_cam.ViewSheenWebCamera;
import fun.unifun.robot.brain.platform.web_cam.WebCamManager;
import fun.unifun.robot.brain.platform.web_cam.XMWebCamera;
import fun.unifun.robot.brain.platform.wifi.NetworkService;
import fun.unifun.robot.brain.platform.wifi.WIFIStateCallback;
import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Observer;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.functions.Consumer;
import io.reactivex.rxjava3.schedulers.Schedulers;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okhttp3.internal.Util;
import okio.BufferedSink;
import okio.Okio;
import okio.Source;
import retrofit2.adapter.rxjava3.CommonRetWrapper;

/**
 * create by yangh on 2020/3/17 20:42
 **/
public class RobotFragment extends BaseFragment implements
        OnDecibelListener,
        OnAudioDataListener,
        PushManager.PushStatusCallback,
        IRService.IrDataCallback,
        RgbService.RgbDataCallback,
        LoraTaskExecute.LoraTaskListener,
        WIFIStateCallback, MqttManager.MqttEventListener,
        BmsDataEventListener, IrFrameTempCallback {
    //初始化JavaCV中的OpenCV
    static {
        OpenCVNativeLoader openCVNativeLoader = new OpenCVNativeLoader();
        openCVNativeLoader.init();
    }

    String TAG = RobotFragment.class.getSimpleName();

    private int mZoom = UConstants.UNKONW, mFocus = UConstants.UNKONW;
    private TextView tvCam, tvSE, tvDistance, tvShowEpc;
    private EditText etSE, etCam;
    private boolean isPlay;


    private boolean isIrBind;
    private boolean isRgbBind;
    private boolean isNetworkBind;
    private boolean isChargerOnline;//充电桩是否在线
    private int rfidWriteTotalNum = -1;
    private int rfidWriteNum;
    private volatile boolean writeRfidInterrupt;
    private volatile boolean isNeedInitSteer;
    private boolean cleanStmRfids = false;
    private List<RfidNode> writeStmRfids = new ArrayList<>();
    private int webCameraNum = 0;//网络摄像头数量
    private long currentProgressTime;//网络摄像头进度回调时间
    //    private long lastProgressTime;//记录上一次进度回调时间
    //    private AlivcPlayAudio alivcPlayAudio;
    private SmartPlayer playAudio;

    private String mLocalPushIrUrl, mLocalPushWebCameraUrl, mLocalPushAudioUrl;

    public InspectManager inspectManager;
    public AutoMoveManager autoMoveManager;
    /**
     * 心跳是否已开启
     */
    private volatile boolean mIsHeartStarted = false;

    private float voltageLow = 3.2f;//单体电池低电压触发回充 (注:并不是极低单体电池电压报警 这个只是检测回充)
    private float veryHighSingleVoltage = 4.3f;//单体电池极高电压阈值 BMS有配置时使用总体电池电压阈值/电池串数=单体电池极高电压阈值 默认值沿用以前极高极低电压阈值4.3 和 2.5
    private float veryLowSingleVoltage = 2.5f;//单体电池极底电压阈值 同上

    private float lowTempThreshold = 50;

    private final int recoveryThreshold = 5;
    private int recoveryNum = 0;
    private int recoveryInPlaceNum = 0;
    private long lastRecoveryInPlaceTime = 0;

    /**
     * RFID类型
     * 0: 上位机-UM202
     * 1: 上位机-HM072
     * 2: 下位机-UM202
     * 3: 下位机-HM072
     */
    public int rfidReadType = UConstants.UNKONW;
    public int rfidReadNum;
    /**
     * 红外摄像头是否显示标定框
     */
    private boolean mInfraredCameraIsShowArea;

    /**
     * 与量产的 MQTT 通信
     * 同一时间一台机器人仅允许和一台手机的量产进行MQTT通信，后建立连接的将占有此通信渠道
     * 通过MQTT消息的[修改目标]来修改productionClientId，实现构建通信的目的
     *
     * @see #setProductionClientId 修改
     */
    public static String productionClientId = MqttCommand.ROBOT_BATCH_PRODUCTION_FLAG;   //量产测试的手机端MQTT id

    /**
     * 查询线段信息的次数
     */
    private int mFindSegmentCount = 0;

    /**
     * 查找充电桩的次数
     */
    private int mFindChargerCount = 0;


    //    private RadioGroup network_rg;
    private CopyOnWriteArrayList<Float> batteryVoltageList = new CopyOnWriteArrayList<>();
    //电池单体电压集合

    private volatile Consumer<RobotChargeEvent> mRobotChargeEventObserver = null;

    private double standardGasval;
    private double upperVal;
    private double lowerVal;
    private MqttManager mMqttManager;
    //    private int lowPowerTime = 0;
    private int frontMicrosWitch, behindMicrosWitch;

    /**
     * 下位机配置参数
     */
    private Map<Integer, String> mStmConfigParams = new ConcurrentHashMap<>();

    private final String KEY_MOTOR_TYPE = "motor_type";
    /**
     * 检测一帧Aruco识别的id集合
     */
    private ArrayList<Integer> idsList;
    private String checkArucoAccount;
    private byte[] takePhotoBytes;
    private TaskNodeLocation taskNodeLocation;


    /**
     * 报警次数记录，key为报警类型ID，如T_00001，value为是报警次数，恢复时应置为0
     */
    private ConcurrentHashMap<AlarmTypeEnum, Integer> mAlarmCount = new ConcurrentHashMap<>(60);

    /**
     * 报警是否已上报，key为报警类型ID，如T_00001，value为是否已上报
     */
    private ConcurrentHashMap<AlarmTypeEnum, Boolean> mIsAlarmReported = new ConcurrentHashMap<>(60);

    //补光灯亮度值(非实时有几秒的延迟)
    private int fillLightLevel = 0;

    /**
     * 是否有新的除尘设备； 自循环、BY
     */
    public boolean mIsHaveNewCleanDevice = false;

    private boolean mIsWaitToQuitAutoBuildMapMode = false;
    private boolean mIsWaitToEnterAutoBuildMapMode = false;

    /**
     * 是否是重启后程序第一次除尘
     */
    private volatile boolean mIsFirstDustingAfterBoot = false;

    private final RobotSequenceInitializer mSequenceInitializer = new RobotSequenceInitializer();
    private int rfidNodeSize;

    public int getFillLightLevel() {
        return this.fillLightLevel;
    }

    public RobotFragment() {

    }

    private PowerManager powerManager;
    //网络摄像头是否通电
    public boolean isWebCameraElectrify = false;

    private Disposable mMotorBackDis = null;

    /**
     * 上次存电机位置时间，防止存储频率过高导致Flash有问题
     */
    private long mLastSaveMotorLocationTime = 0L;


    private boolean mIsCheckingRfidLost = false;

    /**
     * 下位机标准心跳数据队列
     */
    private final ConcurrentLinkedDeque<StmStandardHeartData> mStmHeartDataQueue = new ConcurrentLinkedDeque<>();

    /**
     * 下位机心跳锁
     */
    private final Object mStmHeartLock = new Object();

    /**
     * 下位机心跳数据处理线程
     */
    private Thread mStmHeartDataProcessThread = null;

    /**
     * 上次火情报警的时间
     */
    private long mLastIrFileAlarmTime = 0;

    /**
     * 电机运动阻碍后是否尝试过回充
     */
    private boolean mHasTriedGoChargerAfterMotorStall = false;

    /**
     * 除尘设备区间集合
     */
    private List<DistanceArea> mCleanDeviceAreaList = new ArrayList<>();

    /**
     * 待机时白名单指令类型，不在白名单的指令将被忽略
     */
    private final List<String> mStandbyWhiteListCmdTypes = new ArrayList<>();

    {
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_ENVIRONMENTAL_TEMPERATURE_INDEX_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_SENSOR_STATE_INDEX_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_SLEEP_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_WAKE_UP_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_FORCE_OFF_CHARGING_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_MANAGER_CHARGER_STATE_INDEX);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_MANAGER_DUSTING_STATE_INDEX);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_REBOOT_INDEX_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_LIGHT_OPEN_ACTION);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_REBOOT_STM_INDEX_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_RESULT_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_STEER_ENGINE_CONTROL_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.ROBOT_WEB_CAMERA_CONTROL_TYPE);
        mStandbyWhiteListCmdTypes.add(MqttCommand.StmLog.TYPE_TRANSFER_STM_LOG);
    }

    private MqttCommand mCmdAfterRoomOp = null;

    private RobotType mRobotType = null;

    private CicadaRoomController.DoorStateChangeListener mDoorStateChangeListener = new CicadaRoomController.DoorStateChangeListener() {
        @Override
        public void onStateChanged(CicadaRoomDoorState oldState, CicadaRoomDoorState newState) {
            if (newState == CicadaRoomDoorState.OPEN) {
                ULog.d(TAG, "room门已打开 ，waitOpen=" + RobotStatus.getIsWaitRoomDoorOpen() + ", waitClose=" + RobotStatus.getIsWaitRoomDoorClose() + "," +
                        "cmd:" + mCmdAfterRoomOp);
                if (autoMoveManager != null) {
                    autoMoveManager.cancelRoomIgnoreChargeNotice();
                }

                if (RobotStatus.getIsWaitRoomDoorOpen()) {
                    RobotStatus.setIsWaitRoomDoorOpen(false);
                    if (mCmdAfterRoomOp != null) {
                        if (MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE.equals(mCmdAfterRoomOp.getType())) {
                            MqttCommand cmd = mCmdAfterRoomOp.cloneCreateIdAndTimeStamp();
                            mCmdAfterRoomOp = null;
                            ObstacleController.getInstance().setObstacleOn(false,"11");
                            onMessageReceived(cmd);
                        } else if (MqttCommand.ROBOT_INSPECTION_INDEX_TYPE.equals(mCmdAfterRoomOp.getType())) {
                            ObstacleController.getInstance().setObstacleOn(false,"12");
                            switch (mCmdAfterRoomOp.getAction()) {
                                case MqttCommand.ROBOT_INSPECTION_CHARGING_ACTION:
                                    if (MODE != MODE_GOTO_CHARGER) {
                                        setMode(MODE_GOTO_CHARGER, "回充模式-RoomDoorStateChanged1");
                                    }
                                    break;

                                case MqttCommand.ROBOT_INSPECTION_FORCE_ACTION:
                                    //                                    if (MODE != ROBOT_INSPECTION) {
                                    //                                        setMode(ROBOT_INSPECTION, 111);
                                    //                                    }
                                    MqttCommand cmd = mCmdAfterRoomOp.cloneCreateIdAndTimeStamp();
                                    mCmdAfterRoomOp = null;
                                    onMessageReceived(cmd);
                                    break;
                            }
                        }else if(MqttCommand.MOVE_TO_TARGET_TYPE.equals(mCmdAfterRoomOp.getType())){
                            ObstacleController.getInstance().setObstacleOn(false,"执行移动到指定目标位置前关避障");
                            MqttCommand cmd = mCmdAfterRoomOp.cloneCreateIdAndTimeStamp();
                            onMessageReceived(cmd);
                            mCmdAfterRoomOp = null;
                        }
                    }
                }
            } else if (newState == CicadaRoomDoorState.CLOSED) {
                if (RobotStatus.getIsWaitRoomDoorClose()) {
                    RobotStatus.setIsWaitRoomDoorClose(false);
                }
            }
        }
    };

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
        super.onCreateView(inflater, container, savedInstanceState);
        ULog.d(TAG, "onCreateView:  =========");

        mView = inflater.inflate(R.layout.fragment_robot, container, false);
        TtsManager.getInstance().initTextToSpeech();//初始化tts
        initView();
        initViewByIrYoloV7Obb();
        apnCheck();
        registerObservers();
        initGpio();
        initConfig();
        initYoloV7Obb();
        powerManager = (PowerManager) BaseApplication.getInstance().getSystemService(Context.POWER_SERVICE);
        return mView;
    }

    ImageView iv_detect_img;
    //TODO jiao 临时测试 后期修改或删除
    private void initViewByIrYoloV7Obb() {
        iv_detect_img = mView.findViewById(R.id.iv_detect_img);
        TextView tv_detect_info = mView.findViewById(R.id.tv_detect_info);
        Resources res = getResources();
        Bitmap bmp= BitmapFactory.decodeResource(res, R.mipmap.detect_ir_img);
        mView.findViewById(R.id.bt_cpu).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                /*if (bmp == null)
                    return;
                long start = System.currentTimeMillis();

                Bitmap mutableBitmap = bmp.copy(Bitmap.Config.ARGB_8888, true);*/
                /*//C++中并没有使用GPU所以只调用CPU的接口就可以了  目前起二个参数是false或true都是使用的CPU检测
                Bitmap map = IrYoloV7ObbUtil.getInstance().detectAndDraw(mutableBitmap, false);
                iv_detect_img.setImageBitmap(map);*/

                /*Bitmap map = RgbYoloV7ObbUtil.getInstance().detectAndDraw(mutableBitmap, false);
                iv_detect_img.setImageBitmap(map);

                final long dur = System.currentTimeMillis() - start;
                tv_detect_info.setText("cpu cost time: "+dur+" ms");*/


                String nodeName = "ceshi";
                String[] rollerName =  {"left_roller", "middle_roller", "right_roller"};
                WebCamManager.getInstance().takePhoto().observeOn(Schedulers.io()).subscribe(new NextErrorObserver<ResponseBody>() {
                    @Override
                    public void onNext(@NonNull ResponseBody responseBody) {
                        byte[] bytes = new byte[0];
                        try {
                            bytes = responseBody.bytes();
                        } catch (IOException e) {
                            ULog.d(TAG,"yolov7rgb 拍照失败1 e:"+e.getMessage());
                        }
                        if(bytes.length == 0){
                            ULog.d(TAG,"yolov7rgb 拍照失败2");
                            return;
                        }

                        /**
                         * String filePath = "/sdcard/yolov7obb/detect_rgb_img.jpg";
                         *                         BitmapFactory.Options mOptions = new BitmapFactory.Options();
                         *                         mOptions.inScaled = false;
                         *                         Bitmap bitmap = BitmapFactory.decodeFile(filePath,mOptions);
                         *                         int w = bitmap.getWidth();
                         *                         int h = bitmap.getHeight();
                         *                         Log.d(TAG,"w1:"+width+" h:"+height+" "+bitmap.getAllocationByteCount()+" "+bitmap.getByteCount());
                         *
                         *                         ByteBuffer buffer = ByteBuffer.allocate(bitmap.getByteCount());
                         *                         bitmap.copyPixelsToBuffer(buffer);
                         *                         bytes = buffer.array();
                         */

                        ULog.d("yolov7rgb"," bytes " + UByte.print(bytes, 5) + " bytes.len " + bytes.length);

                        Bitmap bitmap = ((BitmapDrawable) (Drawable)getActivity().getDrawable(R.drawable.detect_rgb_img)).getBitmap();
                        ByteArrayOutputStream stream = new ByteArrayOutputStream();
                        bitmap.compress(Bitmap.CompressFormat.JPEG,100,stream);
                        bytes = stream.toByteArray();

                        ULog.d("yolov7rgb"," bytes " + UByte.print(bytes, 5) + " bytes.len " + bytes.length);
                        // 查找SOF0标记的起始位置
                        int sof0Index = InspectManager.findSOF0Marker(bytes);

                        int h,w;

                        if (sof0Index != -1) {
                            // 提取宽度和高度信息
                            h = (bytes[sof0Index + 5] & 0xFF) << 8 | (bytes[sof0Index + 6] & 0xFF);
                            w = (bytes[sof0Index + 7] & 0xFF) << 8 | (bytes[sof0Index + 8] & 0xFF);
                        } else {
                            ULog.d(TAG,"yolov7rgb 未找到SOF0标记");
                            return;
                        }
                        w = 1280;
                        h = 720;
                        //String nodeName = mCurrentTaskNode.getName();
                        byte[] dstImg = new byte[320*180*4];
                        String[] dstStrArr = new String[]{""};
                        long yoloF = System.currentTimeMillis();
                        ULog.d(TAG, "yolov7rgb 参数打印 W:"+w+
                                " H:"+h+
                                " nodeName:"+ nodeName +
                                " rollerName:"+ UGson.getGson().toJson(rollerName)+
                                " srcImg " + UByte.print(bytes, 5) + " srcImg.len " + bytes.length +
                                " dstImg " + UByte.print(dstImg, 5) + " dstImg.len " + dstImg.length +
                                " dstStrArr:"+UGson.getGson().toJson(dstStrArr) +
                                " time " + yoloF);
                        //拍照 获取到节点图片 然后进行rgb检测 获取检测结果
                        //拍照 获取到节点图片 然后进行rgb检测 获取检测结果
                        boolean detect = RgbYoloV7Obb.Detect(w, h, nodeName, rollerName, bytes, dstImg, dstStrArr);
                        ULog.d(TAG,"yolov7rgb detect result:"+detect);
                        yoloF = System.currentTimeMillis() - yoloF;
                        ULog.d(TAG, "yolov7rgb 结果打印 W:"+w+
                                " H:"+h+
                                " nodeName:"+ nodeName +
                                " rollerName:"+ UGson.getGson().toJson(rollerName)+
                                " srcImg " + UByte.print(bytes, 5) + " srcImg.len " + bytes.length +
                                " dstImg " + UByte.print(dstImg, 5) + " dstImg.len " + dstImg.length +
                                " dstStrArr:"+UGson.getGson() .toJson(dstStrArr)+
                                " time " + yoloF);

                        getActivity().runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                Bitmap tempBitmap = Bitmap.createBitmap(320, 180, Bitmap.Config.ARGB_8888);
                                tempBitmap.copyPixelsFromBuffer(ByteBuffer.wrap(dstImg));

                                iv_detect_img.setImageBitmap(tempBitmap);
                            }
                        });



                    }

                    @Override
                    public void onError(@NonNull Throwable e) {
                        ULog.d(TAG,"yolov7rgb 拍照失败 e:"+e.getMessage());
                    }
                });

            }
        });
    }

    public void yoloBitmapTest(int w, int h, byte[] data) {
        mActivity.runOnUiThread(() -> {
            Bitmap tempBitmap = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
            tempBitmap.copyPixelsFromBuffer(ByteBuffer.wrap(data));
            iv_detect_img.setImageBitmap(tempBitmap);
        });
    }

    private void apnCheck() {
        List<ApnConfig> sysApn = mActivity.getSystemApn();
        List<ApnConfig> localApn = new ArrayList<>();
        String apnStr = StorageCenter.getRobotStorage().getString("apn_config", "");
        ULog.d(TAG, "apnStr = " + apnStr);
        if (!TextUtils.isEmpty(apnStr) && !"[]".equalsIgnoreCase(apnStr)) {
            localApn = new Gson().fromJson(apnStr,  new TypeToken<ArrayList<ApnConfig>>() {
            }.getType());
        }
        for(ApnConfig apn : localApn) {
            if (sysApn.stream().noneMatch(t -> t.getName().equalsIgnoreCase(apn.getName()))) {
                ULog.d(TAG, "需要新增apn : " + apn.getName());
                int newId = mActivity.addAPN(apn);
                ULog.d(TAG, " 新增apn id : " + newId);
            }
        }
    }

    /**
     * GPIO初始化
     */
    private void initGpio() {
        //gpio初始化
        ULog.d(TAG, "GPIO_STM_RESET === init");
        gpioInit(UConstants.GPIO_STM_RESET, 1);
        ULog.d(TAG, "GPIO_STM_RESET === 1");
        gpioCtrl(UConstants.GPIO_STM_RESET, 1);
        gpioInit(UConstants.GPIO_USB_RESET, 1);
        gpioCtrl(UConstants.GPIO_USB_RESET, 1);
        gpioInit(UConstants.GPIO_USB_HOST_RESET, 1);
        gpioCtrl(UConstants.GPIO_USB_HOST_RESET, 1);
        gpioInit(UConstants.GPIO_RFID, 1);
        gpioCtrl(UConstants.GPIO_RFID, 0); //rfid上电
//        SerialManagerUtil.getSerialManager(mActivity).gpio_init(UConstants.GPIO_POWER_OFF, 1);
        ULog.d(TAG, "GPIO_RFID init");

        //PMIC
        ULog.d(TAG, "初始化GPIO PMIC ，dir" + 1);
        SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_init(UConstants.GPIO_PMIC_SLEEP, 1);

    }

    private int SEND_SMS_NO_CHARGING_TIME = 2 * 60_000;
    int steering_engine_test_num;

    //检测网络摄像头是否上电次数
    private int checkWebCameraElectrifyNum = 0;
    //    private String previousCommand;
    private final String inspectionCommand = "inspection";
    //心跳
    //    private int serverHeartErrorNum;
    private boolean serverHeartNormal;
    private long serverHeartNormalTime;
    private int networkErrorNum = 0;

    private boolean isFullBattery; //是否满电 或接近满电 接近满电会加快查询bms信息频率(TODO 以前需要手动开启和关闭充电防止过充用 现在是否仍然需要在接近满电时加快查询频率?)

    /**
     * 是否在充电桩
     */
    public static boolean inCharger;
    public boolean isLowPowerGoTocharger; //低电量回充触发
    private int batteryPowerOff = 97;
    private int batteryPowerOn = 80;
    private boolean batteryAutoOff;
    public static long startInspectTime = 0;

    private int heatControl;//0自动控制 1手动控制

    public static List<Map> mqttMsgList = new ArrayList<>();

    private boolean mIsWaitToWriteRFID = false;
    private byte[] mWaitedRfidTagByte;

    //巡检策略相关计算
    int deltT = 5000; //时间采样间隔
    int meanLen = 36; //样本平滑尺度
    int maxRunTime = 30 * 60; //最大等待时长
    float thresh = 0.03f; //趋势变化条件阈值
    int ctimesThresh = 5; //趋势变化有效最大连续次数

    int ctimes; //趋势变化连续有效次数
    long runTime; //等待时长
    int nSample; //采样次数
    float fT = -10000; //单次采样温度
    float[] pfTArr = new float[meanLen]; //采样温度序列，长度为meanLen的数组
    float fSlope; //趋势值

    private int pushAdjustBitRateNum;

    private boolean netLightOpen;

    private List<OfflineLocation> offlineLocations = new ArrayList<>();
    private List<FireAlarmConfig> fireAlarmConfigs = new ArrayList<>();
    public static Segment mSegment;
    public static List<String> upgradeInfos = new ArrayList<>();
    public static List<String> accounts = new ArrayList<>();
    private List<String> accounts_Y = new ArrayList<>();//运营平台mqtt的id
    public Map<String, Float> envTempeMap = new HashMap<>();
    public static String robotId;
    private boolean handleCheckNodeHead, handleCheckNodeTail;
    private boolean handleCheckNodeHeadBack, handleCheckNodeTailBack;

    public Gson gson = new Gson();

    private long mLastReadRealRFIDTime = 0L;
    private boolean recordLocalSwitch = true;

    //    BMSMATaskExecute bmsMaExecute;
    DecibelTaskExecute decibelExecute;
    //    private int stmUpgradeError;
    private volatile boolean isUpdateRobot = false;
    boolean agingTestGoTOCharger;
    String agingTestChargerId;

    private int targetNodeId; //目标节点id
    private boolean isArrive; //是否达到目标节点

    /**
     * 等待离开充电桩前要执行的命令
     */
    private volatile MqttCommand mCommandBeforeLeaveCharger = null;
    /**
     * 是否等待离开充电桩，如果在充电过程中，需要确保充电关闭才能离开充电桩
     */
    private volatile boolean mIsWaitToLeaveCharger = false;
    /**
     * 重试离开充电桩的次数
     */
    private volatile int mRetryLeaveChargerCount = 0;

    public static volatile int MODE = MODE_UN_KNOW;
    private static int originalMode = MODE_UN_KNOW;        //记录MODE修改前的值
    private Calendar changeModeCalendar;
    /**
     * 设置MODE时的时间 {@link #setMode}
     */
    private Calendar changeTempModeCalendar;
    /**
     * 设置临时MODE的时间 {@link #setTempMode}
     */
    /*--------------end-------------*/

    private int heatOpenThreshold = 4;
    private int heatCloseThreshold = 6;


    private List<Float> maxIr = new ArrayList<>();
    private List<Float> maxIrScale = new ArrayList<>();
    private List<Float> maxIrBack = new ArrayList<>();
    private List<Float> maxIrScaleBack = new ArrayList<>();

    public static float avgDecibel, avgDecibelBack;
    public static int avgDecibelNum, avgDecibelNumBack;

    private volatile boolean irException, irExceptionBack, //紅外是否異常
            audioException, //聲音是否異常
            currentNodeIsExcepted, currentNodeIsExceptedBack, //当前节点是否异常
            currentNodeAudioIsExcepted;

    /**
     * 是否是烟雾异常导致的停止
     */
    private volatile boolean mIsSmokeExceptionStop = false;

    private volatile Map<Integer, Boolean> temperatureAlarm = new HashMap<>(); //储存同个节点不同位置的数据
    private volatile Integer temperatureAlarmSize = 0; //temperatureAlarm的长度

    /*-------------到位信号--------------*/
    static final int SIGNAL_NO_PLACE = 0;
    static final int SIGNAL_IN_PLACE = 1;
    static final int SIGNAL_BOUNDS = 2;
    /*--------------end-------------*/
    //每次移动默认圈数
    public static int defaultRotate = 32;

    //行驶方向
    public static volatile int robotDirection = StmTask.MOVE_END;

    //rfid方向
    public static int rfidDirection = 0;

    AudioManager mAudioManager;
    AudioRecorder audioRecorder;

    PushManager irPusher;
    WebCameraPusher webPusher;

    //mediaCodec 编码
    int width, height;
    int widthRgb, pushWidthRgb;
    int heightRgb, pushHeightRgb;
    int widthIr, pushWidthIr; //= 240;
    int heightIr, pushHeightIr;// = 184;
    int frameRate = 9;
    int bitrate = 10000000; //10m bps/s
    AvcEncoder avcCodec;
    final Object avcLock = new Object();

    //--------------callback data code end-------------------


    int irStatus = StmTask.EX_ROLLER_NORMAL,
            decibelStatus = StmTask.EX_DECIBEL_NORMAL,
            batteryStatus = StmTask.EX_BATTERY_NORMAL;


    private int inspectionUseAngleType = 0;//巡检时摄像头角度用反向或正向(检测甲乙皮带 或普通正常巡检)

    volatile boolean libIniting = false;

    /**
     * 战略后退防止电机长时间过流造成失速
     */
    private volatile boolean mIsBackwardToAvoidStilling = false;

    /**
     * 电流连续超过阈值的次数
     */
    private int mMotorOverCurrentNumber = 0;

    /**
     * 记录掉头重试前里程
     */
    private float mDistanceBeforeBackward = 0f;
    /**
     * 记录掉头前速度
     */
    private float mSpeedBeforeBackward = 0f;
    /**
     * 反向移动的距离差
     */
    private final float DISTANCE_BACKWARD = 0.5f;


    /**
     * 电机保护报警计次，包括过流和运动阻碍
     */
    private volatile int mMotorAlertCount = 0;

    /**
     * 上一次电机管理板报警时间
     */
    private long mLastMotorManagerAlarmTime = 0L;

    /**
     * 电机过流后退完成恢复时，是否
     */
    private boolean mIsNeedToSpeedUp = false;
    /**
     * 失速保护及轮子打滑保护掉头前的延迟时间
     */
    private final long TIME_SLEEP_BEFORE_MOVE_BACKWARD = 1000;

    /**
     * 记录烟雾报警前的机器人模式
     */
    private int mRobotModeBeforeSmokeException = MODE_UN_KNOW;

    //量产测试标识
    public static boolean batch_production_test_power_bms_network,
            batch_production_test_wired_charging,
            batch_production_test_emergency_stop,
            batch_production_test_front_obstacle,
            batch_production_test_behind_obstacle,
            batch_production_test_audio_decibel,
            batch_production_test_rfid,
            batch_production_test_in_place,
            batch_production_test_wireless_charging;
    boolean test_wired_charging, test_wireless_charging;
    int checkInPlaceSwitchNum;

    private float lastHinderAlarmLocation; //上次运动阻碍报警的位置
    private long lastHinderAlarmTime; //上次运动阻碍报警的时间
    float mMotorCurrent = UConstants.UNKONW;//电机电流
    float mMotorCurrent2 = UConstants.UNKONW;//电机电流
    public static float mDistance = UConstants.UNKONW;
    public static float mLastDistance = UConstants.UNKONW;
    public static long mLastBmsInfoTime = UConstants.UNKONW;
    public static long mLastInspectTime = UConstants.UNKONW;
    double mMotorSpeed;
    static boolean saveDistanceFlag; //是否记录过里程
    static float distanceCheck;

    private InspectionEnable mInspectionEnableThread = null;
    private List<BeltRunStatus> beltRunStatuses = new ArrayList<>();

    //    private ArrayBlockingQueue<byte[]> irBuffer = new ArrayBlockingQueue(3),
    //            rgbBuffer = new ArrayBlockingQueue(3),
    //            pushBuffer = new ArrayBlockingQueue(3),
    //            recordBuffer = new ArrayBlockingQueue(3);
    private volatile VideoBuff[] irBuff = new VideoBuff[4];
    private volatile VideoBuff[] rgbBuff = new VideoBuff[4];
    private volatile VideoBuff[] pushBuff = new VideoBuff[4];
    private volatile VideoBuff[] recordBuff = new VideoBuff[4];

    private int irBuffIndex, rgbBuffIndex, pushBuffIndex, recordBuffIndex, //存索引
            irBuffIndexTemp, rgbBuffIndexTemp, pushBuffIndexTemp, recordBuffIndexTemp //存临时变量
            , irBuffUseIndex, rgbBuffUseIndex, pushBuffUseIndex, recordBuffUseIndex //取索引
            , irBuffUseIndexTemp, rgbBuffUseIndexTemp, pushBuffUseIndexTemp, recordBuffUseIndexTemp; //取临时变量

    private byte[] pushFrame, outputFrame;
    private LoraTaskExecute loraTaskExecute;
    private int sendMessageMode;//0:mqtt 1:lora
    private boolean isCloseRepeatCharge = false;//是否强制断开充电
    public static short mCurrent = -1;//电流
    private int powerKeyLowVoltageNum = 0;
    private String nearestChargerId;//距离最近的充电桩id
//    private List<Charger> chargers = new ArrayList<>();//线段上所有充电桩
    private int lastRobotDirection;//记录之前的方向
    private static boolean isSleep;//是否待机
    private boolean isSoftEmergencyStop;//是否软件急停
    private boolean rgbLensDirtyState;//rgb镜头是否污损
    private int gotoChargerCrossingNum = 0;//回充越界次数（超过10次报警）
    private static final int WORKER = 0;//现场工作人员
    private static final int OPERATION = 1;//运维工程师


    private long motionHinderTime;


    private Disposable mRobotInfoDisposable = null;
    private boolean isCorridorInspection;//是否是巡检廊道
    public static boolean isNeedCheckAruco;//是否需要识别Aruco码
    private int cokeOvenInspectRepeatNum;
    public static boolean isServerStartRecognise; //焦炉识别服务器是否开始识别
    public static boolean isCokeOvenDecelerateEnable = false; //焦炉减速是否启用
    public static boolean isCokeOvenInspectMqttEnable = true; //焦炉巡检mqtt确认信息

    private static volatile boolean mIsRobotInitialized = false;//机器人是否走完初始化流程
    public static  boolean isRobotInitialized(){
        return mIsRobotInitialized;
    }

    private int rgbRecognitionRepeatNum; //rgb识别消息重试次数
    public static boolean isServerStartRecogniseRGB; //rgb识别服务器是否开始识别

    private int recordVideoRecogRepeatNum; //录视频自动标定消息重试次数
    public static boolean isServerStartRecordVideoRecog; //录视频自动标定 服务器是否开始识别

    private AlarmManager mAlarmManager = null;

    public long mLastCleanDeviceTimestamp = 0L;

    private long mLastDustingDurationMillSeconds = 0L;


    /**
     * 除尘的最大和最小里程范围
     */
    public float mDustingDistanceMin = -1000.0f;
    public float mDustingDistanceMax = -1000.0f;

    /**
     * 传感器配置管理类
     */
    private SensorManager mSensorManager = null;
    /**
     * 传感器数据、状态配置
     */
    private ConcurrentHashMap<String, List<SensorData>> mSensorsData = new ConcurrentHashMap<>();

    private volatile Disposable mStmConfigDisposable = null;

    private boolean mIsStmInSleepMode = false;


    public RobotInfoManager mBotInfoMgr = null;

    /**
     * 一些内置传感器使能状态 (除尘的时候会对一些传感器断电 防止灰尘影响误报可能)
     * 目前对比心跳发现 对 以下传感器生效
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.outsideTempValue}   外部温度    v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.outsideHumidityValue}   外部湿度    v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.coValue}   一氧化碳     v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.co2Value}   二氧化碳    v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.ch4Value}   甲烷      v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.h2sValue}   硫化氢     v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.nh3Value}   氨气      v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.o2Value}   氧气       v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.sf6Value}   六氟化硫        v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.pm25Value}   PM2.5      v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.pm10Value}   PM10       v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.h2Value}   氢气       v
     * {@link fun.unifun.robot.brain.platform.bean.StmStandardHeartData.smokeStatus}    烟雾(设置为无烟)      v
     * 气体采集板        v   processGasBoardDataChange
     * 六合一 实际是使用的PM2.5的状态 pm2.5 pm10 外部温度  外部湿度 合到一块儿 v processGasBoardDataChange
     *  sensorEnableStatus 为false的时候将上传感器的数值设置成0 并且不检测报警
     *
     */
    private boolean sensorEnableStatus;

    /**
     * 下位机地图是否需要更新
     */
    private boolean mNeedUpdateStmMap = false;

    private static Robot getRobot() {
        return MainApp.mRobot;
    }

    public boolean isCorridorInspection() {
        return isCorridorInspection;
    }

    public void setCorridorInspection(boolean isCorridorInspection) {
        ULog.d(TAG, "廊道巡检 setCorridorInspection=" + isCorridorInspection);
        this.isCorridorInspection = isCorridorInspection;
        if (!this.isCorridorInspection) {
            inspectManager.lastSwitchNodeInfoFrontTime = 0;
            inspectManager.lastSwitchNodeInfoEndTime = 0;
        }
    }


//    public float getFirstDistance() {
//        if (mDistance != UConstants.UNKONW) {
//            return mDistance;
//        }
//        if (getRobot().getMapNodeId() != null && getRobot().getMapNodeId() != -1 && getRobot().getMapNodeId() != 0) {
//            return inspectManager.getDistanceByNodeId(getRobot().getMapNodeId());
//        }
//
//        return UConstants.UNKONW;
//    }

    //================== IrService ===========================
    private void bindIrService() {
        ULog.d(TAG, "ir ===== bindIrService: ");
        Intent intent = new Intent(mActivity, IRService.class);
        isIrBind = mActivity.bindService(intent, irConnection, Activity.BIND_AUTO_CREATE);
    }

    IRService irService;
    IRService.IrBinder irBinder;
    ServiceConnection irConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            ULog.d(TAG, "ir ===== onServiceConnected: " + name);
            if (mHandler.hasMessages(Msg.WHAT_BIND_IR_SERVICE)) {
                mHandler.removeMessages(Msg.WHAT_BIND_IR_SERVICE);
            }
            try {
                //设置死亡代理
                service.linkToDeath(irDeathRecipient, 0);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            irBinder = (IRService.IrBinder) service;
            irService = irBinder.getIrService();
            irService.setCallbackType(pushType);
            irService.registerIrDataCallback(RobotFragment.this);
            /**
             * 红外数据监听逻辑
             * UVCCamera ->  IRayDev  ->	IrManager	->	IRService 	->	RobotFragment
             * RobotFragmen创建IRService对象
             * IRService onCreate的时候会通过 initIrParam方法创建 irManager对象  initIrDevices方法 中调用了irManager的init
             * IrManager通过 mUsbMonitor 注册了红外设备监听
             *
             * IrManager 通过 mUsbMonitor 实现 {@link fun.unifun.robot.brain.platform.camera.ir.IrManager#onConnect}方法 并在该方法创建IRayDev对象
             * IRayDev 通过 {@link fun.unifun.robot.brain.platform.camera.ir.dev.IRayDev#open}方法中 通过UVCCamera setTemperatureCallback 设置UVCCamear 的数据回调 通过temperatureCallback往外发
             * IrManager 通过 {@link fun.unifun.robot.brain.platform.camera.ir.IrManager#start}方法中 registerTemperatureCallback 注册红外数据回调
             * IrManager 通过 {@link fun.unifun.robot.brain.platform.camera.ir.IrManager.ThermalTemperatureCompute}线程处理 原始数据转成图像 并通过 thermalDataCallback 分发红外数据
             * IRService registerIrDataCallback方法 实现 {@link fun.unifun.robot.brain.platform.camera.ir.IrManager.ThermalDataCallback} 并通过 irDataCallback往下层传递
             * RobotFragment registerIrDataCallback 实现 {@link fun.unifun.robot.brain.platform.services.IRService.IrDataCallback} 处理各种回调数据
             */
            irService.registerIrFrameTempCallback(RobotFragment.this);
            if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_ARR)) {
                mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_ARR);
            }
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_SET_PUT_TEXT, 5000);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            ULog.d(TAG, "ir ===== onServiceDisconnected:  " + name);
        }
    };

    //死亡代理
    private IBinder.DeathRecipient irDeathRecipient = new IBinder.DeathRecipient() {
        @Override
        public void binderDied() {
            ULog.d(TAG, "ir ===== binderDied: 连接断开");
            //解绑
            if (irBinder != null) {
                irBinder.unlinkToDeath(irDeathRecipient, 0);
                irBinder = null;
            }
            //断开重新绑定
            if (!mHandler.hasMessages(Msg.WHAT_BIND_IR_SERVICE)) {
                mHandler.sendEmptyMessage(Msg.WHAT_BIND_IR_SERVICE);
            }
        }
    };

    public boolean irServiceIsAlive() {
        if (irBinder != null && irBinder.isBinderAlive()) {
            return true;
        }
        if (!mHandler.hasMessages(Msg.WHAT_BIND_IR_SERVICE)) {
            mHandler.sendEmptyMessage(Msg.WHAT_BIND_IR_SERVICE);
        }
        return false;
    }

    public void setTaskObj(List<TaskObj> taskObjs, TaskNode checkTaskNode) {
        if (irService != null) {
            irService.setTaskObjs(taskObjs, checkTaskNode);
        }
    }

    public void setTaskObjBack(List<TaskObj> taskObjs, TaskNode checkTaskNodeBack) {
        if (irService != null) {
            irService.setTaskObjsBack(taskObjs, checkTaskNodeBack);
        }
    }

    public void setTaskTypeParams(SparseArray<String> typeParams) {
        if (irService != null) {
            irService.setTypeParams(typeParams);
        }
    }
    // ==================== rgbService ===================================

    private void bindRgbService() {
        ULog.d(TAG, "rgb ===== bindRgbService: ");
        Intent intent = new Intent(mActivity, RgbService.class);
        isRgbBind = mActivity.bindService(intent, rgbConnection, Activity.BIND_AUTO_CREATE);
    }

    RgbService rgbService;
    RgbService.RgbBinder rgbBinder;
    ServiceConnection rgbConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            ULog.d(TAG, "rgb ===== onServiceConnected: " + name);
            if (mHandler.hasMessages(Msg.WHAT_BIND_RGB_SERVICE)) {
                mHandler.removeMessages(Msg.WHAT_BIND_RGB_SERVICE);
            }
            try {
                //设置死亡代理
                service.linkToDeath(rgbDeathRecipient, 0);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            rgbBinder = (RgbService.RgbBinder) service;
            rgbService = rgbBinder.getRgbService();
            rgbService.registerRgbDataCallback(RobotFragment.this);
            mHandler.sendEmptyMessage(Msg.WHAT_INIT_RGB_ARR);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            ULog.d(TAG, "rgb ===== onServiceDisconnected:  " + name);
        }
    };
    //死亡代理
    private IBinder.DeathRecipient rgbDeathRecipient = new IBinder.DeathRecipient() {
        @Override
        public void binderDied() {
            ULog.d(TAG, "rgb ===== binderDied: 连接断开");
            //解绑
            if (rgbBinder != null) {
                rgbBinder.unlinkToDeath(rgbDeathRecipient, 0);
                rgbBinder = null;
            }
            //断开重新绑定
            if (!mHandler.hasMessages(Msg.WHAT_BIND_RGB_SERVICE)) {
                mHandler.sendEmptyMessage(Msg.WHAT_BIND_RGB_SERVICE);
            }
        }
    };

    private boolean rgbServiceIsAlive() {
        if (rgbBinder != null && rgbBinder.isBinderAlive()) {
            return true;
        }
        if (!mHandler.hasMessages(Msg.WHAT_BIND_RGB_SERVICE)) {
            mHandler.sendEmptyMessage(Msg.WHAT_BIND_RGB_SERVICE);
        }
        return false;
    }

    // ==================== NetworkService ===================================

    private void bindNetworkService() {
        ULog.d(TAG, "AP ===== bindNetworkService: ");
        Intent intent = new Intent(mActivity, NetworkService.class);
        isNetworkBind = mActivity.bindService(intent, networkConnection, Activity.BIND_AUTO_CREATE);
    }

    NetworkService networkService;
    NetworkService.NetworkBinder networkBinder;
    ServiceConnection networkConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            ULog.d(TAG, "ap ===== onServiceConnected: " + name);
            if (mHandler.hasMessages(Msg.WHAT_BIND_NETWORK_SERVICE)) {
                mHandler.removeMessages(Msg.WHAT_BIND_NETWORK_SERVICE);
            }
            try {
                //设置死亡代理
                service.linkToDeath(apDeathRecipient, 0);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
            networkBinder = (NetworkService.NetworkBinder) service;
            networkService = networkBinder.getNetworkService();
            networkService.setMobileNetworkStatusInterface(new NetworkService.MobileNetworkStatusInterface() {
                @Override
                public void mobileNetworkDisconnect() {
                    ULog.d(TAG, "MobileNetwork 开关飞行模式3分钟未恢复网络，重启机器 低电量条件 = " + isLowPowerGoTocharger);
                    if (isLowPowerGoTocharger) return;
                    if (mRobotType.getSubType() != RobotSubType.BZ) {
                        if(mCurrent >= 0 ){
                            ULog.d(TAG, "MobileNetwork 类型不支持电池重启，执行系统重启");
                            mActivity.writePowerOffLog("MobileNetwork-Disconnect_1");
                            try {
                                Thread.sleep(100);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            URootCmd.execRootCmdSilent("reboot -p");
                        }else{
                            int time = 20;
                            BaseBmsCommunicator.getInstance().enterPowerSaveMode(time, "MobileNetwork-Disconnect_2");
                        }
                    } else {
                        ULog.d(TAG, "MobileNetwork 类型不支持电池重启，执行系统重启");
                        mActivity.writePowerOffLog("MobileNetwork-Disconnect_3");
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        URootCmd.execRootCmdSilent("reboot -p");
                    }
                }
            });
            //连接指定AP
            networkService.setWifiStateCallback(RobotFragment.this);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
            ULog.d(TAG, "ap ===== onServiceDisconnected:  " + name);
        }
    };

    //死亡代理
    private IBinder.DeathRecipient apDeathRecipient = new IBinder.DeathRecipient() {
        @Override
        public void binderDied() {
            ULog.d(TAG, "ap ===== binderDied: 连接断开");
            //解绑
            if (networkBinder != null) {
                networkBinder.unlinkToDeath(apDeathRecipient, 0);
                networkBinder = null;
            }
            //断开重新绑定
            if (!mHandler.hasMessages(Msg.WHAT_BIND_NETWORK_SERVICE)) {
                mHandler.sendEmptyMessage(Msg.WHAT_BIND_NETWORK_SERVICE);
            }
        }
    };

    private boolean networdServiceIsAlive() {
        if (networkBinder != null && networkBinder.isBinderAlive()) {
            return true;
        }
        if (!mHandler.hasMessages(Msg.WHAT_BIND_NETWORK_SERVICE)) {
            mHandler.sendEmptyMessage(Msg.WHAT_BIND_NETWORK_SERVICE);
        }
        return false;
    }

    /**
     * 是否需要启动检测自动巡检线程
     *
     * @return boolean
     */
    private boolean getInspectEnableThreadNeedExec() {
        if (mInspectionEnableThread == null) {
            mInspectionEnableThread = new InspectionEnable();
            return true;
        }
        if (mInspectionEnableThread.isAlive() || mInspectionEnableThread.getState() == Thread.State.RUNNABLE) {
            return false;
        }
        mInspectionEnableThread = new InspectionEnable();
        return true;
    }

    private void initConfig() {
        ULog.d(TAG, "initConfig = " + mActivity.getPackageName());

        mAlarmManager = AlarmManager.getInstance(MainApp.getInstance());
        mBotInfoMgr = RobotInfoManager.getInstance();
        mBotInfoMgr.init(BaseApplication.getInstance().getApplicationContext());
        PerformanceManager.getInstance().startStm32TempCheck(PerformanceManager.DEVICE_TYPE_ROBOT);
        RfidLostChecker.getInstance();
        ChargerNodeManager.getInstance().init();
        HealthChecker.getInstance();

        //        SpeedDetector.getInstance().init(null);
        //        SpeedDetector.getInstance().startDetector();


        if (UConstants.isFirstBoot(mActivity)) {
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_ROBOT_STM_HEART_EXCEPTION_NUM_KEY, 0);
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_DECIBEL_EXCEPTION_KEY, 0);
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_MIC_EXCEPTION_KEY, 0);
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_STM_EXCEPTION_KEY, 0);
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_MOTOR_EXCEPTION_KEY, 0);
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_IR_EXCEPTION_KEY, 0);
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_PUSH_TYPE_INDEX_KEY, 0);
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_INSPECT_IS_SELF, false);
        } else {
            isStmBootUp = true;
        }
        isCloseRepeatCharge = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_ROBOT_FORCE_CLOSE_CHARGING_KEY, false);
        ULog.d(TAG, "重复上电保持状态：" + isCloseRepeatCharge);


        mMqttManager = MqttManager.getInstance();
        mInspectionEnableThread = new InspectionEnable();

        loraTaskExecute = LoraTaskExecute.getInstance(mActivity);
        serverHeartNormal = true;
        isBeltConveyorStart = UPreferences.getInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 0) == 1;
        MainApp.beltStartDate = UPreferences.getLong(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_START_DATE_KEY, 0);
        inspectionUseAngleType = UPreferences.getInt(mActivity, UConstants.PREFERENCES_INSPECTION_USE_ANGLE_TYPE_KEY, 0);
        mInfraredCameraIsShowArea = UPreferences.getBoolean(mActivity, UConstants.KEY_INFRARED_CAMERA_IS_SHOW_AREA, false);
        MainApp.networkIsMobile = UPreferences.getBoolean(mActivity, UConstants.PREFERENCE_IS_MOBILE_NETWORK_KEY, false);
        isSoftEmergencyStop = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_ROBOT_SOFT_EMERGENCY_STOP_KEY, false);
        MainApp.stmHeartExceptionNum = UPreferences.getInt(mActivity, UConstants.PREFERENCES_ROBOT_STM_HEART_EXCEPTION_NUM_KEY, 0);
        MainApp.softEmergencyStopButton = isSoftEmergencyStop ? 1 : 0;

        rgbLensDirtyState = UPreferences.getBoolean(mActivity, UConstants.KEY_RGB_LENS_DIRTY_STATE, false);

        inspectManager = InspectManager.getInstance(MainApp.getInstance(), this);
        autoMoveManager = AutoMoveManager.getInstance(MainApp.getInstance(), this);

        loraTaskExecute.registerOnTaskListener(this);

        robotId = UPreferences.getString(mActivity, UConstants.PREFERENCE_KEY_DEVICE_SN);

        irPusher = getIrPusher();
        webPusher = getWebCameraPusher();

        initFileDir();
        mHandler.sendEmptyMessage(Msg.WHAT_BIND_GUARD_SERVICE);
        if (!mHandler.hasMessages(Msg.WHAT_BIND_NETWORK_SERVICE)) {
            mHandler.sendEmptyMessage(Msg.WHAT_BIND_NETWORK_SERVICE);
        }
        if (UConstants.isFirstBoot(mActivity)) { //开机广播启动
            ULog.d(TAG, "upgrade = 第一次开机 set stmNormal false");
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCE_STM_BOOT_KEY, false);
            stmUpgradeCheckNum = 0;
            rkUpgradeCheckNum = 0;
            mHandler.sendEmptyMessage(Msg.WHAT_FIRST_UPGRADE);
        } else {
            initData();
        }

        //        mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR);//初始化SDK
        //        if (true) return;
        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR, 10000);

        //        boolean isConfigByBt = UPreferences.getBoolean(getActivity(), UConstants.KEY_IS_CONFIG_THROUGH_BLUETOOTH, false);
        //        if (isConfigByBt) {
        //            UPreferences.putBoolean(getActivity(), UConstants.KEY_IS_CONFIG_THROUGH_BLUETOOTH, false);
        //        }


/*        Observable.interval(3,TimeUnit.SECONDS)
                .observeOn(Schedulers.io())
                .subscribe(t -> {
                    rfidExecute.executeTask(new RFIDTask().setWorkMode(RFIDTask.WorkMode.MODE_ONCE_TRIGGER,
                            RFIDTask.WorkMode.DATA_OUTPUT_MODE_SERIAL, 50));

                    rfidExecute.executeTask(new RFIDTask().readHardwareVersion());
                });*/

    }

    private void initYoloV7Obb(){
        IrYoloV7ObbUtil.getInstance().initModel();
        RgbYoloV7ObbUtil.getInstance().initModel();
    }
    //里程和电流测试开关(轨道测试用)
    private boolean distanceAndMotorCurrentTestLogSwitch = false;
    private PrintWriter printWriter;
    private String uploadIrFrameHost;
    private boolean isUploadIrFrameTemp = false, lastIsUploadIrFrameTemp = false, uploadIrFrameTempJump = true;
    volatile float[] jumperUploadFrame = null;
    volatile int jumperUploadStatus; //0 未填充数据 1 填充完毕 2 使用中

    //    int onIrFrameTempDataNum;
    @Override
    public void onIrFrameTempData(int index, int width, int height, float[] data) {
        //        ULog.d(TAG, "onIrFrameTempData = " + index + " width " + width + " height " + height + " data " + data.length);
        boolean isError = true;
        for (int i = 0; i < 20; i++) {
            if (data[i] != 0) {
                isError = false;
                break;
            }
        }
        if (isError) return;
        //        onIrFrameTempDataNum++;
        //        boolean isUpload = false;
        //        if (onIrFrameTempDataNum % 100 == 0) {
        //            isUpload = true;
        //        }
        if (isUploadIrFrameTemp && jumperUploadStatus == 0 && !TextUtils.isEmpty(uploadIrFrameHost) && index == 0 && getRobot() != null) {
            if (jumperUploadFrame == null) {
                jumperUploadFrame = new float[data.length];
            }

            System.arraycopy(data, 0, jumperUploadFrame, 0, data.length);
            ULog.d(TAG, "uploadTempFrameData 刷新数据");
            jumperUploadStatus = 1;
            if (!uploadTempFrameData.isAlive()) {
                uploadTempFrameData.start();
            }
        }
    }
    Thread uploadTempFrameData = new Thread(() -> {
        while(true) {
            if (jumperUploadStatus != 1) {
                try {
                    Thread.sleep(30);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                continue;
            }
            if (!lastIsUploadIrFrameTemp && isUploadIrFrameTemp) {
                jumperUploadStatus = 0;
                lastIsUploadIrFrameTemp = isUploadIrFrameTemp;
                continue;
            }
            if (!isUploadIrFrameTemp) {
                lastIsUploadIrFrameTemp = isUploadIrFrameTemp;
                continue;
            }
            if (!uploadIrFrameTempJump) { continue;}
            jumperUploadStatus = 2;

            UploadTempFrameData request = new UploadTempFrameData();
            request.setWidth(width);
            request.setHeight(height);
            request.setRobotId(getRobot().getId());
            request.setUploadTime(System.currentTimeMillis());
            request.setTemperature(jumperUploadFrame);


            long time = System.currentTimeMillis();
            //        ULog.d(TAG, "uploadTempFrameData ==params = "); // + gson.toJson(request));
            //        UOKHttp.post("http://jumper.320.io:53139", request, new UOKHttp.RequestCallBack<UploadTempFrameData>(UploadTempFrameData.class) {
            UOKHttp.post(uploadIrFrameHost, request, new UOKHttp.RequestCallBack<UploadTempFrameData>(UploadTempFrameData.class) {
                @Override
                public void onFailure(Call call, IOException e) {
                    ULog.d(TAG, "onFailure == uploadTempFrameData time " + (System.currentTimeMillis() - time));
                    jumperUploadStatus = 0;
                }

                @Override
                public void onResponseOk(Call call, UploadTempFrameData o) {
                    ULog.d(TAG, "onResponseOk == uploadTempFrameData time " + (System.currentTimeMillis() - time));
                    jumperUploadStatus = 0;
                    uploadIrFrameTempJump = false;
                }

                @Override
                public void onResponseError(Call call, int i, String s) {
                    ULog.d(TAG, "onResponseError == uploadTempFrameData " + s + " time " + (System.currentTimeMillis() - time));
                    jumperUploadStatus = 0;
                }
            });
        }
    });

    interface IDistanceAndMotorCurrentTestLogListener {
        void onDataBack(float distance, float motorCurrent, float motorCurrent2);
    }

    private IDistanceAndMotorCurrentTestLogListener testMotorCurrentListener;

    private void setTestMotorCurrentListener(IDistanceAndMotorCurrentTestLogListener testMotorCurrentListener) {
        this.testMotorCurrentListener = testMotorCurrentListener;
    }


    private boolean distanceAndMotorCurrentTestLogUploading = false;

    Timer timer;
    int irTestTime;
    /**
     * 初始化界面
     */
    private void initView() {
        GuardModeManager.getInstance().initRobotFragment(RobotFragment.this);
        //        Button btMoveStop = mView.findViewById(R.id.bt_move_stop);
        tvCam = mView.findViewById(R.id.tv_camera_params);
        tvSE = mView.findViewById(R.id.tv_se_params);
        tvDistance = mView.findViewById(R.id.tv_distance);
        etSE = mView.findViewById(R.id.et_text);
        etCam = mView.findViewById(R.id.et_cam);
        mView.findViewById(R.id.bt_play).setOnClickListener(view -> {
            if (isPlay) {
                ((Button) mView.findViewById(R.id.bt_play)).setText("播放");
                mActivity.stopPlay();
                isPlay = false;
            } else {
                if (pushWidthIr != 0 && pushHeightIr != 0 && getRobot() != null) {
                    String ip = null;
                    if (SensorInfoProvider.of(getRobot().getId()).cacheInfo().WEBCAM_INFO != null) {
                        ip = getRobot().getNetworkCameraIp();
                        if (ip == null) {
                            ip = "192.168.1.160";
                        }
                    }
                    mActivity.play(pushWidthIr, pushHeightIr, ip);
                    ((Button) mView.findViewById(R.id.bt_play)).setText(R.string.stop);
                    isPlay = true;
                }
            }
        });
        mView.findViewById(R.id.bt_set_se_param).setOnClickListener(view -> {
            String angleStr = etSE.getText().toString();
            if (!TextUtils.isEmpty(angleStr) && angleStr.contains("/")) {
                String[] arr = angleStr.split("/");
                if (arr.length == 2) {
                    float H = Float.parseFloat(arr[0]);
                    float V = Float.parseFloat(arr[1]);
                    stmExecute.executeTask(new StmTask().setSteerEngineAngle(1, 1, H));
                    stmExecute.executeTask(new StmTask().setSteerEngineAngle(1, 2, V));

                    SteerController.getInstance().setSteerAngle(H, V, RobotSetSpeedLogTags.SPEELD_lOG_TAG_11);
                    tvSE.setText("舵机H:" + SteerController.getInstance().getCurHAngle() + " V:" + SteerController.getInstance()
                            .getCurVAngle());
                }
            }
        });
        mView.findViewById(R.id.bt_set_cam_param).setOnClickListener(view -> {
            String angleStr = etCam.getText().toString();
            if (!TextUtils.isEmpty(angleStr) && angleStr.contains("/")) {
                String[] arr = angleStr.split("/");
                if (arr.length == 2) {
                    int z = Integer.parseInt(arr[0]);
                    int f = Integer.parseInt(arr[1]);
                    ZhstWebCameraManager.getInstance().settingWebcamZoomAndFocus(z, f);
                }
            }
        });
        final boolean[] flag2 = {false};
        tvShowEpc = mView.findViewById(R.id.tv_show_epc);
        mView.findViewById(R.id.bt_read_rfid).setOnClickListener(view -> {
            if (rfidReadType == 2 || rfidReadType == 3) {
                stmExecute.executeTask(new StmTask().rfidReadCurrentEpc());
                RobotFragment.this.getActivity().runOnUiThread(() -> tvShowEpc.setText("epc:-"));
            }else{
                RobotFragment.this.getActivity().runOnUiThread(() -> tvShowEpc.setText("epc:非下位机读标签类型"));
            }
        });

        mView.findViewById(R.id.bt_ele_clear_cache).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ElevatorController.clearCacheForTest();
                ElevatorController.getInstance(RobotFragment.this).initCacheForTest();
            }
        });
        mView.findViewById(R.id.bt_light_level_percent).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                try {
                    String percent = etSE.getText().toString();
                    if (!TextUtils.isEmpty(percent)) {
                        FillLightController.fillLightLevelPercent = Integer.parseInt(percent);
                    }
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                }
            }
        });

        mView.findViewById(R.id.bt_get_camera_param).setOnClickListener(view -> getCameraParam());
        mView.findViewById(R.id.bt_save_task_node).setOnClickListener(view -> {
            TaskNode node = new TaskNode();
            if (mSegment.getMapId() != null)
                node.setMapId(mSegment.getMapId());
            node.setStartLocation(mDistance);

            node.setAngleJson("{\"angleH\":" + SteerController.getInstance().getCurHAngle() + ",\"angleV\":" + SteerController.getInstance()
                    .getCurVAngle() +
                    "}");
            if (mZoom != UConstants.UNKONW && mFocus != UConstants.UNKONW) {
                node.setWebcamJson("{\"focuspos\":" + mFocus + ",\"zoompos\":" + mZoom + "}");
            }
            node.setType(NodeType.OTHER);
            getExecutorService().execute(new InspectManager.SaveTaskNode(node));

        });
        mView.findViewById(R.id.bt_upload_task_node).setOnClickListener(view -> {
            getExecutorService().execute(new InspectManager.UploadTaskNode());
        });
        mView.findViewById(R.id.bt_sensor_enable).setOnClickListener(view -> {
//            SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_RFID, 0);
//            stmExecute.executeTask(new StmTask().switchComponentEnable(true, StmTask.FuncPowerBit.BIT_SENSOR_POWER));
//            mMqttManager.sendMessageToSelf(MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_INSPECTION_START_COKE_OVEN_RECOGNISE_READY_ACTION);
            WebCameraPusher.setManualSwitch(true);
        });
        mView.findViewById(R.id.bt_sensor_disable).setOnClickListener(view -> {
//            SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_RFID, 1);
//            stmExecute.executeTask(new StmTask().switchComponentEnable(false, StmTask.FuncPowerBit.BIT_SENSOR_POWER));
//            mMqttManager.sendMessageToSelf(MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_INSPECTION_STOP_COKE_OVEN_RECOGNISE_READY_ACTION);
            WebCameraPusher.setManualSwitch(false);
        });

//        MainApp.isLocalRecordVideo = UPreferences.getBoolean(mActivity, "isLocalRecordVideo", false);
//        mView.findViewById(R.id.bt_video_record).setOnClickListener(view -> {
//            MainApp.isLocalRecordVideo = !MainApp.isLocalRecordVideo;
//            UPreferences.putBoolean(mActivity, "isLocalRecordVideo", MainApp.isLocalRecordVideo);
//            if (MainApp.isLocalRecordVideo) {
//                ((Button)mView.findViewById(R.id.bt_video_record)).setText("本地录制:开");
//            } else {
//                ((Button)mView.findViewById(R.id.bt_video_record)).setText("本地录制:关");
//            }
//        });
//
//        if (MainApp.isLocalRecordVideo) {
//            ((Button)mView.findViewById(R.id.bt_video_record)).setText("本地录制:开");
//        } else {
//            ((Button)mView.findViewById(R.id.bt_video_record)).setText("本地录制:关");
//        }

        if (isCokeOvenDecelerateEnable) {
            ((Button)mView.findViewById(R.id.bt_coke_oven_decelerate)).setText("焦炉减速:开");
        } else {
            ((Button)mView.findViewById(R.id.bt_coke_oven_decelerate)).setText("焦炉减速:关");
        }
        mView.findViewById(R.id.bt_coke_oven_decelerate).setOnClickListener(view -> {
            isCokeOvenDecelerateEnable = !isCokeOvenDecelerateEnable;
            if (isCokeOvenDecelerateEnable) {
                ((Button)mView.findViewById(R.id.bt_coke_oven_decelerate)).setText("焦炉减速:开");
            } else {
                ((Button)mView.findViewById(R.id.bt_coke_oven_decelerate)).setText("焦炉减速:关");
            }
        });
        if (isCokeOvenInspectMqttEnable) {
            ((Button)mView.findViewById(R.id.bt_coke_oven_mqtt)).setText("焦炉mqtt:开");
        } else {
            ((Button)mView.findViewById(R.id.bt_coke_oven_mqtt)).setText("焦炉mqtt:关");
        }
        mView.findViewById(R.id.bt_coke_oven_mqtt).setOnClickListener(view -> {
            isCokeOvenInspectMqttEnable = !isCokeOvenInspectMqttEnable;
            if (isCokeOvenInspectMqttEnable) {
                ((Button)mView.findViewById(R.id.bt_coke_oven_mqtt)).setText("焦炉mqtt:开");
            } else {
                ((Button)mView.findViewById(R.id.bt_coke_oven_mqtt)).setText("焦炉mqtt:关");
            }
        });
        mView.findViewById(R.id.bt_move_front).setOnClickListener(view -> {
//            setSpeed(0.35f, "bt_move_front");
            robotMove(StmTask.MOVE_FRONT);
//            gpioCtrl(UConstants.GPIO_POWER_OFF, 1);
//            getWebCameraPusher().rollBackPush(System.currentTimeMillis() - 40_000);
        });
        mView.findViewById(R.id.bt_move_back).setOnClickListener(view -> {
//            setSpeed(0.35f, "bt_move_back");
            robotMove(MOVE_END);
//            getWebCameraPusher().rollBackLogTest();
//            gpioCtrl(UConstants.GPIO_POWER_OFF, 0);
//                .observeOn(Schedulers.computation())
//            if (viewSheenWebCamera == null) {
//                viewSheenWebCamera = new ViewSheenWebCamera(ViewSheenWebCamConstants.IP_ADDRESS);
//            }
//
//            long time0 = System.currentTimeMillis();
//            ULog.d(TAG, "test_takePhoto拍照开始e: delay " + delay + " time " + System.currentTimeMillis());

//            getScheduledExecutor().schedule(() -> {
//
//            }, delay, TimeUnit.SECONDS);
//            Flowable.timer(delay, TimeUnit.SECONDS).subscribeOn(Schedulers.newThread()).doOnComplete(() -> {
//                ULog.d(TAG, "test_takePhoto拍照xxxxxx: " + System.currentTimeMillis() + "  " + Thread.currentThread().getName());
//
//
//                long time1 = System.currentTimeMillis();
//                ULog.d(TAG, "test_takePhoto拍照开始e: " + System.currentTimeMillis());
//
//                try {
//                    Response response = viewSheenWebCamera.getOkHttpClient().newCall(viewSheenWebCamera.getTakePhotoRequest()).execute();
//                    ResponseBody responseBody = response.body();
//
//                    ULog.d(TAG, "test_takePhoto拍照成功e code : " + response.code() + " time " + (System.currentTimeMillis() - time1) + " time1 " + (System.currentTimeMillis() - time0));
//                } catch (IOException e) {
//                    ULog.d(TAG, "test_takePhoto拍照失败e: " + System.currentTimeMillis() + " IOException " + e.getMessage());
//                    e.printStackTrace();
//                }
//            }).subscribe();
//            delay++;if(delay == 3) delay=0;
        });
        mView.findViewById(R.id.bt_move_stop).setOnClickListener(view -> {
            stmExecute.executeTaskNonQueue(new StmTask().stopMove("主界面 click 停止按钮 31"));
            if (MODE == MODE_GOTO_CHARGER || MODE == MODE_INSPECTION) {
                setMode(MODE_UN_KNOW, "正常模式-主界面点击停止按钮");
            }
//            setSpeedDecrement(0.04f, "bt_move_stop");
//            onChagerFinishDusting();
//            new Thread(new Runnable() {
//                @Override
//                public void run() {
//
//                    ConnectTest connectRequest = new ConnectTest();
//                    connectRequest.setRobotId(getRobot().getId());
//                    ConnectTest postResult = UOKHttp.postSync(UrlManager.getBaseUrl(), connectRequest, ConnectTest.class);
//                    if (postResult == null || !postResult.isSuccess()) {
//                        ULog.d(TAG, "ConnectTest = 测试post失败");
//                    } else {
//                        ULog.d(TAG, "ConnectTest = 测试post成功 "+postResult.getRobotId());
//                    }
//                }
//            }).start();

//            long time = System.currentTimeMillis();
//            ULog.d(TAG, "test_takePhoto拍照开始: " + System.currentTimeMillis());
//                Flowable.timer(0, TimeUnit.SECONDS).subscribeOn(Schedulers.newThread()).doOnComplete(() -> {
//                    ULog.d(TAG, "test_takePhoto拍照22开始: " + System.currentTimeMillis());
//                    WebCamManager.getInstance().takePhoto()
////                            .timeout(3, TimeUnit.SECONDS)
//                            .subscribe(new NextErrorObserver<ResponseBody>() {
//
//                                @Override
//                                public void onNext(@NonNull ResponseBody responseBody) {
//                                    ULog.d(TAG, "test_takePhoto拍照成功: " + (System.currentTimeMillis() - time));
//                                    mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "拍照成功: " + (System.currentTimeMillis() - time), Toast.LENGTH_LONG).show());
//                                }
//
//                                @Override
//                                public void onError(@NonNull Throwable e) {
//                                    ULog.d(TAG, "test_takePhoto拍照失败:" + (System.currentTimeMillis() - time) + " msg: " + e.getMessage());
//                                    mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "拍照失败:" + (System.currentTimeMillis() - time) + " msg: "  + e.getMessage(), Toast.LENGTH_LONG).show());
//                                }
//                            });
//                }).subscribe();
        });

        mView.findViewById(R.id.bt_steer_test).setOnClickListener(view -> {
            steerTest();
        });
        mView.findViewById(R.id.bt_upload_config).setOnClickListener(view -> {
            uploadSensorConfig();
        });
        mView.findViewById(R.id.bt_offset_correct).setOnClickListener(view -> {
            offsetCorrect();
        });
        mView.findViewById(R.id.bt_local_test).setOnClickListener(view -> {
            if (MainApp.isLocalRecordVideoTest) {
                MainApp.isLocalRecordVideoTest = false;
                ((Button)mView.findViewById(R.id.bt_local_test)).setText("录制测试 当前:关");
            } else {
                MainApp.isLocalRecordVideoTest = true;
                ((Button)mView.findViewById(R.id.bt_local_test)).setText("录制测试 当前:开");
            }
            ULog.d(TAG, "bt_local_test ir = " + MainApp.isRecordIrRawDataTest + " rgb " + MainApp.isLocalRecordVideoTest);
        });
        mView.findViewById(R.id.bt_local_ir_test).setOnClickListener(view -> {
            if (!MainApp.isRecordIrRawDataTest) {
                MainApp.isRecordIrRawDataTest = true;
                RecordIrData.enableRange(true);
                RecordIrData.enableRangeBack(true);
            }
            irTestTime = 3;
            ((Button)mView.findViewById(R.id.bt_local_ir_test)).setText("红外录制测试(3)");
            ((Button)mView.findViewById(R.id.bt_local_ir_test)).setEnabled(false);
            if (timer != null) {
                timer.cancel();
            }
            timer = new Timer();
            timer.schedule(new TimerTask() {
                @Override
                public void run() {
                    mActivity.runOnUiThread(() -> {
                        irTestTime--;
                        ((Button)mView.findViewById(R.id.bt_local_ir_test)).setText("红外录制测试(" + (irTestTime) + ")");
                        if (irTestTime <= 1) {
                            RecordIrData.enableRange(false);
                            RecordIrData.enableRangeBack(false);
                            inspectManager.avgDecibelReset();
                            inspectManager.avgDecibelBackReset();
                        }
                        if (irTestTime <= 0) {
                            ((Button)mView.findViewById(R.id.bt_local_ir_test)).setEnabled(true);
                            MainApp.isRecordIrRawDataTest = false;
                            if (timer != null) {
                                timer.cancel();
                            }
                        }
                    });
                }
            }, 1000, 1000);
            ULog.d(TAG, "bt_local_ir_test ir = " + MainApp.isRecordIrRawDataTest + " rgb " + MainApp.isLocalRecordVideoTest);
        });
        Button lowPowerMode = mView.findViewById(R.id.low_power_mode_btn);
        Button fullPowerMode = mView.findViewById(R.id.full_power_mode_btn);

        lowPowerMode.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ToastUtils.showLong("进入低功耗模式");
                if (!powerManager.isPowerSaveMode()) {
                    switch2LowPowerMode(true);
                    mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE);
                } else {
                    ToastUtils.showLong("已经处于低功耗模式");
                }

            }
        });

        fullPowerMode.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ToastUtils.showLong("恢复全功耗模式");
                if (powerManager.isPowerSaveMode()) {
                    switch2LowPowerMode(false);
                    quitPowerSaveMode();
                } else {
                    ToastUtils.showLong("已经处于全功耗模式");
                }
            }
        });
        mView.findViewById(R.id.lcs_test1).setOnClickListener(v -> {
            //            boolean istest1 = UPreferences.getBoolean(mActivity, "istest1", false);
            //            UPreferences.putBoolean(mActivity, "istest1", !istest1);
            //            showToast(!istest1 ? "开启成功" : "禁用成功");
        });
        mView.findViewById(R.id.lcs_test2).setOnClickListener(v -> {
            //            boolean istest2 = UPreferences.getBoolean(mActivity, "istest2", false);
            //            UPreferences.putBoolean(mActivity, "istest2", !istest2);
            //            showToast(!istest2 ? "开启成功" : "禁用成功");
        });

        //缓存读取机器人是否在目标回充位置附近
        AutoMoveManager.setInTargetChargerNode4mWithin(UShare.getBoolean(MainApp.getInstance(),UConstants.IN_TARGET_CHARGER_NODE_4M_WITHIN,false));
        AutoMoveManager.setInTargetChargerNode3mWithin(UShare.getBoolean(MainApp.getInstance(),UConstants.IN_TARGET_CHARGER_NODE_3M_WITHIN,false));
        AutoMoveManager.setInTargetChargerNode2mWithin(UShare.getBoolean(MainApp.getInstance(),UConstants.IN_TARGET_CHARGER_NODE_2M_WITHIN,false));

        //从缓存读取机器人方向
        setRobotDirection(UPreferences.getInt(mActivity, UConstants.PREFERENCES_DIRECTION_KEY, 1),"9");
        ULog.d(TAG, " initView robotDirection =" + robotDirection);

    }
    int delay;
    ViewSheenWebCamera viewSheenWebCamera;
    private void getCameraParam() {
        pushDeviceControl(true,"1", false);
        ZhstWebCameraManager.getInstance()
                .setOnRefreshWebcamZoomAndFocusListener(new ZhstWebCameraManager.OnRefreshWebcamZoomAndFocusListener() {
                    @Override
                    public void onSettingFailure(String e) {
                        ULog.d(TAG, "网络摄像头 变焦和变倍的值 onSettingFailure === e:" + e);
                        boolean isRet = checkWebCameraIsOnLine(e, () -> getCameraParam());
                        if (!isRet) {
                            mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "获取失败!", Toast.LENGTH_SHORT).show());
                        }
                    }

                    @Override
                    public void onSettingSuccess(Integer zoompos, Integer focuspos) {
                        ULog.d(TAG, "网络摄像头 变焦和变倍的值 onSettingSuccess === zoompos:" + zoompos + " focuspos:" + focuspos);
                        mZoom = zoompos;
                        mFocus = focuspos;
                        mActivity.runOnUiThread(() -> tvCam.setText("变倍:" + mZoom + " 焦距:" + mFocus));
                    }
                });
        ZhstWebCameraManager.getInstance().refreshWebcamZoomAndFocus();
    }

    private void switch2LowPowerMode(boolean isOpen) {

        try {
            Method setPowerSaveModeMethod = PowerManager.class.getMethod("setPowerSaveMode", boolean.class);
            setPowerSaveModeMethod.setAccessible(true);

            Object object = setPowerSaveModeMethod.invoke(powerManager, isOpen);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }

    }

    private Disposable bluetoothMqttSubscribe;
    private Disposable mqttReInitSubscribe;
    private void registerObservers() {
        registerDelayLeaveChargerObserver();
        registerConnectTestObserver();
        registerNetworkEventObservers();
        //注册监听处理蓝牙事件
        registerBluetoothEventObservers();
        //监听mqtt心跳丢失后从新初始化mqtt
        mqttReInitSubscribe = RxBus.getInstance().toObservable(MqttEvent.class)
                .filter(event -> MqttEvent.EVENT_RE_INIT_MQTT == event.getAction())
                .subscribe(mqttEvent -> {
                    ULog.w(TAG,"MqttHeartChecker EVENT_RE_INIT_MQTT 稍后重新初始化mqtt");
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_MQTT, 5000);
                });
        //巡检报警，需要手动处理
        RxBus.getInstance().toObservable(InspectionAlarmEvent.class)
                .observeOn(Schedulers.computation())
                .subscribe(event -> {
                    if (event.getAction() == RobotEventConstants.EVENT_TYPE_ALARM_NEED_STOP) {
                        if (mAlarmManager.getIsNeedToWaitAlarmProcessed()) {
                            ULog.d(TAG, "设备异常，需要等待处理");
                            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.WARNING_FOUND_EXCEPTION_WAIT_PROCESSING);
                            mMqttManager.broadcastShowInfo("发现异常，等待处理完成后继续巡检");

                            stmExecute.executeTaskNonQueue(new StmTask().stopMove("巡检报警，需要手动处理32"));
                            setMode(MODE_UN_KNOW, "正常模式-巡检报警需要手动处理");
                        }
                    } else if (event.getAction() == RobotEventConstants.EVENT_TYPE_ALARM_PROCESSED) {
                        ULog.d(TAG, "异常已处理完成，恢复巡检");
                        startInspection(robotDirection,"异常已处理完成，恢复巡检");
                    }
                });

        //推流Key变化
        RxBus.getInstance().toObservable(PushEvent.class)
                .observeOn(Schedulers.io())
                .subscribe(event -> {
                    ULog.w(TAG, "推流key变化，重新初始化SDK");
                    if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                        mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_SDK);
                    }
                });


        //启动流程： 获取机器人信息 -> 拿传感器配置 -> 获取地图 -> 解析和初始化机器人 -> 配置下位机 -> 启动完成 -> 回充处理
        AtomicReference<Robot> tmpRobot = new AtomicReference<>();
        AtomicBoolean roomInited = new AtomicBoolean(false);
        AtomicBoolean stmConfiged = new AtomicBoolean(false);
        mRobotInfoDisposable = RxBus.getInstance().toObservable(RobotEvent.class)
                .observeOn(Schedulers.computation())
                .subscribe(robotEvent -> {
                    switch (robotEvent.getAction()) {
                        case RobotEvent.ACTION_START_PARSE_ROBOT: {
                            Robot robot = robotEvent.getRobot();
                            parseRobotInfo(robot);

                            //                            boolean isInSleepMode = UPreferences.getBoolean(getContext(),
                            //                                    UConstants.KEY_IS_IN_SLEEP_MODE, false);
                            //                            if (robot.getSleepMode() != null && robot.getSleepMode().equals(UConstants.VALUE_SWITCH_STATUS_ON)) {
                            //                                //休眠已打开
                            //                                MainApp.setRobot(robot);
                            //                                if (!checkArrangeInspection()) {
                            //                                    mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE);
                            //                                    return;
                            //                                }
                            //                                ULog.d(TAG, "startSleep 休眠开关已开启，重新进入休眠");
                            //                                mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE);
                            //                            } else {
                            //                                //未开启休眠
                            ////                                if (isInSleepMode) {
                            //                                    ULog.d(TAG, "startSleep 休眠开关已关闭，通知下位机退出休眠");
                            //                                    mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE);
                            ////                                }
                            //                            }

                            ULog.d(TAG, "startSleep 先退出休眠，回充结束后重新进休眠");
                            mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE);
                        }
                        break;

                        case RobotEvent.EVENT_ENTER_POWER_SAVE_MODE:
                            ULog.d(TAG, "RobotEvent == 收到事件：进入休眠模式");
                            mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE);
                            break;

                        case RobotEvent.EVENT_QUIT_POWER_SAVE_MODE:
                            ULog.d(TAG, "RobotEvent == 收到事件：退出休眠模式");
                            mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE);
                            break;

                        case RobotEvent.EVENT_STM_CONFIG_FINISHED:
                            if (mNeedUpdateStmMap) {
                                writeStmRfids = MapManager.getInstance().getRfidNodeList();
                                cleanStmRfids = false;
                                stmExecute.executeTask(new StmTask().rfidClean());
                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_STM_RFID, 3000);
                            }
                            break;

                        case RobotEvent.EVENT_ROBOT_INFO_SUCCESS: {
                            if (robotEvent.getRobot() != null && !TextUtils.isEmpty(robotEvent.getRobot().getId())) {
                                //配置报警继电器联动
                                if(getRobotConfigParams() != null && getRobotConfigParams().getAlarmToNetworkRelayMap() != null){
                                    mAlarmManager.setAlarmToNetworkRelayMap(getRobotConfigParams().getAlarmToNetworkRelayMap());
                                }

                                //设置minio地址
                                UrlManager.setMinioAddr(robotEvent.getRobot().getMinioIp(),"EVENT_ROBOT_INFO_SUCCESS");
                                //设置mqtt地址
                                UrlManager.setMqttAddr(robotEvent.getRobot().getMqttLocalIp(),"EVENT_ROBOT_INFO_SUCCESS");


                                ULog.i(TAG, "RobotEvent == 已获取到机器人ID，开始获取传感器配置");
                                MainApp.setRobot(robotEvent.getRobot());
                                if (mSensorManager == null) {
                                    mSensorManager = SensorInfoProvider.of(robotEvent.getRobot().getId());
                                }

                                try {
                                    //延迟4s，防止初始化太快，下位机还没起来，导致有些需要使用串口设置的参数设置无效
                                    Thread.sleep(4000);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }

                                mSensorManager.autoRetryToParseSensorConfig(new SensorManager.SensorConfigParseListener() {
                                    @Override
                                    public void onComplete() {
                                        ULog.i(TAG, "RobotEvent == 传感器数据获取成功 " + mSensorManager.cacheInfo().CLEAN_DEVICE);
                                        mIsHaveNewCleanDevice = mSensorManager.cacheInfo().CLEAN_DEVICE != null
                                                && (mSensorManager.cacheInfo().CLEAN_DEVICE.getType().equals(CleanDeviceType.type_1)
                                                || mSensorManager.cacheInfo().CLEAN_DEVICE.getType().equals(CleanDeviceType.type_2)
                                                || mSensorManager.cacheInfo().CLEAN_DEVICE.getType().equals(CleanDeviceType.type_3)
                                                || mSensorManager.cacheInfo().CLEAN_DEVICE.getType().equals(CleanDeviceType.type_4));
                                        ULog.i(TAG, "RobotEvent == mIsHaveNewCleanDevice " + mIsHaveNewCleanDevice);
                                        tmpRobot.set(robotEvent.getRobot());
                                        isGrayUpgrade = robotEvent.getRobot().getGrayUpgrade() != null && robotEvent.getRobot()
                                                .getGrayUpgrade();
                                        robotEvent.setAction(RobotEvent.EVENT_SENSOR_CONFIG_PARSE_SUCCESS);
                                        RxBus.getInstance().post(robotEvent);
                                        if(mSensorManager.cacheInfo().BMS_INFO != null){
                                            BmsInfo bmsInfo = mSensorManager.cacheInfo().BMS_INFO;
                                            if(bmsInfo.getBatteryClusterNum() < 1){
                                                veryHighSingleVoltage = bmsInfo.getHighVoltageThreshold();
                                                veryLowSingleVoltage = bmsInfo.getLowVoltageThreshold();
                                            }else{
                                                veryHighSingleVoltage = bmsInfo.getHighVoltageThreshold() / bmsInfo.getBatteryClusterNum();//总电池的过压阈值除电池串数 得到单体电池过压阈值
                                                veryLowSingleVoltage = bmsInfo.getLowVoltageThreshold() / bmsInfo.getBatteryClusterNum();//单体电池欠压阈值同上
                                            }
                                        }
                                        if(mSensorManager.cacheInfo().MOTOR_INFO != null){
                                            //这里机器人类型不能使用全局的 此时只是获取到了机器人的信息并没有解析所以fragment这边机器人类型是空的
                                            MotorMaxSpeedParser.parseMaxSpeed(RobotInfoManager.getInstance().getRobotType(), mSensorManager.cacheInfo().MOTOR_INFO);
                                        }

                                        if(MainApp.maxMotorSpeed != null){
                                            MainApp.setRobotMaxSpeed(MainApp.maxMotorSpeed,"根据电机配置设置最大速度.");
                                        }

                                    }

                                    @Override
                                    public void onFail() {

                                    }
                                });
                            }

                        }
                        break;

                        case RobotEvent.EVENT_SENSOR_CONFIG_PARSE_SUCCESS:
                            MapManager.getInstance().getMap(robotEvent.getRobot().getId());
                            break;

                        case RobotEvent.EVENT_ALL_DATA_FETCHED: {
                            if (mIsRobotInitialized) {
                                return;
                            }
                            mSequenceInitializer.cancelSequence();
                            mSequenceInitializer.quitSequence();

                            //延后到启动完成后检测升级，防止重复调用`initData`造成一直循环初始化
                            if (UConstants.isFirstBoot(getContext()) && MapManager.getInstance().getRfidNodeList().size() == 0) {
                                checkUpgrade(14);
                            }
                            boolean inCleanDevice = isInCleanDeviceArea(mDistance);
                            ULog.d(TAG, "舵机使能条件 SteerController mIsHaveNewCleanDevice " + mIsHaveNewCleanDevice + " inCleanDevice " + inCleanDevice + " isHaveSteer() " + mBotInfoMgr.isHaveSteer() + " getEnableControlSteerInCleanDevice " + mBotInfoMgr.getRobotConfigParams().getEnableControlSteerInCleanDevice() + " isWebCameraElectrify " + isWebCameraElectrify + " mDistance " + mDistance);
                            if (mIsHaveNewCleanDevice) {
                                ObstacleController.getInstance().setObstacleOn(!inCleanDevice,"13");
                                if (mBotInfoMgr.isHaveSteer()) {
                                    if (!mBotInfoMgr.getRobotConfigParams().getEnableControlSteerInCleanDevice()) {
                                        if (!inCleanDevice && isWebCameraElectrify) {
                                            SteerController.getInstance().setPowerEnable(true);
                                            SteerController.getInstance().setControllable(true);
                                        } else if (!inCleanDevice) {
                                            SteerController.getInstance().setControllable(true);
                                        }
                                    } else {
                                        if (isWebCameraElectrify) {
                                            SteerController.getInstance().setPowerEnable(true);
                                        }
                                        SteerController.getInstance().setControllable(true);
                                    }
                                }
                            } else {
                                if (mBotInfoMgr.isHaveSteer()) {
                                    SteerController.getInstance().setControllable(true);
                                }
                            }

                            mIsRobotInitialized = true;
                            moveHinderNeedSleep = UPreferences.getBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NEED_SLEEP_KEY, false);
                            moveHinderLowPower = UPreferences.getBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_LOW_POWER_GO_CHARGER_KEY, false);
                            moveHinderNetDisconnect = UPreferences.getBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NET_DISCONNECT_GO_CHARGER_KEY, false);
                            sleepTimeMoveHinder = getSleepTimeMoveHinder();
                            currentChargerControlStatus = UPreferences.getInt(MainApp.getInstance(), UConstants.PREFERENCES_TEMPERATURE_CONTROL_STATUS, 0);
                            currentChargerControlStatusCool = UPreferences.getInt(MainApp.getInstance(), UConstants.PREFERENCES_TEMPERATURE_CONTROL_STATUS_COOL, 0);
                            ULog.d(TAG, "RobotEvent == 机器人启动完成... 运动阻碍状态 moveHinderNeedSleep " + moveHinderNeedSleep + " moveHinderLowPower " + moveHinderLowPower + " moveHinderNetDisconnect " + moveHinderNetDisconnect + " sleepTimeMoveHinder " + sleepTimeMoveHinder + " currentChargerControlStatus " + currentChargerControlStatus + " currentChargerControlStatusCool " + currentChargerControlStatusCool);
                            if (!UConstants.isFirstBoot(MainApp.getInstance())) { //非开机广播启动
                                if (readCache()) {
                                    return;
                                }
                            }

                            //清理图片
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_PIC, 20_000);
                            //启动后计算一次，防止要用到时nearestChargerLocation为空
                            AutoMoveManager.mTargetChargerNodeW =
                                    ChargerNodeManager.getInstance().computeNearestChargerNodeWrapper(mDistance,"4");
                            mIsFirstDustingAfterBoot = true;
                            UConstants.setBoot();

                            if (moveHinderNeedSleep) {
                                ULog.d(TAG, "运动阻碍开机_reboot_sleep_time " + sleepTimeMoveHinder);
                                break;
                            }
                            if (MapManager.getInstance().getRfidNodeList().size() >  0) {
                                autoMoveManager.gotoChargerCheck("初始化完成_回充");
                            } else {
                                ULog.w(TAG,"无地图，不回充");
                            }
                        }
                        break;

                        case RobotEvent.EVENT_GET_MAP_FINISHED:

                            ULog.d(TAG, "RobotEvent == 地图获取完成，初始化机器人");
                            robotEvent.setAction(RobotEvent.ACTION_START_PARSE_ROBOT);
                            robotEvent.setRobot(tmpRobot.get());
                            RxBus.getInstance().post(robotEvent);
                            break;

                        case RobotEvent.ACTION_ENVIRONMENT_TEMPERATURE_UPDATED:
                            environmentalTemperature = ((Double) robotEvent.getObj()).floatValue();
                            ULog.d(TAG,"environmentalTemperature update 1 :"+environmentalTemperature);
                            break;

                        case RobotEvent.ACTION_CONFIG_CHARGER_SENSOR_FINISHED:
                            RestrictDistanceWatcher.getInstance().init();
                            break;

                        default:
                            break;

                    }
                });

        RxBus.getInstance().toObservable(ElevatorEvent.class)
                .observeOn(Schedulers.io())
                .subscribe(event -> {
                    ULog.d(TAG, "ElevatorEvent action:"+event.getAction());
                    if(event.getAction() == ElevatorEvent.EVENT_FIND_ELEVATOR_CONFIG_SUCCESS){
                        if(ElevatorEvent.MSG_NOT_HAVE_ELEVATE_CONFIG.equals(event.getMessage())){
                            ULog.d(TAG, "ElevatorEvent not have elevate config ignore.");
                            ElevatorController.notHaveElevatorConfigclearCache();
                        }else{
                            if(event.getElevators() != null && event.getElevators().size() > 0){
                                ElevatorController.getInstance(RobotFragment.this).parseConfig1(event.getElevators());
                            }
                        }
                    }
                });


        RxBus.getInstance().toObservable(MapEvent.class)
                .observeOn(Schedulers.computation())
                .subscribe(mapEvent -> {
                    switch (mapEvent.getAction()) {
                        case MapEvent.EVENT_ROBOT_GET_MAP_SUCCESS:
                            ULog.d(TAG, "收到地图数据");
                            if (parseMapResult(mapEvent.getMapInfo())) {
                                initCleanDeviceParams();
                                RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_GET_MAP_FINISHED));
                            }
                            break;

                        case MapEvent.EVENT_ROBOT_MAP_EMPTY: {
                            ULog.w(TAG, "收到空地图数据");
                            if ((rfidReadType == 2 || rfidReadType == 3) && !cleanStmRfids && !mHandler.hasMessages(Msg.WHAT_CLEAN_STM_RFID)) {
                                isDeleteRfidMap = true;
                                stmExecute.executeTask(new StmTask().rfidClean());
                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_STM_RFID, 3000);
                            }
                            initCleanDeviceParams();
                            sendNotMapInfo();
                            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_GET_MAP_FINISHED));
                        }
                        break;

                        case MapEvent.EVENT_ENTER_RESTRICT_AREA: {
                            DistanceArea area = mapEvent.getDistanceArea();
                            if (area == null) {
                                return;
                            }
                            ULog.i(TAG, "进入限制区：" + area);
                            if (area.getType() == DistanceAreaType.CLEAN_DEVICE) {

//                                if (MODE == MODE_GOTO_CHARGER || MODE == MODE_DEVICE_CLEAN) {
//                                    ULog.d(TAG, "限制区_sensor_control_false");
//                                    stmExecute.executeTask(new StmTask().switchComponentEnable(false, StmTask.FuncPowerBit.BIT_SENSOR_POWER));
//                                }
                                if (mBotInfoMgr.isHaveSteer()) {
                                    boolean allowControl = mBotInfoMgr.getRobotConfigParams().getEnableControlSteerInCleanDevice();
                                    boolean needVertical = mBotInfoMgr.getRobotConfigParams()
                                            .getLeaveBySteerVerticalDown() == UConstants.VALUE_SWITCH_STATUS_ON;

                                    if (!allowControl) {
                                        SteerController.getInstance().setControllable(false);
                                    }

                                    if (allowControl && needVertical) {
                                        SteerController.getInstance().directSetVAngle(180, SteerControlTag.ENTER_CLEAN_DEVICE.getReason());
                                    } else if (allowControl) {
                                        //随意
                                    } else if (needVertical) {
                                        SteerController.getInstance().directSetSteerAngle(mBotInfoMgr.getRobotConfigParams()
                                                .getDustHorizontalAngle(), 180, SteerControlTag.ENTER_CLEAN_DEVICE.getReason());
                                    } else {
                                        SteerController.getInstance().directSetSteerAngle(mBotInfoMgr.getRobotConfigParams()
                                                        .getDustHorizontalAngle(), mBotInfoMgr.getRobotConfigParams().getDustVerticalAngle(),
                                                SteerControlTag.ENTER_CLEAN_DEVICE.getReason());
                                    }
                                }

                                ObstacleController.getInstance().setObstacleOn(false,"14");
                            }
                        }
                        break;

                        case MapEvent.EVENT_LEAVE_RESTRICT_AREA: {
                            DistanceArea area = mapEvent.getDistanceArea();
                            if (area == null) {
                                return;
                            }
                            ULog.i(TAG, "离开限制区：" + area);
                            if (area.getType() == DistanceAreaType.CLEAN_DEVICE) {
                                if (mBotInfoMgr.isHaveSteer()) {
                                    if (isWebCameraElectrify) {
                                        ULog.i(TAG, "舵机上电");
                                        SteerController.getInstance().setPowerEnable(true);
                                    }
                                    SteerController.getInstance().setControllable(true);

                                    if (inspectManager.mCheckTargetNode != null) {
                                        float[] angles = UConstants.getAngle(inspectManager.getCheckTargetNode().getAngleJson());
                                        SteerController.getInstance().directSetSteerAngle(angles[0],
                                                angles[1],
                                                SteerControlTag.INSPECTION.getReason()+"离开里程限制区");
                                    }


                                }

                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_SHUTTER_ALL_IR_WHEN_LEAVE_BY, 5000);
                            }
                        }
                        break;

                        default:
                            break;
                    }
                });

        //堵转事件
        RxBus.getInstance().toObservable(RobotEvent.class)
                .observeOn(Schedulers.newThread())
                .subscribe(robotEvent -> {
                    switch (robotEvent.getAction()) {
                        case RobotEvent.EVENT_MOTOR_MANAGE_BOARD_ALARM:
                        case RobotEvent.EVENT_MOTOR_OVER_CURRENT:
//                        case RobotEvent.EVENT_MOTOR_SPEED_LOW_THAN_ONE_THIRD: 速度达不到是在下位机检测
                        case RobotEvent.EVENT_STM_REPORT_MOVEMENT_HINDRANCE: {
                            if (MODE == MODE_AUTO_BUILD_MAP) {
                                ULog.w(TAG, "自动建图时运动阻碍");
                                mBotInfoMgr.setRobotActionCode(RobotActionCode.MOVE_STOPPED, RobotActionCode.Stop.HINDRANCE_STOP);
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("自动建图时运动阻碍33"));
                                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_MOTOR_HINDRANCE);
                                mMqttManager.broadcastShowInfo("遇到运动阻碍");

                                return;
                            }

                            //                            if (System.currentTimeMillis() - mLastMotorAlertTime < 1000) {
                            //                                return;
                            //                            }

                            mMotorAlertCount++;
                            mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                            if (mMotorBackDis != null && !mMotorBackDis.isDisposed()) {
                                mMotorBackDis.dispose();
                            }

                            String log = String.format("运动阻碍,原因：%s，次数：%s, mIsBackwardToAvoidStilling:%s",
                                    getMotorAlarmReasonStr(robotEvent.getAction()), mMotorAlertCount, mIsBackwardToAvoidStilling);
                            ULog.w("Motor", log);

                            if (mMotorAlertCount >= 2) {
                                mBotInfoMgr.setRobotActionCode(RobotActionCode.MOVE_STOPPED, RobotActionCode.Stop.HINDRANCE_FINAL_STOP);
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("运动阻碍2次34"));

                                ULog.e(TAG, "运动阻碍2次，上报");
                                if (isNeedCheckAruco && (TakeImgInspectManager.isRunning || MODE == MODE_INSPECTION || MODE == MODE_CHECKING_STOP)) {
                                    TakeImgInspectManager.getInstance(RobotFragment.this).startCheckOrClose(2, "1");
                                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_INSPECTION_HINDRANCE_GOTO_CHARGER);
                                    mMqttManager.broadcastShowInfo("识别巡检过程中遇到运动阻碍,回充电桩.");
                                }
                                if (mRobotType.getSubType() == RobotSubType.BZ) {
                                    //非煤安电机需要卸力，煤安停止后电机刹车，可以不卸力
                                    Observable.just(1)
                                            .observeOn(Schedulers.io())
                                            .subscribe(t -> {
                                                setRobotActionCode(RobotActionCode.Hindrance.HINDRANCE_UNLOADING);
                                                //两次失能，防止下位机自动使能导致没有成功失能卸力
                                                MotorController.getInstance().disableMotor();
                                                Thread.sleep(500);
                                                MotorController.getInstance().disableMotor();
                                                Thread.sleep(500);
                                                MotorController.getInstance().enableMotor(true, true);
                                                mBotInfoMgr.setRobotActionCode(RobotActionCode.MOVE_STOPPED,
                                                        RobotActionCode.Stop.HINDRANCE_FINAL_STOP);
                                            });
                                }

                                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_MOTOR_HINDRANCE);
                                mMqttManager.broadcastShowInfo("遇到运动阻碍");
                                AlarmEvent alertEvent;
                                if (robotEvent.getAction() == RobotEvent.EVENT_MOTOR_MANAGE_BOARD_ALARM) {
                                    alertEvent = new AlarmEvent(AlarmTypeEnum.MOTOR_MANAGE_BOARD_REPORT_MOVEMENT_HINDRANCE);
                                } else {
                                    alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_WITH_LOCATION);
                                }
                                List<String> params = new ArrayList<>();
                                params.add(String.valueOf(FormatUtils.keepDecimals(mDistance, 2)));
                                params.add(getCurrentTaskNodeName());
                                alertEvent.setParams(params);
                                if (!MainApp.TEST_ID.equals(getRobot().getId())) {
                                    if (Math.abs(mDistance - lastHinderAlarmLocation) > 0.1 || System.currentTimeMillis() - lastHinderAlarmTime > 10000) {
                                        RxBus.getInstance().post(alertEvent);
                                        setIsAlarmReported(alertEvent.getAlarmType(), true);
                                        lastHinderAlarmLocation = mDistance;
                                        lastHinderAlarmTime = System.currentTimeMillis();
                                    } else {
                                        ULog.d(TAG, "短时间同一位置运动阻碍，不报警");
                                    }
                                }

                                if (MODE == MODE_INSPECTION && MainApp.isArrangeInspect(getRobot().getChargeStrategy())) {
                                    if (robotDirection == MOVE_FRONT) {
                                        setToMapHead("hinder");
                                    } else {
                                        ULog.d(TAG, "setToMapEnd tag 4");
                                        setToMapEnd("hinder");
                                    }
                                }

                                if (MODE == MODE_INSPECTION || MODE == MODE_DEVICE_CLEAN || MODE == MODE_CHECKING_STOP || MODE == MODE_MOVE_TO_TARGET) {
                                    ULog.d(TAG, "运动阻碍 巡检或除尘或去目标位置状态，2秒后开始回充");
                                    setMode(MODE_UN_KNOW, "正常模式-运动阻碍 巡检或除尘状态，2秒后开始回充");
                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("运动阻碍 巡检或除尘状态，2秒后开始回充 35"));
                                    mHandler.postDelayed(() -> {autoMoveManager.gotoChargerCheck("运动阻碍_巡检或除尘状态_回充");}, 2000);
                                    return;
                                }

                                if (MODE == MODE_GOTO_CHARGER && ChargerNodeManager.getInstance().getActiveChargersW().size() > 1) { // 回充状态下运动阻碍2次 尝试回其他充电桩
                                   if (autoMoveManager.goToNextCharger()) {
                                       ULog.d(TAG, "运动阻碍，回充状态，尝试回下一个充电桩");
                                       return;
                                   }
                                   ULog.d(TAG, "运动阻碍，没有其他充电桩可回");
                                }
                                if (isInCleanDeviceArea(mDistance)) {
                                    ULog.d(TAG, "运动阻碍 by内 不进电池休眠");
                                    setMode(MODE_UN_KNOW, "正常模式-运动阻碍 by内");
                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("运动阻碍by内 36"));
                                    return;
                                }
//                                ULog.d(TAG, "up_time = " + SystemClock.elapsedRealtime());//获取已开机时间 单位毫秒
                                if (MODE == MODE_INSPECTION || MODE == MODE_GOTO_CHARGER || MODE == MODE_DEVICE_CLEAN) {
                                    ULog.d(TAG, "startSleep 运动阻碍关机，开始休眠 moveHinderNeedSleep " + moveHinderNeedSleep + " sleepTimeMoveHinder " + sleepTimeMoveHinder + " hasMessages " + mHandler.hasMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE));
                                    moveHinderNeedSleep = true;
                                    UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NEED_SLEEP_KEY, true);
                                    if (!mHandler.hasMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE)) {
                                        sleepTimeMoveHinder = 10;
                                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE, 600_000);
                                    }
                                }
//                                //3小时后重试移动
//                                Message retryMsg = Message.obtain();
//                                retryMsg.what = Msg.WHAT_RETRY_MOVE_AFTER_STALLING;
//                                retryMsg.arg1 = MODE;
//                                retryMsg.arg2 = robotDirection;
//                                mHandler.sendMessageDelayed(retryMsg,
//                                        TimeUnit.MINUTES.toMillis(mBotInfoMgr.getRobotConfigParams().getHindranceRetryDelayMinute()));

                                setMode(MODE_UN_KNOW, "正常模式-阻碍1");
                                mIsBackwardToAvoidStilling = false;
                                mMotorAlertCount = 0;
                                mIsNeedToSpeedUp = false;
                                mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                                clearMotorOverCurrentFlags();
                                mDistanceBeforeBackward = 0f;

                            } else {
                                mBotInfoMgr.setRobotActionCode(RobotActionCode.MOVE_STOPPED, RobotActionCode.Stop.HINDRANCE_STOP);
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("HINDRANCE_STOP 37"));

                                mIsBackwardToAvoidStilling = true;
                                mDistanceBeforeBackward = mDistance;
                                mSpeedBeforeBackward = lastSpeed;
                                mIsNeedToSpeedUp = false;

                                int targetDir = robotDirection == MOVE_FRONT ? MOVE_END : MOVE_FRONT;
                                ULog.d(TAG,
                                        "运动阻碍准备掉头，当前里程：" + mDistance + "，当前方向：" + robotDirection + "，目标方向：" + targetDir);
                                setRobotDirection(targetDir,"运动阻碍准备掉头");

                                mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                                if (mRobotType.getSubType() == RobotSubType.FB || mRobotType.getSubType() == RobotSubType.MA) {
                                    setRobotActionCode(RobotActionCode.Hindrance.HINDRANCE_WAIT_BACK);
                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("运动阻碍准备掉头 38"));
                                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD, 10_000);
                                } else {
                                    mHandler.sendEmptyMessage(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                                }
                            }

                        }
                        break;

                        case RobotEvent.EVENT_LEAVE_CLEAN_DEVICE_AREA: {
                            if (MODE == MODE_INSPECTION) {
                                TaskNode curTaskNode = inspectManager.getCurrentTaskNode();
                                float[] angle = UConstants.getAngle(curTaskNode.getAngleJson());
                                if (angle[0] != SteerController.getInstance().getCurHAngle() || angle[1] != SteerController.getInstance()
                                        .getCurVAngle()) {
                                    ULog.d(TAG, "巡检中离开除尘设备范围， 重新舵机角度");
                                    SteerController.getInstance().setSteerAngle(angle[0], angle[1], SteerControlTag.INSPECTION.getReason());
                                }

                            }
                        }
                        break;

                        case RobotEvent.ACTION_UPDATE_ROBOT_IR_EXCEPTION: {
                            if ((getRobot().getException() >> 2 & 0x1) == 0) {
                                getRobot().setException(getRobot().getException() + 0b100);
                            }
                        }
                        break;

                        case RobotEvent.ACTION_CLEAR_ROBOT_IR_EXCEPTION: {
                            if ((getRobot().getException() >> 2 & 0x1) == 1) {
                                getRobot().setException(getRobot().getException() - 0b100);
                            }
                        }
                        break;

                        default:
                            break;
                    }

                });


        //网络摄像头事件
        RxBus.getInstance().toObservable(WebCameraEvent.class)
		        .filter(event -> getRobot() != null && getRobot().getPushEnable())
                .observeOn(Schedulers.io())
                .subscribe(event -> {
                    switch (event.getAction()) {
                        case WebCameraEvent.EVENT_WEB_CAMERA_CONNECT_FAILED:
                            //网络摄像头连接失败
                            ULog.w(TAG, "webcam 网络摄像头多次连接失败，重启USB");

                            ULog.e(TAG, "网络摄像头掉线，已上报： : " + getIsAlarmReported(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION) + "，次数： " + getAlarmCount(
                                    AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION) + " 次数阈值 " + mAlarmManager.getAlarmTriggerCount(
                                    AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION));
                            if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION)) {
                                //网络摄像头掉线
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION);
                                List<String> params = new ArrayList<>();
                                alertEvent.setParams(params);
                                RxBus.getInstance().post(alertEvent);
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION, true);
                            }

                            SerialManagerUtil.resetGpio(UConstants.GPIO_USB_HOST_RESET, 8000);
                            if (!isInCleanDeviceArea(mDistance)) {
                                stmExecute.executeTask(new StmTask().switchComponentEnable(true, StmTask.FuncPowerBit.POWER_MANAGER_PTZ));
                            }
                            break;

                        case WebCameraEvent.EVENT_WEB_CAMERA_LOST:
                            ULog.w(TAG, "webcam 网络摄像头可能掉线，重启Android");
                            Thread.sleep(2000);
                            //                            PowerManager pm = (PowerManager) mActivity.getSystemService(Context.POWER_SERVICE);
                            //                            pm.reboot("");
                            rebootAndroid("WebCam drop");
                            break;

                        case WebCameraEvent.EVENT_WEB_CAMERA_NOT_ELECTRIFY:
                            ULog.w(TAG, "webcam 网络摄像头可能没有上电 " + checkWebCameraElectrifyNum);
                            if (getRobot().getPushEnable() && !mHandler.hasMessages(Msg.WHAT_WEB_CAMERA_IS_ELECTRIFY) && checkWebCameraElectrifyNum < 5) {
                                checkWebCameraElectrifyNum++;
                                Message msg = mHandler.obtainMessage(Msg.WHAT_WEB_CAMERA_IS_ELECTRIFY);
                                msg.obj = event.getMessage();
                                mHandler.sendMessageDelayed(msg, 2000);
                            }
                            break;
                        case WebCameraEvent.EVENT_WEB_CAMERA_ARUCO_START_PULL_STREAM_FAILED:
                            //暂时只打印下
                            ULog.w(TAG, "webcam 检测Aruco巡检 拉流开启失败,可能摄像头掉线");
                            break;
                        default:
                            break;
                    }
                });

        //rfid功率事件
        RxBus.getInstance().toObservable(RfidEvent.class)
                .observeOn(Schedulers.computation())
                .subscribe(rfidEvent -> {
                    if (rfidEvent.getAction() == RfidEvent.ACTION_WRITE_RFID_POWER) {
                        RfidController.getInstance().setPower(rfidEvent.getReadPower(), rfidEvent.getWritePower(),
                                false);
                    } else if (rfidEvent.getAction() == RfidEvent.ACTION_WRITE_POWER_RESULT) {

                        if (mIsWaitToWriteRFID) {
                            ULog.i(TAG, "onRFIDReceiveData： 功率设置完成，开始写入RFID");
                            RfidController.getInstance().writeData(mWaitedRfidTagByte);
                        }
                    }
                });

        //电池过流保护事件
        RxBus.getInstance().toObservable(BmsEvent.class)
                .observeOn(Schedulers.newThread())
                .subscribe(event -> {
                    switch (event.getAction()) {
                        case BmsEvent.EVENT_OVER_CURRENT:
                            ULog.d(TAG, "电池过流， 停止移动 " + event.getCurrent());
                            stmExecute.executeTask(new StmTask().stopMove("电池过流， 停止移动 39"));
                            break;

                        case BmsEvent.EVENT_OVER_CURRENT_PROTECT:
                            ULog.d(TAG, "电池过流保护， 终止任务 " + event.getCurrent());
                            stmExecute.executeTask(new StmTask().stopMove("电池过流保护， 终止任务 40"));
                            setMode(MODE_UN_KNOW, "正常模式-电池过流保护");
                            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.WARNING_ROBOT_BATTERY_PROTECT_PLEASE_PROCESS);
                            mMqttManager.broadcastShowInfo("电池发生过流保护，请前往处理！");

                            //机器人电池电流超过一定阈值 报警 阈值正负10A
                            if (addAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION)) {
                                ULog.i(TAG, "电池电流 异常报警 mCurrent=" + mCurrent + "batteryCurrentExceptionNum=" + getAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION));
                                List<String> params = new ArrayList<>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(event.getCurrent() > 0 ? "超过阈值" + (BaseBmsCommunicator.mOverCurrentThreshold * 1000f) : "低于阈值" + (BaseBmsCommunicator.mOverCurrentThreshold * 1000f));
                                params.add(String.valueOf(event.getCurrent()));
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION,
                                        params));
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION, true);
                            }
                            break;

                        default:
                            break;
                    }
                });


        //硬件设备事件
        RxBus.getInstance().toObservable(DeviceEvent.class)
                .observeOn(Schedulers.io())
                .subscribe(event -> {
                    switch (event.getAction()) {
                        case DeviceEvent.ACTION_REBOOT_USB_HUB:
                            ULog.i(TAG, "DeviceEvent === 收到事件 重启 USB HUB");
                            stmExecute.executeTask(new StmTask().switchComponentEnable(false, StmTask.FuncPowerBit.BIT_5V_0));
                            break;

                        case DeviceEvent.ACTION_USB_HUB_DISABLE_SUCCESS:
                            ULog.i(TAG, "DeviceEvent === USB HUB 失能成功 ，3s后重新使能");
                            Utils.postDelayed(() -> {
                                stmExecute.executeTask(new StmTask().switchComponentEnable(true,
                                        StmTask.FuncPowerBit.BIT_5V_0));
                            }, 3000);
                            break;

                        case DeviceEvent.ACTION_USB_HUB_ENABLE_SUCCESS:
                            ULog.i(TAG, "DeviceEvent === USB HUB 使能成功，USB HOST重新上电");
                            SerialManagerUtil.resetGpio(UConstants.GPIO_USB_RESET, 3000);
                            break;
                        case DeviceEvent.ACTION_SENSOR_DISABLE_SUCCESS:
                            ULog.i(TAG, "DeviceEvent === 传感器 失能成功");
                            break;
                        case DeviceEvent.ACTION_SENSOR_ENABLE_SUCCESS:
                            ULog.i(TAG, "DeviceEvent === 传感器 使能成功");
                            break;

                        case DeviceEvent.ACTION_REBOOT_ANDROID:
                            ULog.w(TAG, "DeviceEvent === 收到事件 重启上位机");
                            rebootAndroid(event.getMsg());
                            break;

                        default:
                            break;
                    }
                });

        //获取报警类型 这里做一下转发
        RxBus.getInstance().toObservable(AlarmTypeEvent.class)
                .filter(event -> event.getAction() == AlarmTypeEvent.EVENT_FIND_ALL_ALARM_TYPE)
                .observeOn(Schedulers.io())
                .subscribe(event -> {
                    if(!mHandler.hasMessages(Msg.WHAT_FORWARD_FIND_ALL_ALARM_TYPE)){
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_FORWARD_FIND_ALL_ALARM_TYPE,event.getDelayTime());
                    }
                });


//        monitorOutsideTemp();
    }

    private void cleanMoveHinder(int tag) {
        //退出运动阻碍休眠
        ULog.d(TAG, "退出运动阻碍休眠 tag " + tag + " moveHinderNeedSleep " + moveHinderNeedSleep + " hasMessage " + mHandler.hasMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE));
        if (moveHinderNeedSleep && mHandler.hasMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE)) {
            mHandler.removeMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE);
            sleepTimeMoveHinder = 0;
        }
        moveHinderNeedSleep = false;
        UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NEED_SLEEP_KEY, false);
    }

    //到地图首尾端次数 用于统计巡检次数
    private int toMapEndNum = UConstants.UNKONW;
    private int toMapHeadNum = UConstants.UNKONW;
    long lastSetToMapEndTime, lastSetToMapHeadTime;
    int lastSetToMapEndDir, lastSetToMapHeadDir;
    float startStatisticLocation = 0; //开始巡检统计位置 中止巡检时，巡检里程超过50%才会统计巡检次数和报表
    public void setToMapEnd(String flag) {
        ULog.d(TAG, "setToMapEnd " + flag + " toMapEndNum " + toMapEndNum + " lastTime " + lastSetToMapEndTime + " lastDir" + lastSetToMapEndDir);
        boolean isJust = System.currentTimeMillis() - lastSetToMapEndTime < 1000 && robotDirection == lastSetToMapEndDir;
        if (("onMotorInfo".equals(flag) || "rfidNodeHandle".equals(flag)) && !isJust && isInspectionMode() && MainApp.inspectIsSelf) {
            statisticToMapEnd("setToMapEnd");
        }
        inspectManager.isInspectTail = true;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_INSPECT_TAIL_KEY, true);
    }
    public void statisticToMapEnd(String flag) {
        ULog.d(TAG, "statisticToMapEnd " + flag + " toMapHeadNum " + toMapHeadNum + " toMapEndNum " + toMapEndNum);
        startStatisticLocation = mDistance;
        lastSetToMapEndTime = System.currentTimeMillis();
        lastSetToMapEndDir = robotDirection;
        InspectManager.isToEndOfReportForm = true;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_TO_END_OF_REPORT_FORM_KEY, true);
        toMapEndNum = 1;
        StorageCenter.getRobotStorage().putInteger(UConstants.PREFERENCES_INSPECTION_TO_END_NUM_KEY, toMapEndNum);
        ULog.d(TAG, "statisticToMapEnd2 " + flag + " toMapHeadNum " + toMapHeadNum + " toMapEndNum " + toMapEndNum);
    }
    public void setToMapHead(String flag) {
        ULog.d(TAG, "setToMapHead " + flag + " toMapHeadNum " + toMapHeadNum + " lastTime " + lastSetToMapHeadTime + " lastDir" + lastSetToMapHeadDir);
        boolean isJust = System.currentTimeMillis() - lastSetToMapHeadTime < 1000 && robotDirection == lastSetToMapHeadDir;
        if (("onMotorInfo".equals(flag) || "rfidNodeHandle".equals(flag)) && !isJust && isInspectionMode() && MainApp.inspectIsSelf) {
            statisticToMapHead("setToMapHead");
        }
        inspectManager.isInspectHead = true;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_INSPECT_HEAD_KEY, true);
    }
    public void statisticToMapHead(String flag) {
        ULog.d(TAG, "statisticToMapHead " + flag + " toMapHeadNum " + toMapHeadNum + " toMapEndNum " + toMapEndNum);
        startStatisticLocation = mDistance;
        lastSetToMapHeadTime = System.currentTimeMillis();
        lastSetToMapHeadDir = robotDirection;
        InspectManager.isToHeadOfReportForm = true;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_TO_HEAD_OF_REPORT_FORM_KEY, true);
        toMapHeadNum = 1;
        StorageCenter.getRobotStorage().putInteger(UConstants.PREFERENCES_INSPECTION_TO_HEAD_NUM_KEY, toMapHeadNum);
        ULog.d(TAG, "statisticToMapHead2 " + flag + " toMapHeadNum " + toMapHeadNum + " toMapEndNum " + toMapEndNum);
    }

    /**
     * 监控外部温度
     */
    private void monitorOutsideTemp() {
        ConcurrentLinkedDeque<Float> historyTemp = new ConcurrentLinkedDeque<>();
        final AtomicLong lastShutterTime = new AtomicLong(0);

        RobotInfoManager.getInstance().getOutsideTempObservable().addOnPropertyChangedCallback(new androidx.databinding.Observable.OnPropertyChangedCallback() {
            @Override
            public void onPropertyChanged(androidx.databinding.Observable sender, int propertyId) {
                float temp = mBotInfoMgr.getOutsideTempObservable().get();
                if (historyTemp.size() >= 30) {
                    historyTemp.removeFirst();
                }
                historyTemp.addLast(temp);

                if (historyTemp.size() < 10) {
                    return;
                }

                Iterator<Float> iterator = historyTemp.iterator();
                float minTemp = 999.0f;
                float maxTemp = -999.0f;
                while (iterator.hasNext()) {
                    float hTemp = iterator.next();
                    if (hTemp < minTemp) {
                        minTemp = hTemp;
                    }
                    if (hTemp > maxTemp) {
                        maxTemp = hTemp;
                    }
                }

                float diff = Math.abs(maxTemp - minTemp);
                if (diff > mBotInfoMgr.getRobotConfigParams().getTempDiffToShutter() && diff < 100 && (System.currentTimeMillis() - lastShutterTime.get() > 60_000)) {
                    ULog.i(TAG, "外部温度变化较大，快门校正");
                    lastShutterTime.set(System.currentTimeMillis());
                    mHandler.sendEmptyMessage(Msg.WHAT_SHUTTER_ALL_IR_WHEN_LEAVE_BY);
                    historyTemp.clear();
                }
            }
        });
    }

    private void registerBluetoothEventObservers(){
        bluetoothMqttSubscribe = RxBus.getInstance().toObservable(BluetoothEvent.class)
                .filter(e -> BluetoothEvent.BLE_BLUETOOTH_MSG_HANDLE_ACTION == e.getAction())
                .subscribe(event -> {
                    ULog.d(TAG,"RobotBluetoothManager robot bluetoothMqttSubscribe 接收到蓝牙的消息");
                    switch (event.getType()){
                        case CMD_MOVE_FRONT:
                        case CMD_MOVE_BACK:
                        case CMD_MOVE_STOP:
                        case CMD_SET_SPEED:
                        case CMD_ENABLE_MOTOR:
                        case CMD_STANDBY:
                        case CMD_WAKEUP_STANDBY:
                        case CMD_OPEN_OBSTACLE:
                        case CMD_CLOSE_OBSTACLE:
                            MqttCommand cmd = (MqttCommand) event.getObj();
                            ULog.d(TAG,"RobotBluetoothManager bluetoothMqttSubscribe 接收到蓝牙的mqtt消息.");
                            onMessageReceived(cmd);
                            break;
                        case CMD_EMERGENCY_STOP:
                            //软件急停
                            ctrlSoftEmergencyStop(true, "蓝牙控制开启软件急停");
                            break;
                        case CMD_WAKEUP_EMERGENCY_STOP:
                            //唤醒急停
                            ctrlSoftEmergencyStop(false, "蓝牙控制关闭软件急停");
                            break;
                        case CMD_CURRENT_TEST_OPEN:
                            //开启电流测试
                            ctrlTestMotorCurrent(true);
                            //TODO jiao 待实现  ble可能不支持高频率消息
                            break;
                        case CMD_CURRENT_TEST_CLOSE:
                            //关闭电流测试
                            ctrlTestMotorCurrent(false);
                            //TODO jiao 待实现
                            break;
                        case CMD_CURRENT_LOG_OPEN:
                            //开启电流日志
                            ctrlDistanceCurrentLogSwitch(true);
                            //TODO jiao 待实现
                            break;
                        case CMD_CURRENT_LOG_CLOSE:
                            //关闭电流日志
                            ctrlDistanceCurrentLogSwitch(false);
                            //TODO jiao 待实现
                            break;
                        case CMD_CURRENT_LOG_UPLOAD:
                            //上传电流日志
                            //TODO jiao 待实现
                            distanceCurrentLogSwitchUpload();
                            break;
                        default:
                            break;
                    }
                });
    }

    private void registerNetworkEventObservers() {
        RxBus.getInstance().toObservable(NetworkEvent.class)
                .subscribe(networkEvent -> {
                    switch (networkEvent.getAction()) {
                        case NetworkEvent.ACTION_MQTT_CONNECT_FAILED_LONG_TIME: {
                            ULog.d(TAG, "MQTT通信异常 网络状态 " + NetworkService.isNetworkAvailable());
                            if (!NetworkService.isNetworkAvailable()) {
                                ULog.d(TAG, "MQTT通信异常，网络不可用，不报警");
                                break;
                            }
                            if (System.currentTimeMillis() - NetworkService.mIsNetworkAvailableTime < 30_000) {
                                ULog.d(TAG, "MQTT通信异常，网络刚恢复，不报警");
                                break;
                            }
                            List<String> params = new ArrayList<>();
                            params.add("MQTT");
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.COMMUNICATION_CONNECT_FAILED_LONG_TIME, params));
                        }
                        break;

                        case NetworkEvent.ACTION_NETTY_CONNECT_FAILED_LONG_TIME: {
                            ULog.d(TAG, "NETTY通信异常 网络状态 " + NetworkService.isNetworkAvailable());
                            if (!NetworkService.isNetworkAvailable()) {
                                ULog.d(TAG, "NETTY通信异常，网络不可用，不报警");
                                break;
                            }
                            if (System.currentTimeMillis() - NetworkService.mIsNetworkAvailableTime < (5 * 60_000)) {
                                ULog.d(TAG, "NETTY通信异常，网络刚恢复，不报警");
                                break;
                            }
                            List<String> params = new ArrayList<>();
                            params.add("NETTY");
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.COMMUNICATION_CONNECT_FAILED_LONG_TIME, params));
                        }
                        break;

                        default:
                            break;
                    }
                });
    }

    boolean isPowerKey = false;
    long lastCheckSleepTime = 0;
    long sleepTime = -1; //休眠时间 分钟
    int sleepTimeMoveHinder = -1; //运动阻碍关机时间 分钟
    boolean isRecordSleepTime; //是否记录过休眠时间
    boolean moveHinderNeedSleep; //运动阻碍是否需要休眠
    public boolean moveHinderLowPower; //运动阻碍是否需要执行低电量回充
    public boolean moveHinderNetDisconnect; //运动阻碍是否需要执行断网回充
    long nextArrangeDate = 0;//下次开始排班巡检时间
    //排班巡检 时间点和对应是否巡检
    Map<Long, Boolean> arrangeMap = new HashMap<>();

    /**
     * @return 是否休眠
     */
    public boolean checkArrangeInspection(boolean isForce) {
        if (isUpgrading) {
            ULog.d(TAG, "checkArrangeInspection 升级中，不能休眠");
            return false;
        }
        if (System.currentTimeMillis() - lastCheckSleepTime < 5000) {
            ULog.d(TAG, "checkArrangeInspection 休眠检测间隔小于5秒，等下次 isForce = " + isForce);
            if (!isForce) return false;
        }
        lastCheckSleepTime = System.currentTimeMillis();
        long currentTime = System.currentTimeMillis();
        //下次唤醒时间
        Date nextWakeDate = new Date(0);
        Date nextTriggerDate = null;
        Date previousTriggerDate = null;
        CronExpression schedulerExpression = null;
        int expressDiff = 15, sleepWakeupInterval = 30;
        boolean isArrange = false;//是否有巡检参数
        //排班巡检相关参数
        if (MainApp.isArrangeInspect(getRobot().getChargeStrategy()) && !TextUtils.isEmpty(
                getRobot().getCornExpress())) {
            try {
                schedulerExpression = new CronExpression(getRobot().getCornExpress());
            } catch (Exception e) {
                ULog.d(TAG, "scheduler inspection schedule job failed");
                e.printStackTrace();
            }
            if (getRobot() != null && getRobot().getSleepWakeupInterval() != null) {
                sleepWakeupInterval = getRobot().getSleepWakeupInterval();
            }
            expressDiff = getRobotConfigParams().getArrangeInspectDiff();
            ULog.d(TAG, "startSleep expressDiff 误差时间 " + expressDiff);
            if (schedulerExpression != null) {
                nextTriggerDate = schedulerExpression.getNextValidTimeAfter(new Date(currentTime));
                Long previousTriggerDateTime = currentTime - (expressDiff + 1) * 60_000;
                previousTriggerDate = schedulerExpression.getNextValidTimeAfter(new Date(previousTriggerDateTime));
                ULog.d(TAG, "checkArrangeInspection previousTriggerDateTime " +UTime.getStringFromDate(previousTriggerDate));
                arrangeMap.putIfAbsent(nextTriggerDate.getTime(), false);
                arrangeMap.putIfAbsent(previousTriggerDate.getTime(), false);

                Object[] keys = arrangeMap.keySet().toArray();
                Arrays.sort(keys);
                List<Long> deleteData = new ArrayList<>();
                for (int i = 0; i < keys.length; i++) {
                    if (previousTriggerDateTime - ((Long) keys[i]) >= 0) {
                        deleteData.add(((Long) keys[i]));
                    }
                    ULog.d(TAG, "startSleep arrangeMap == " + i
                            + " time " + UTime.getStringFromDate(new Date((Long) keys[i]))
                            + " == " + arrangeMap.get(keys[i])
                            + " == delete = " + (previousTriggerDateTime - ((Long) keys[i]) >= 0));
                }
                for (Long time : deleteData) {
                    arrangeMap.remove(time);
                }
                isArrange = true;
            }

        }

        boolean isSleepMode = getRobot().getSleepMode() == null ? false : getRobot().getSleepMode() == 1;
        sleepTime = 30;
        if (getRobot() != null && getRobot().getSleepWakeupInterval() != null) {
            sleepTime = getRobot().getSleepWakeupInterval();
        }
        //休眠打开，非排班优先 则直接休眠
        if (isSleepMode && getRobot().getChargeStrategy() != ChargingStrategy.INSPECTION_RUNS_ARRANGE_SLEEP) {
            if (sleepTime > 135) {
                sleepTime -= 120;
            }
            return true;
        } else if (isSleepMode && getRobot().getChargeStrategy() == ChargingStrategy.INSPECTION_RUNS_ARRANGE_SLEEP) {
            //休眠打开 且为 排班优先
            //计算是否需要休眠
            boolean isSleep = computeIsSleep(nextTriggerDate,
                    previousTriggerDate,
                    currentTime,
                    nextWakeDate,
                    expressDiff,
                    schedulerExpression);

            ULog.d(TAG,
                    "排班巡检 startSleep 表达式getCornExpress() " + getRobot().getCornExpress() + " 下次触发时间：" + UTime.getStringFromDate(
                            nextTriggerDate) + " 距离开始时间： " + (nextTriggerDate.getTime() - System.currentTimeMillis()) + " 上次可能触发时间：" + UTime.getStringFromDate(
                            previousTriggerDate) + " 下次唤醒时间 " + (nextWakeDate.getTime() == 0 ? "无" : UTime.getStringFromDate(nextWakeDate)) + " 是否应该休眠 " + isSleep + " 休眠时长 " + sleepTime + "分 mode " + MODE);

            if (isSleep && MODE != MODE_INSPECTION) {
                //下次唤醒时间小于下次排班巡检时间 继续休眠
                return true;
            } else {
                nextArrangeDate = System.currentTimeMillis() + 2_000;
                ULog.d(TAG,
                        "startSleep 无需休眠，通知下位机退出休眠 inCharger " + inCharger() + " nextArrangeDate " + UTime.getStringFromDate(new Date(
                                nextArrangeDate)));
                return false;
            }
        } else if (!isSleepMode) {
            if (isArrange) { //有排班巡检参数
                boolean isSleep = computeIsSleep(nextTriggerDate,
                        previousTriggerDate,
                        currentTime,
                        nextWakeDate,
                        expressDiff,
                        schedulerExpression);

                Object[] keys = arrangeMap.keySet().toArray();
                Arrays.sort(keys);
                for (int i = 0; i < keys.length; i++) {
                    ULog.d(TAG,
                            "startSleep arrangeMap == " + i + " time " + UTime.getStringFromDate(new Date((Long) keys[i])) + " == " + arrangeMap.get(
                                    keys[i]));
                    if (!arrangeMap.get(keys[i])) {
                        nextArrangeDate = (long) keys[i];
                        break;
                    }
                }
                ULog.d(TAG,
                        "排班巡检222 startSleep 表达式getCornExpress() " + getRobot().getCornExpress() + " 下次触发时间：" + UTime.getStringFromDate(
                                nextTriggerDate) + " 距离开始时间： " + (nextTriggerDate.getTime() - System.currentTimeMillis()) + " 上次可能触发时间：" + UTime.getStringFromDate(
                                previousTriggerDate) + " 下次唤醒时间 " + (nextWakeDate.getTime() == 0 ? "无" : UTime.getStringFromDate(
                                nextWakeDate)) + " 是否应该休眠 " + isSleep + " 休眠时长 " + sleepTime + "分 mode " + MODE + " nextArrangeDate " + UTime.getStringFromDate(
                                new Date(nextArrangeDate)));
            }
        }
        return false;
    }

    //是否可以执行休眠 true可以休眠 false不用休眠 可以执行巡检
    private boolean computeIsSleep(Date nextTriggerDate, Date previousTriggerDate, long currentTime, Date nextWakeDate, int expressDiff,
                                   CronExpression schedulerExpression) {
        ULog.d(TAG, "startSleep computeIsSleep = nextTriggerDate " + UTime.getStringFromDate(nextTriggerDate));

        if (arrangeMap.get(nextTriggerDate.getTime()) == null) {
            arrangeMap.put(nextTriggerDate.getTime(), false);
        }

        //当前时间小于下次触发时间减去误差时间 则应该休眠
        boolean isSleep = currentTime < (nextTriggerDate.getTime() - expressDiff * 60_000);
        if (isSleep) { //到下一次是要休眠的
            isSleep = nextTriggerDate.getTime() == previousTriggerDate.getTime();
            if (isSleep) {
                //两次时间一样 应该休眠到下一次 计算休眠时间
                nextWakeDate.setTime(computeSleepTime(nextTriggerDate.getTime(), currentTime));
            } else { //两次时间不一样 说明是在上次排班点的范围内，应执行巡检
                //在上一次的巡检时间内 不休眠 检测上一次是否巡检过
                isSleep = arrangeMap.get(previousTriggerDate.getTime()) == null ? false : arrangeMap.get(previousTriggerDate.getTime()); //上一次已经巡检过了，应该休眠
                if (isSleep) {
                    nextWakeDate.setTime(computeSleepTime(nextTriggerDate.getTime(), currentTime));
                } else {
                }//else不休眠 执行巡检
            }
        } else {
            //不休眠时，如果下次已经触发过了，则应该休眠
            isSleep = arrangeMap.get(nextTriggerDate.getTime()) == null ? false : arrangeMap.get(nextTriggerDate.getTime());
            if (isSleep) {
                nextTriggerDate = schedulerExpression.getNextValidTimeAfter(nextTriggerDate); //下下次的时间点
                //递归计算下下次是否需要休眠
                isSleep = computeIsSleep(nextTriggerDate, previousTriggerDate, currentTime, nextWakeDate, expressDiff, schedulerExpression);
            }
        }
        return isSleep;
    }

    /**
     * 计算休眠时间 返回下次唤醒时间
     *
     * @param nextTime
     * @param currentTime
     *
     * @return
     */
    private long computeSleepTime(long nextTime, long currentTime) {
        long result = nextTime - currentTime;
        //若大于2小时15分则为2小时后唤醒
        if (result > (135 * 60_000)) {
            sleepTime = (result - 120 * 60_000) / 1000 / 60;
            result = nextTime - (sleepTime * 60_000);
        } else {
            sleepTime = result / 1000 / 60;
            result = nextTime;
        }
        return result;
    }

    /**
     * 进入低功耗模式
     * 上位机尽可能断电，拉高PMIC口 切换大部分区域供电
     * 下位机也会进入休眠模式
     * 触发消息请使用{@link  fun.unifun.insbot.robot.brain.robot.Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE}
     */
    private void enterPowerSaveMode() {
        ULog.w(TAG, "startSleep 进入休眠模式 enterPowerSaveMode webCamera 网络摄像头断电");
        getRobot().setSleepMode(UConstants.VALUE_SWITCH_STATUS_ON);
        RobotPreferences.getInstance(getContext()).setRobot(getContext(), getRobot());

        pushDeviceControl(false,"2", false);

//        //传感器 导致循环触发
//        stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_POWER_CONTROL, 0));

        //拉低蓝牙 和Wifi
        SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_BT, 0);
        SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_WIFI, 0);

        //        int interval = 30;
        //        if (getRobot() != null && getRobot().getSleepWakeupInterval() != null) {
        //            interval = getRobot().getSleepWakeupInterval();
        //        }
        //        int bms = (int)(interval * 60 - interval * 4.6);
        if (mRobotType != null && mRobotType.getSubType() != RobotSubType.BZ) {
            long tempTime = sleepTime;
            if (moveHinderNeedSleep) {
                ULog.d(TAG, "startSleep 运动阻碍关机 " + sleepTimeMoveHinder);
                tempTime = sleepTimeMoveHinder;
            }
            int batteryClusterNum = SensorInfoProvider.of(getRobot().getId()).cacheInfo().BMS_INFO != null ?
                    SensorInfoProvider.of(getRobot().getId()).cacheInfo().BMS_INFO.getBatteryClusterNum() : 7;
            int bms = (int) (tempTime / 2.0 * 60);
            if (batteryClusterNum >= 7) {
                bms = (int) (tempTime * 60);
            }
            RobotConfigParams params = getRobotConfigParams();
            boolean disableBatterySleep = params.getDisableBatterySleep();
            ULog.d(TAG,
                    "startSleep 开始执行休眠 间隔 " + sleepTime + "分 电池休眠间隔 " + bms + "秒 分:" + bms / 60.0 + " disableBatterySleep " + disableBatterySleep + " batteryClusterNum " + batteryClusterNum);
            if (!disableBatterySleep) {
                String reason = "Power-Save";
                if (moveHinderNeedSleep) reason = "move_hinder_BMS_" + sleepTimeMoveHinder;
                BaseBmsCommunicator.getInstance().enterPowerSaveMode(Math.min(bms, 65534), reason);
            }
        }

        Observable.just(1)
                .observeOn(Schedulers.io())
                .subscribe(t -> {
                    ULog.d(TAG, "startSleep 10s后执行休眠指令");
                    Thread.sleep(10000);
                    ULog.d(TAG, "startSleep 拉高GPIO PMIC");
                    gpioCtrl(UConstants.GPIO_PMIC_SLEEP, 1);
                    //                    URootCmd.execRootCmd("echo mem > /sys/power/state");
                });
    }

    private void quitPowerSaveMode() {
        ULog.d(TAG, "quitPowerSaveMode 退出休眠 webCamera 网络摄像头上电");
        pushDeviceControl(true,"3", false);
        mHandler.sendEmptyMessage(Msg.WHAT_CHECK_WEB_CAMERA);
        //热成像
        SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_USB_RESET, 1);
        bindIrService();
        if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_ARR)) {
            mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_ARR);
        }
        if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
            mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_SDK);
        }

        //传感器
        stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_POWER_CONTROL, 1));
        ULog.d(TAG, "拉高GPIO PMIC");

        //控制PMIC
        gpioCtrl(UConstants.GPIO_PMIC_SLEEP, 0);
    }

    ModBusManager beltConveyorStatus;

    private synchronized void startHeart() {
        ULog.d(TAG, "robot startHeart called ," + mIsHeartStarted);
        if (mIsHeartStarted) {
            return;
        }
        mIsHeartStarted = true;

        //获取segment信息(此数据现在实时获取振动传感器数据)
        if (!mHandler.hasMessages(Msg.WHAT_GET_SEGMENT)) {
            mHandler.sendEmptyMessage(Msg.WHAT_GET_SEGMENT);
        }
        mHandler.sendEmptyMessage(Msg.WHAT_INIT_MQTT);

        //第一时间通知服务器在线状态
        RxBus.getInstance().post(new RobotHeartEvent(RobotEventConstants.EVENT_SEND_CONNECT_TEST));

        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SAVE_TEMPERATURE, 20000);
        //开始心跳 启动心跳
        mHandler.sendEmptyMessage(Msg.WHAT_SEND_HEART);
        //舵机测试
//        mHandler.sendEmptyMessage(Msg.WHAT_STEERING_ENGINE_TEST);

        String rebootTest = StorageCenter.getRobotStorage().getString("stmRebootAndroid", "unknown");
        if (rebootTest.contains("stmRebootAndroid")) {
            String timeStrStmRebootAndroid = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CHINA).format(new Date());
            StorageCenter.getRobotStorage().putString(KeyConstant.Storage.LAST_REBOOT_REASON, rebootTest + " stmRebootAndroid ,op:TestActivity");
            StorageCenter.getRobotStorage().putString(KeyConstant.Storage.LAST_REBOOT_TRIGGER_TIME, timeStrStmRebootAndroid);
            StorageCenter.getRobotStorage().putString("stmRebootAndroid", "stmRebootAndroid_" + (Integer.parseInt(rebootTest.substring(rebootTest.indexOf("_")+1)) + 1));
            StorageCenter.getRobotStorage().save();
            mHandler.postDelayed(() -> {
                String rebootTest2 = StorageCenter.getRobotStorage().getString("stmRebootAndroid", "unknown");
                if (rebootTest.contains("stmRebootAndroid"))
                    stmExecute.executeTask(new StmTask().stmRebootAndroid());
            }, 10_000);
        }
        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SEND_LOCATION, 20000);
        //获取机器人所有在线用户
        mHandler.sendEmptyMessage(Msg.WHAT_GET_ACCOUNTS);
        //开始读取里程信息
        //        mHandler.sendEmptyMessage(Msg.WHAT_READ_MOTOR_INFO);
        //服务器心跳robot状态
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SERVER_ROBOT_STATUS_HEART, 10000);
        //传感器信息更新
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_RECORD_UPDATE, 10000);
        //服务器心跳 使用测试接口
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SERVER_HEART, 30000);
        //传感器历史数据上传
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_RECORD, 40_000);
        //刷新上傳位置標識
        //        mHandler.sendEmptyMessage(Msg.WHAT_INIT_UPLOAD_LOCAL_FLAG);
        //        //音频推流
        //        startAudioAnalysis();
        //        //分贝模块
        //        mHandler.sendEmptyMessage(Msg.WHAT_START_QUERY_DECIBEL);
        //开始获取补光灯亮度
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_READ_FILL_LIGHT_LEVEL, 2 * 1000);
        //        //开始红外自检
        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_IR_CHECK, 10 * 1000);
        //移动检测
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_MOVE_CHECK, 30 * 1000);
        //上传网络信号强度
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_UPDATE_RSSI, 10 * 1000);
        //30分钟重置报警
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_RESET_ALERT, 30 * 60 * 1000);
        //开始分贝模块自检
        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_DECIBEL_CHECK, 20 * 1000);
        //开始读里程自检
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_HEART, 5 * 60 * 1000);
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_SERIAL_PORT, 30 * 1000);
        lastCheckSerialPortTime = System.currentTimeMillis();
        //获取网络速度
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_NETWORK_SPEED, 10 * 1000);

        mHandler.sendEmptyMessageDelayed(Msg.WHAT_UPLOAD_HIS_TIME, 5 * 1000);

        mHandler.sendEmptyMessageDelayed(Msg.WHAT_UPDATE_TV, 5 * 1000);

        //传感器数据打印
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_PRINT_SENSOR_DATA, 10_000);

        //启动自身基础信息共享消息广播
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_BROADCAST_ROBOT_INFO, 10_000);
        //        timer.schedule(timerTask, 10000, 200);
        //        if (taskMileage != null) taskMileage.cancel(true);
        resetStmHeart();
        if (MainApp.YOLOV7) resetIrTicks();
        mStmHeartDataProcessThread = new StmHeartDataProcessThread();
        mStmHeartDataProcessThread.start();

        if (!uploadAlarmPicThread.isAlive()) {
            uploadAlarmPicThread.start();
        }

        if (mBotInfoMgr.getRobotMainType() == RobotMainType.CICADA) {
            //CICADA 机型启动语言对讲
            ChatSocketClient chatClient = new ChatSocketClient();
            chatClient.init(getRobot().getId());
        }
    }

    private void initData() {
        ULog.e("===========>>initData");

        //      //广播测试
        IntentFilter intentFilter = new IntentFilter();
        //测试广播========================
        //        intentFilter.addAction("start_ez_record");
        //        intentFilter.addAction("stop_ez_record");
        //        intentFilter.addAction("start_ir_audio_record");
        //        intentFilter.addAction("stop_ir_audio_record");
        //        intentFilter.addAction("test_exception");
        //        intentFilter.addAction("start_ir_record");
        //        intentFilter.addAction("stop_ir_record");
        //        intentFilter.addAction("update_temperature");
        //        intentFilter.addAction("frame_loss_test");
        intentFilter.addAction("test");
        intentFilter.addAction("save_ir_result");
        intentFilter.addAction("start_audio");
        intentFilter.addAction("stop_audio");

        intentFilter.addAction("alarm_ir");
        intentFilter.addAction("alarm_rgb");

        intentFilter.addAction("test_play_media");
        intentFilter.addAction("test_play_sound_pool");
        intentFilter.addAction("test_play_audio_treack");
        intentFilter.addAction("rtsp_debug");
        //        intentFilter.addAction("belt_open");
        //        intentFilter.addAction("belt_close");
        //        intentFilter.addAction("start_audio_record");
        //        intentFilter.addAction("stop_audio_record");
        //        intentFilter.addAction("low_battery");
        //        intentFilter.addAction("kill_oneself");
        //        intentFilter.addAction("batch_production_test");

        //        intentFilter.addAction(UConstants.ACTION_VERIFY);
        //        intentFilter.addAction(UConstants.ACTION_GET_ID);
        intentFilter.addAction(UConstants.NET_BROADCAST_RECEIVE);
        //        intentFilter.addAction(UConstants.ACTION_GET_GUARD_OBJECT);

        mActivity.registerReceiver(receiver, intentFilter);
        ////        mHandler.sendEmptyMessage(Msg.WHAT_TEST_BROAD);
        ////        initEz();
        if (!mIsRobotInitialized) {
            mSequenceInitializer.cancelSequence();
            mSequenceInitializer.startInit();
        }
    }

    /**
     * @return 是否消费
     */
    public boolean readCache() {
        int cacheMode = UPreferences.getInt(mActivity, UConstants.PREFERENCES_MODE_KEY, -2);
        setInCharger(UPreferences.getInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0) == 1,"readCache");
        isSleep = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_ROBOT_SLEEP_KEY, false);
        batteryAutoOff = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_BATTERY_AUTO_OFF_KEY, false);
        inspectManager.isInspectHead = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_INSPECT_HEAD_KEY, false);
        inspectManager.isInspectTail = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_INSPECT_TAIL_KEY, false);
        startInspectTime = UPreferences.getLong(mActivity, UConstants.PREFERENCES_START_INSPECT_TIME_KEY);

        MainApp.mileOffset = UPreferences.getFloat(mActivity, "MILE_OFFSET", MainApp.mileOffset);
        MainApp.hAngleOffset = UPreferences.getInt(mActivity, "H_ANGLE_OFFSET", MainApp.hAngleOffset);
        MainApp.vAngleOffset = UPreferences.getInt(mActivity, "V_ANGLE_OFFSET", MainApp.vAngleOffset);
        MainApp.BMS_HEAT_STATUS = UPreferences.getInt(mActivity, UConstants.PREFERENCES_BMS_HEAT, -1);
        MainApp.batteryCheckStatus = StorageCenter.getRobotStorage().getInteger(KeyConstant.Storage.BATTERY_CHECK_STATUS, 0);

        inspectManager.readCacheHandledVarianceFlag();
        long tempTime = UPreferences.getLong(mActivity, UConstants.PREFERENCES_START_INSPECT_TIME_KEY, -1);
        if (tempTime > 0) startInspectionTime = new Date(tempTime);
        MainApp.turnAroundDate = UPreferences.getLong(mActivity, UConstants.PREFERENCES_TURN_AROUND_DATE_KEY, 0);
        isCacheStartInspectTime = cacheMode == MODE_INSPECTION || cacheMode == MODE_CHECKING_STOP || cacheMode == MODE_GOTO_CHARGER;
        isCacheTurnAroundDate = isCacheStartInspectTime;
        inspectManager.inspectDirection = UPreferences.getInt(mActivity, UConstants.PREFERENCES_INSPECTION_USE_ANGLE_TYPE_KEY, 0);
        if (inspectManager.inspectDirection == 1 || inspectManager.inspectDirection == 2) {
            inspectManager.inspectDirectionIsUpdate = true;
        }

        int cacheRobotDirection = UPreferences.getInt(mActivity, UConstants.PREFERENCES_DIRECTION_KEY, 1);
        pushType = UPreferences.getInt(mActivity, UConstants.PREFERENCES_PUSH_TYPE_INDEX_KEY, 0);

        ULog.d(TAG, "initData:  ======= 缓存数据 " + cacheMode);
        if ((getRobot() != null && getRobot().getIrCameraNum() > 0) && (cacheMode == MODE_INSPECTION || cacheMode == MODE_COLLECTION_RAW_DATA_MP4 || cacheMode == MODE_UN_KNOW)) {
            if (!irPusher.isPushInit) {
                if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                    mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_SDK);
                }
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_READ_CACHE, 2000);
                return true;
            }
        }
        switch (cacheMode) {
//            case MODE_RECLAIMER:
//                autoMoveManager.gotoChargerCheck(5);
//                return true;
            case MODE_INSPECTION:
            case MODE_CHECKING_STOP:
                continueInspection(cacheRobotDirection);
                return true;
            case MODE_UN_KNOW:
                if (getRobot() != null) {
                    if (getRobot().getChargeStatus() == ChargerStatus.CHARGE_END || getRobot().getChargeStatus() == ChargerStatus.CHARGE_FRONT) {
                        if (inCharger() && getInspectEnableThreadNeedExec()) {
                            mInspectionEnableThread.start();
                        }
                    }
                }
                return true;
            default:
                break;
        }
        return false;
    }

    BroadcastReceiver receiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getAction() != null) {
                ULog.d(TAG, "onReceive:  === action ==== " + intent.getAction());
                switch (intent.getAction()) {
                    //                    case UConstants.ACTION_GET_GUARD_OBJECT:
                    //                        Intent intent1 = new Intent(UConstants.ACTION_SET_GUARD_OBJECT);
                    //                        if (getRobot() != null) {
                    //                            intent1.putExtra("deviceId", getRobot().getId());
                    //                            context.sendBroadcast(intent1);
                    //                        } else if (!TextUtils.isEmpty(robotId)) {
                    //                            intent1.putExtra("deviceId", robotId);
                    //                            context.sendBroadcast(intent1);
                    //                        }
                    //                        break;
                    case UConstants.NET_BROADCAST_RECEIVE:
                        ULog.d(TAG, "onReceive:  ====  网络发生变化 ======= " + UNet.checkNet(mActivity));
                        break;
                    //                    case UConstants.ACTION_GET_ID:
                    //                        if (MainApp.robotType == RobotType.BEETLE_EZ_TWO_C) {
                    //                            if (getRobot() != null && ezRecordIsAlive()) {
                    //                                try {
                    //                                    ezRecord.setRobotId(getRobot().getId());
                    //                                } catch (RemoteException e) {
                    //                                    e.printStackTrace();
                    //                                }
                    //                            }
                    //                        } else if (MainApp.robotType != -1) {
                    //                            mActivity.sendBroadcast(new Intent(UConstants.ACTION_GET_ID_END));
                    //                        }
                    //                        break;
                    case "start_ez_record":
                        ULog.d(TAG, "onReceive:  ==== start_ez_record ");
                        //                        ezStartPreviewAndRecord();
                        break;
                    case "save_ir_result":
                        int mode = intent.getIntExtra("mode", 0);
                        String filePath = intent.getStringExtra("filePath");
                        String filePath2 = intent.getStringExtra("filePath2");
                        if (mode == 0) {
                            IrManager.saveIrDataNum = 0;
                            IrManager.costTotal = 0;
                            MainApp.isSaveIrData = true;
                        } else {
                            int SIZE = intent.getIntExtra("buffer_size", 2 * 1024 * 1024);
                            int deflater_buffer_size = intent.getIntExtra("deflater_buffer_size", 2 * 1024 * 1024);
                            int num = intent.getIntExtra("num", 10);
                            ULog.d(TAG, "SaveIrData  SIZE " + SIZE + " num " + num + " deflater_buffer_size " + deflater_buffer_size);
                            final String fFilePath = TextUtils.isEmpty(filePath) ? "/storage/636E-1904/ir_origin_data_front/1682061327208.raw_data" : filePath;
                            final String fFilePath2 = TextUtils.isEmpty(filePath2) ? fFilePath : filePath2;
                            for (int i = 0; i < num; i++) {
                                String fffFilePath  = i == 1 ? fFilePath2 : fFilePath;
                                int index = i;
                                new Thread(new Runnable() {
                                    @Override
                                    public void run() {
                                        int BUFFER_SIZE = SIZE;
                                        long time = System.currentTimeMillis();
                                        File file = new File(fffFilePath);
                                        if (!file.exists()) {
                                            ULog.d(TAG, "SaveIrData  file.exists()");
                                            return;
                                        }
                                        String tarFileName = fffFilePath + "_" + index + ".zip";
                                        byte[] data = new byte[BUFFER_SIZE];
                                        int count;
                                        try {
                                            FileInputStream srcFileInputStream = new FileInputStream(file);
                                            BufferedInputStream bfInputStream = new BufferedInputStream(srcFileInputStream);
                                            FileOutputStream fileOutputStream = new FileOutputStream(tarFileName);
                                            BufferedOutputStream bfOutStream = new BufferedOutputStream(fileOutputStream);

                                            //===================Deflater =======================================

//                                    //使用指定的压缩级别创建一个新的压缩器。
//                                    Deflater deflater = new Deflater(Deflater.BEST_SPEED);
//                                    DeflaterOutputStream deflaterOut = new DeflaterOutputStream(bfOutStream, deflater);
//
//                                    while ((count = bfInputStream.read(data)) != -1) {
//                                        deflaterOut.write(data, 0, count);
//                                    }

                                            //===================gzip=======================================
                                            Deflater deflater = new Deflater(Deflater.BEST_SPEED, true);
                                            UGZIPOutputStream gzipOutStream = new UGZIPOutputStream(bfOutStream, deflater, deflater_buffer_size);

                                            while ((count = bfInputStream.read(data)) != -1) {
                                                gzipOutStream.write(data, 0, count);
                                            }
                                            gzipOutStream.finish();
                                            gzipOutStream.close();


                                            //===================zip=======================================

//                            ZipOutputStream zip = new ZipOutputStream(bfOutStream);
//                            zip.putNextEntry(new ZipEntry("0"));
//
//                            while ((count = bfInputStream.read(data)) != -1) {
//                                zip.write(data, 0, count);
//                            }
//                            zip.closeEntry();
//                            zip.close();


                                            //===================7z=======================================
                                            //                            BufferedInputStream inStream = new BufferedInputStream(new ByteArrayInputStream(xml.getBytes()));
                                            //                            ByteArrayOutputStream bos = new ByteArrayOutputStream();

                                            //                            boolean eos = true;
                                            //                            Encoder encoder = new Encoder();
                                            //                            encoder.SetEndMarkerMode(eos);
                                            //                            encoder.WriteCoderProperties(bfOutStream);
                                            //                            long fileSize = file.length();
                                            //                            if (eos)
                                            //                                fileSize = -1;
                                            //                            for (int i = 0; i < 8; i++)
                                            //                                bfOutStream.write((int)(fileSize >>> (8 * i)) & 0xFF);
                                            //                            encoder.Code(bfInputStream, bfOutStream, -1, -1, null);



                                            //===================7z=======================================
//                                    String inputFile = file.getAbsolutePath(); // 输入文件路径
//                                    String compressedFile = tarFileName; // 压缩后的文件路径
//
//                                    // 设置压缩参数
//                                    String[] parameters = {
//                                            "e",
//                                            "-a0",
//                                            "-d12",
//                                            "-fb8",
//                                            inputFile,
//                                            compressedFile
//                                    };
//
//                                    // 调用 LZMA SDK 的 LzmaAlone 类的 main 方法进行压缩
//                                    LzmaAlone.main(parameters);
                                            data = null;
                                            ULog.i(TAG, "deflater SaveIrData zip file finished. " + tarFileName + " time " + (System.currentTimeMillis() - time));
                                        } catch (Exception e) {
                                            e.printStackTrace();
                                        }

                                    }
                                }).start();
                            }
                        }
                        break;
                    case "belt_open":
                        //21 02 01 00 AA 48
                        byte[] bOpen = new byte[6];
                        bOpen[0] = 0x21;
                        bOpen[1] = 0x02;
                        bOpen[2] = 0x01;
                        bOpen[3] = 0x01;
                        jdqParseResult(bOpen);
                        break;
                    case "belt_close":
                        //21 02 01 00 AA 48
                        byte[] bClose = new byte[6];
                        bClose[0] = 0x21;
                        bClose[1] = 0x02;
                        bClose[2] = 0x01;
                        bClose[3] = 0x00;
                        jdqParseResult(bClose);
                        break;
                    case "stop_ez_record":
                        ULog.d(TAG, "onReceive:  ==== stop_ez_record ");
                        //                        ezStopRecord(-1);
                        break;
                    case "start_ir_record":
                        //                        startRecordIrFile();
                        break;
                    case "start_audio_record":
                        ULog.d(TAG, "AudioManager onReceive:  ==start ==  ");
                        AudioManager.getInstance(mActivity).startRecordFile(getRobot().getId() + "_" + System.currentTimeMillis());
                        break;
                    case "stop_audio_record":
                        ULog.d(TAG, "AudioManager onReceive:  ==stop ==  " + AudioManager.getInstance(mActivity).stopRecordingFile());
                        break;
                    case "stop_ir_record":
                        //                        ULog.d(TAG, "onReceive:  ==stop_ir_record ==  " + stopIrRecordAndUpload());
                        break;
                    case "start_audio":
                        mHandler.sendEmptyMessage(Msg.WHAT_GET_AUDIO_STREAM);
                        break;
                    case "stop_audio":
                        if (playAudio != null)
                            playAudio.stop();
                        break;
                    case "start_ir_audio_record":
                        ULog.d(TAG, "onReceive:  == test == start");
                        //                        startRecordIrFile();
                        //                        AudioManager.getInstance(mActivity).startRecordFile(getRobot().getId() + "_" + System.currentTimeMillis());
                        break;
                    case "stop_ir_audio_record":
                        //                        ULog.d(TAG, "onReceive:  == test == stop");
                        //                        String irFile = stopIrRecordAndUpload();
                        //                        String audioFile = AudioManager.getInstance(mActivity).stopRecordingFile();
                        //                        getExecutorService().execute(() -> {
                        //                            try {
                        //                                stopRecordAndMuxingThenUpload(irFile, audioFile, 1);
                        //                            } catch (IOException e) {
                        //                                e.printStackTrace();
                        //                            }
                        //                        });
                        break;
                    case "kill_oneself":
                        ULog.d(TAG, "onReceive:  ==== kill_oneself ");
                        //                    android.os.Process.killProcess(android.os.Process.myPid());
                        //                    System.exit(0);
                        //                    ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
                        //                    manager.killBackgroundProcesses("fun.unifun.insbot.robot.brain");
                        URootCmd.execRootCmdSilent("kill -9 " + android.os.Process.myPid());
                        break;
                    case "test_exception":
                        int a = 1 / 0;
                        break;
                    case "update_temperature":
                        robotOutsideTemperature = Double.parseDouble(intent.getStringExtra("temperature"));
                        break;
                    case "frame_loss_test":
                        frameLossTest = true;
                        break;
                    case "low_battery":
                        battery = intent.getIntExtra("battery", 30);
                        break;
                    case "batch_production_test":
                        MqttCommand testCommand = new MqttCommand();
                        testCommand.setSource("test");
                        testCommand.setTarget("RK_100000015");
                        testCommand.setType(MqttCommand.AGING_TEST_INDEX);
                        testCommand.setAction(" ");
                        ULog.d(TAG, "onReceive:  ===========test ======= connect = " + MqttManager.getInstance().isConnected());
                        if (MqttManager.getInstance().isConnected()) {
                            mMqttManager.publishMessage(testCommand);
                        }
                        break;
                    case "test":
                        ULog.d(TAG, "onReceive: ==========test ========================== ");
                        //                        reInitIr();
                        break;
                    case "alarm_ir":
                        ULog.d(TAG, "alarm_test_ir " + getAlarmIrImgFileName(System.currentTimeMillis()));
                        break;
                    case "alarm_rgb":
                        ULog.d(TAG, "alarm_test_rgb " + getAlarmRgbImgFileName(System.currentTimeMillis()));
                        break;
                    case "rtsp_debug":
                        SmartRtspToRtmp.isAutoInspect = true;
                        getWebCameraPusher().rollBackLogTest();
                        break;
                    case "test_play_media":
                        ULog.d(TAG, "onReceive: ==========test_play_media ========================== " + intent.getIntExtra("num", 1));
                        new Thread(new Runnable() {
                            @Override
                            public void run() {
                                for (int i = 0; i < intent.getIntExtra("num", 1); i++) {
                                    ULog.d(TAG, "test_play_media == " + i);
                                    Intent mediaService = new Intent(mActivity, SoundPoolService.class);
                                    mediaService.setAction(SoundPoolService.ACTION_PLAY);
                                    if (intent.getIntExtra("type", 0) == 1) {
                                        mediaService.putExtra("inspect", 1);
                                    } else if (intent.getIntExtra("type", 0) == 2) {
                                        mediaService.putExtra("low_power", 1);
                                    }
                                    mActivity.startService(mediaService);
                                    try {
                                        Thread.sleep(3300);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                }
                            }
                        }).start();
                        break;
                    /*case "test_play_sound_pool":
                        ULog.d(TAG, "onReceive: ==========test_play_sound_pool ========================== " + intent.getIntExtra("num", 1));

                        new Thread(new Runnable() {
                            @Override
                            public void run() {
                                for (int i = 0; i < intent.getIntExtra("num", 1); i++) {
                                    ULog.d(TAG, "test_play_sound_pool == " + i);

                                    if (MainApp.mSoundPool != null) MainApp.mSoundPool.release();
                                    MainApp.mSoundPool = new SoundPool(5, android.media.AudioManager.STREAM_MUSIC,8);
                                    soundMap.put(0, MainApp.mSoundPool.load(mActivity, R.raw.inspect, 1));
                                    MainApp.mSoundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() {
                                        @Override
                                        public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
                                            ULog.d(TAG, "onReceive: ==========test_play_sound_pool onLoadComplete ========================== ");
                                            MainApp.mSoundPool.play(soundMap.get(0), 1, 1, 2, 0, 1);
                                        }
                                    });
                                    try {
                                        Thread.sleep(3000);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                }
                            }
                        }).start();

                        break;*/
                    /*case "test_play_audio_treack":
                        ULog.d(TAG, "onReceive: ==========test_play_audio_treack ========================== ");
                        //只支持PCM音频
                        new Thread(new Runnable() {
                            @Override
                            public void run() {
                                // 获取最小缓冲区
                                int bufSize = AudioTrack.getMinBufferSize(16000, AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT);
                                // 实例化AudioTrack(设置缓冲区为最小缓冲区的2倍，至少要等于最小缓冲区)
                                AudioTrack audioTrack = new AudioTrack(android.media.AudioManager.STREAM_MUSIC, 16000, AudioFormat.CHANNEL_OUT_STEREO,
                                        AudioFormat.ENCODING_PCM_16BIT, bufSize*2, AudioTrack.MODE_STREAM);
                                // 设置音量
                                audioTrack.setVolume(14f) ;
                                // 设置播放频率
                                audioTrack.setPlaybackRate(10) ;
                                audioTrack.play();
                                // 获取音乐文件输入流
                                InputStream is = getResources().openRawResource(R.raw.pcm_test);
                                byte[] buffer = new byte[bufSize*2] ;
                                int len ;
                                try {
                                    while((len=is.read(buffer,0,buffer.length)) != -1){
                                        ULog.d(TAG, "test_play_audio_treack 读取数据中...");
                                        // 将读取的数据，写入Audiotrack
                                        audioTrack.write(buffer,0,buffer.length) ;
                                    }
                                    is.close();
                                } catch (Exception e) {
                                    e.printStackTrace();
                                }
                            }
                        }).start();
                        break;*/

                    default:
                        break;
                }
            }
        }
    };
    private HashMap<Integer, Integer> soundMap = new HashMap<Integer, Integer>();
    int battery = 30; //电量测试


    int irType;
    boolean isCombineStop;
    boolean isCombine; //是否需要合并图像
    boolean combineThreadIsStarted = false;
    boolean pushFreamThreadIsStarted = false;
    //    private ScheduledFuture taskCombine;
    private ScheduledFuture taskComputeMile, taskReadMotorInfo;
    private ScheduledFuture taskIrTicks; //红外相关任务处理

    private void resetPusherParams() {
        String pushIrUrl = getPushIrUrl();
        ULog.e("resetPusherParams ====红外推流地址>>" + pushIrUrl);
        getIrPusher().setPushLanParams(getRobot().getId(), pushIrUrl, width, height);
        getIrPusher().init();
    }

    private synchronized void initLib() {
        ULog.d(TAG, "initLib:  ======= " + libIniting);
        if (getRobot() == null) return;
        if (IntUtil.isNullOr0(getRobot().getIrCameraNum())) {
            ULog.d(TAG, "===红外推送的数量为0（IrCameraNum字段）");
            return;
        }

        //避免推流导致的异常
        if (!UNet.ping() && getRobot().getPushStreamType() != PushManager.PUSH_LAN) {
            ULog.d(TAG, "initLib：网络连接异常");
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_SDK, 1000);
            return;
        }

        if (libIniting || irPusher.isPushing) {
            return;
        }
        if (width == 0 || height == 0) {
            if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_SDK, 1000);
            }
            return;
        }
        ULog.d(TAG, "initLib:  pushir  ==== widthIr = " + widthIr);
        if (widthIr == 0) {
            if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_SDK, 1000);
            }
            return;
        }
        libIniting = true;
        try {
            //红外初始化
            //            initIRThermalImage();
            //            Thread.sleep(100);

            //            PushFps fps = PushFps.FPS_10;
            PushFps fps = PushFps.FPS_25;
            if (irType == IrManager.TYPE_IRAY) {
                fps = PushFps.FPS_25;
                frameRate = 24;
            }
            if (getRobot().getPushEnable() != null) {
                pushCtrlIr(getRobot().getPushEnable());
                if (!mHandler.hasMessages(Msg.WHAT_CHECK_WEB_CAMERA)) {
                    mHandler.sendEmptyMessage(Msg.WHAT_CHECK_WEB_CAMERA);
                }
            }
            checkRobotVersion();
            String pushIrUrl = getPushIrUrl();
            ULog.e("====获取红外推流地址>>" + pushIrUrl);
            if (IntUtil.eq(getRobot().getPushStreamType(), PushManager.PUSH_WAN)) {
                //公网推流初始化
                irPusher.setType(PushManager.PUSH_WAN);
                irPusher.setPushWanParams(getRobot().getId(), pushIrUrl, width, height, fps);
            } else if (IntUtil.eq(getRobot().getPushStreamType(), PushManager.PUSH_LAN) && StrUtil.isNotBlank(pushIrUrl)) {
                //局域网推流初始化
                irPusher.setType(PushManager.PUSH_LAN);
                irPusher.setPushLanParams(getRobot().getId(), pushIrUrl, width, height);
            }
            if (IntUtil.eq(getRobot().getPushStreamType(), PushManager.PUSH_LAN) && StrUtil.isBlank(pushIrUrl)) {
                ULog.d(TAG, "initLib: pushir 局域网 红外推流地址为空 getLocalPushIrUrl = null");
                if (TextUtils.isEmpty(getRobot().getPushLocalIp())) {
                    ULog.d(TAG, "initLib: pushir 局域网 推流地址为空 getPushLocalIp = null");
                } else {
                    //                    UEasyDSS.createPushUrl(getRobot().getPushLocalIp(), getRobot().getId(), new UEasyDSS.RequestCallBack() {
                    //                        @Override
                    //                        public void onSuccess(String result) {
                    //                            ULog.d(TAG, "onSuccess: createPushUrl " + result);
                    //                            if (!TextUtils.isEmpty(result)) {
                    //                                getRobot().setLocalPushIrUrl(result);
                    //                                mLocalPushIrUrl = result;
                    //                            }
                    //                        }
                    //
                    //                        @Override
                    //                        public void onFailure(String msg) {
                    //                            ULog.d(TAG, "onFailure: createPushUrl " + msg);
                    //                        }
                    //                    });
                }
                libIniting = false;
                if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_SDK, 2000);
                }
                return;
            }
            irPusher.init();
            pushCtrlIr(getRobot().getPushEnable());
            SystemClock.sleep(100);
            //            float num = fps == PushFps.FPS_8 ? 9f : 12.7f;
            //            ULog.d(TAG, "initLib:  === fuck = time " + (long) (1000.0 / num));
            if (pushType == 0 && mBotInfoMgr.getRobotMainType() == RobotMainType.LADYBUG && getRobot().getRgbCameraNum() != 0) {
                isCombineStop = false;
                isCombine = true; //需要合并图像
                if (!combineThreadIsStarted) {
                    combineThreadIsStarted = true;
                    getExecutorService().execute(new CombineFrameHandle());
                }
                //                taskCombine = getScheduledExecutor().scheduleAtFixedRate(new CombineFrameHandle(), 500, (long) (1000.0 / 24), TimeUnit.MILLISECONDS);
            } else {
                isCombine = false; //不需要合并图像
            }
            ULog.d(TAG, "initlib: pushir PUSH_STREAM_TYPE===isCombine " + isCombine);
            //            getScheduledExecutor().scheduleAtFixedRate(new PushFrameHandle(), 600, (long) (1000.0 / num), TimeUnit.MILLISECONDS);
            isPush = true;
            if (!pushFreamThreadIsStarted) {
                pushFreamThreadIsStarted = true;
                getExecutorService().execute(new PushFrameHandle());
            }

            //mHandler.sendEmptyMessageDelayed(Msg.WHAT_PUSH_INIT, 0);
            //            avcCodec = new AvcEncoder(widthIr * 2, heightIr, frameRate, bitrate);
        } catch (Exception e) {
            e.printStackTrace();
        }
        libIniting = false;
    }

    boolean isStopSave = false;
    private Bitmap tempBitmap;
    Canvas irCanvas = null;
    private int lastIrWidth, lastIrHeight;
    long frameTime = -1, frameNum = 0;
    @Override
    public void onIrFrame(byte[] data, int width, int height) {
//        if (frameTime == -1) {
//            frameTime = System.currentTimeMillis();
//            frameNum = 0;
//        } else {
//            ULog.e(TAG, "onIrFrame === " + data.length + "  width " + width + "  height  " + height + " fps " + (frameNum/((System.currentTimeMillis() - frameTime)/1000.0)));
//        }
//        frameNum++;
        try {
            Recorder.irDataBack(data, width, height);
            if (isCorridorInspection) { //廊道巡检，防止画框
                inspectManager.nodeFrameNum = 10000;
                inspectManager.nodeBackFrameNum = 10000;
            }
            if (isPlay) {
                mActivity.setIrData(data);
            }
            if (irBuff[0] == null) {
                return;
            }
            boolean isRobotSupported =
                    mBotInfoMgr.getRobotMainType() == RobotMainType.LADYBUG || mBotInfoMgr.getRobotMainType() == RobotMainType.CICADA;

            if (isNeedCheckAruco) {
                isRobotSupported = false;
            }
            if (tempBitmap == null || lastIrWidth != width || lastIrHeight != height) {
                lastIrWidth = width;
                lastIrHeight = height;
                tempBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            }
            int timePosDiffX = 0, timePosDiffY = 0;
            boolean bitmapSetData = false;
            if (!isCorridorInspection && (mInfraredCameraIsShowArea && (inspectManager.getFrontChecking() || inspectManager.getBackChecking()))
                    && isRobotSupported) {
                long startTime = System.currentTimeMillis();
                tempBitmap.copyPixelsFromBuffer(ByteBuffer.wrap(data));
                irCanvas = new Canvas(tempBitmap);
                bitmapSetData = true;

                boolean visibleFront = inspectManager.getFrontChecking();
                boolean visibleBack = inspectManager.getBackChecking();

                Paint paint = new Paint();
                paint.setColor(Color.WHITE);
                paint.setTextAlign(Paint.Align.LEFT);
                paint.setAntiAlias(true); // 开下抗锯齿试试
                int irCameraNum = getRobot().getIrCameraNum();
                if (visibleFront && inspectManager.taskObjsFront.size() != 0) {
                    //callbackType 显示前面或全部时（非只显示后面），绘制前摄像头范围标定框
                    if (IRService.callbackType != 2) {
                        for (int i = 0; i < inspectManager.taskObjsFront.size(); i++) {
                            TaskObj taskObj = inspectManager.taskObjsFront.get(i);
                            if (!TextUtils.isEmpty(taskObj.getRect())) {
                                int[] t = UConstants.getRectArr(taskObj.getRect());
                                if (t.length > 1 && t.length == t[1] * 2 + 2) {
                                    float[] lines = new float[t[1] * 4];
                                    int index = 0;
                                    for (int j = 0; j < t.length; j += 2) {
                                        if (j == t.length - 2) {
                                            lines[index++] = t[2];
                                            lines[index] = t[3];
                                            break;
                                        }
                                        lines[index++] = t[j + 2];
                                        lines[index++] = t[j + 3];
                                        if (j > 0) {
                                            lines[index++] = t[j + 2];
                                            lines[index++] = t[j + 3];
                                        }
                                    }
                                    synchronized (irFrameLock) {
                                        ULog.d(TAG, "onIrFrame == lines = " + Arrays.toString(lines) + " t:  " + Arrays.toString(t) + " currentIRValue:" + currentIRValue.toString() + " node:" + (inspectManager.mCheckTargetNode == null ? "node_null" : inspectManager.mCheckTargetNode.getName()) + " obj:" + taskObj.getName());
                                        paint.setStyle(Paint.Style.STROKE);//不填充
                                        paint.setStrokeWidth(1);  //线的宽度
                                        irCanvas.drawLines(lines, paint);
                                        if (inspectManager.taskObjsFront.size() == currentIRValue.size() && inspectManager.taskObjsFront.size() == currentIRValueXy.size()) {
                                            //把框内高温点温度画到画面上
                                            paint.setTextSize(15f);
                                            paint.setStyle(Paint.Style.STROKE); // 设置为描边模式
                                            paint.setColor(Color.BLACK); // 描边文字颜色
                                            paint.setStrokeWidth(1); // 描边宽度
                                            irCanvas.drawText(Math.round(currentIRValue.get(i)) + "", currentIRValueXy.get(i)[0], currentIRValueXy.get(i)[1], paint);

                                            paint.setStyle(Paint.Style.FILL); // 设置为填充模式
                                            paint.setColor(Color.WHITE); // 填充文字颜色

                                            ULog.d(TAG, " front xy:" + Arrays.toString(currentIRValueXy.get(i)));
                                            //把温度画到框中间 画两次是为了有边框
                                            irCanvas.drawText(Math.round(currentIRValue.get(i)) + "", currentIRValueXy.get(i)[0], currentIRValueXy.get(i)[1], paint);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                if (visibleBack && inspectManager.taskObjsBack.size() != 0) {
                    //                boolean isSave = inspectManager.getSaveBack() && !nodeFrameBackSave;
                    //callbacktype 显示后面或全部时（非只显示前面），显示后摄像头区域标定框
                    if (irCameraNum > 1 && IRService.callbackType != 1) {
                        //后置摄像头绘制框横向坐标修正量
                        int posXFix = 0;
                        int oneFrameWidth = IRService.callbackType == 0 ? (width / irCameraNum) : (width);

                        //全部显示时，修正两个画幅宽偏移量
                        posXFix = IRService.callbackType == 0 ? oneFrameWidth * 2 : 0;

                        for (int i = 0; i < inspectManager.taskObjsBack.size(); i++) {
                            TaskObj taskObj = inspectManager.taskObjsBack.get(i);
                            if (!TextUtils.isEmpty(taskObj.getRect())) {
                                int[] t = UConstants.getRectArr(taskObj.getRect());

                                if (t.length > 1 && t.length == t[1] * 2 + 2) {
                                    float[] lines = new float[t[1] * 4];
                                    int index = 0;
                                    for (int j = 0; j < t.length; j += 2) {
                                        if (j == t.length - 2) {
                                            lines[index++] = t[2];
                                            lines[index] = t[3];
                                            break;
                                        }
                                        lines[index++] = t[j + 2];
                                        lines[index++] = t[j + 3];
                                        if (j > 0) {
                                            lines[index++] = t[j + 2];
                                            lines[index++] = t[j + 3];
                                        }
                                    }
                                    for (int k = 0; k < lines.length; k++) {
                                        if (k % 2 == 0) {
                                            lines[k] += posXFix;
                                        }
                                    }
                                    synchronized (irFrameBackLock) {
                                        ULog.d(TAG, "onIrFrame == lines back = " + Arrays.toString(lines) + " t:  " + Arrays.toString(t) + " currentIRValueBack:" + currentIRValueBack.toString() + " node:" + (inspectManager.mCheckTargetNodeBack == null ? "node_null" : inspectManager.mCheckTargetNodeBack.getName()) + " obj:" + taskObj.getName());
                                        paint.setStyle(Paint.Style.STROKE);//不填充
                                        paint.setStrokeWidth(1);  //线的宽度
                                        irCanvas.drawLines(lines, paint);
                                        if (inspectManager.taskObjsBack.size() == currentIRValueBackXy.size() && inspectManager.taskObjsBack.size() == currentIRValueBackXy.size()) {
                                            //把框内高温点温度画到画面上
                                            paint.setTextSize(15f);
                                            paint.setStyle(Paint.Style.STROKE); // 设置为描边模式
                                            paint.setColor(Color.BLACK); // 描边文字颜色
                                            paint.setStrokeWidth(1); // 描边宽度
                                            irCanvas.drawText(Math.round(currentIRValueBack.get(i)) + "", currentIRValueBackXy.get(i)[0], currentIRValueBackXy.get(i)[1], paint);

                                            paint.setStyle(Paint.Style.FILL); // 设置为填充模式
                                            paint.setColor(Color.WHITE); // 填充文字颜色

                                            ULog.d(TAG, " back xy:" + Arrays.toString(currentIRValueBackXy.get(i)));
                                            //把温度画到框中间 画两次是为了有边框
                                            irCanvas.drawText(Math.round(currentIRValueBack.get(i)) + "", currentIRValueBackXy.get(i)[0], currentIRValueBackXy.get(i)[1], paint);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                ULog.d(TAG, "nodeFrameNum convert bitmap == " + (System.currentTimeMillis() - startTime));
            }

            Paint paint = new Paint();
            paint.setColor(Color.WHITE);
            if (mBotInfoMgr.getRobotMainType() == RobotMainType.LADYBUG) {
                paint.setTextSize(30f);
                timePosDiffX = width - 300;
                timePosDiffY = 30;
            } else {
                paint.setTextSize(15f);
                timePosDiffX = width - 150;
                timePosDiffY = 15;
            }
            paint.setTextAlign(Paint.Align.LEFT);
            paint.setStyle(Paint.Style.FILL);
            paint.setStrokeWidth(0);  //线的宽度

            if (!bitmapSetData) {
                tempBitmap.copyPixelsFromBuffer(ByteBuffer.wrap(data));
                irCanvas = new Canvas(tempBitmap);
            }

            if(InspectManager.mCurrentTaskNode != null && InspectManager.mCurrentTaskNode.getName() != null){
                irCanvas.drawText(InspectManager.mCurrentTaskNode.getName() , 10, irCanvas.getHeight() - 10, paint);
            }
            if (MainApp.isShowIrTime) {
                irCanvas.drawText(sdfYMDHMS.format(new Date()), timePosDiffX, timePosDiffY, paint);
            }
            data = UImg.bitmapTobyte(tempBitmap);

            if (width != 0 && height != 0) {
                if (isIrException) {
                    ULog.d(TAG, "onIrFrame: 掉线检测 =====  ir恢复");
                    isIrException = false;
                }
                irBuffIndexTemp = (irBuffIndex + 1) % irBuff.length;
                if (irBuff[irBuffIndexTemp] != null && irBuff[irBuffIndexTemp].isReadyToFill) {
                    if (data.length == irBuff[irBuffIndexTemp].buff.length) {
                        System.arraycopy(data, 0, irBuff[irBuffIndexTemp].buff, 0, irBuff[irBuffIndexTemp].buff.length);
                        irBuffIndex = irBuffIndexTemp;
                        irBuff[irBuffIndexTemp].isReadyToFill = false;
                    }
                }
            }
            String irImg = irImgQueue.poll();
            if (!TextUtils.isEmpty(irImg)) {
                byte[] finalCloneFrame = new byte[data.length];
                System.arraycopy(data, 0, finalCloneFrame, 0, data.length);
                getExecutorService().execute(() -> {
                    Thread.currentThread().setName("alarm_ir_saveImg");
                    UImg.saveImg(UConstants.ALARM_PIC_DIR, irImg, irImg.substring(0, irImg.indexOf("_writing")) + ".jpg", finalCloneFrame, width, height);
                });
            }
            inspectManager.onIrFrame(data, width, height);
        } catch (Exception e) {
            ULog.d(TAG, "onIrFrameException e " + e.getMessage());
        }
    }

    private SimpleDateFormat sdfYMD = new SimpleDateFormat("YYYY-MM-dd");
    private SimpleDateFormat sdfYMDHMS = new SimpleDateFormat("YYYY-MM-dd HH:mm:ss");
    private ArrayBlockingQueue<String> irImgQueue = new ArrayBlockingQueue<String>(1000);
    //UConstants.ALARM_IR_PIC_DIR
    //报警图片
    public String getAlarmIrImgFileName(long time) {
        irImgQueue.offer(time + "_ir_writing.jpg");
        String filePath = time + "_ir.jpg";

        String timeStr = sdfYMD.format(new Date(time));
        String[] timeArr = timeStr.split("-");
        if (MainApp.uploadFileType == 0) {
            filePath = UConstants.UPLOAD_ALARM_PIC_FILE_DIR + MainApp.mRobot.getId() + "/" + timeArr[0] + "/" + timeArr[1] + "/" + timeArr[2] + "/" + filePath;
        } else {
            filePath = UConstants.UPLOAD_MINIO_ALARM_PIC_FILE_DIR + MainApp.mRobot.getId() + "/" + timeArr[0] + "/" + timeArr[1] + "/" + timeArr[2] + "/" + filePath;
        }
        return filePath;
    }
    private long lastAlarmRgbImgTime;
    public String getAlarmRgbImgFileName(long time) {
        //小于1.5秒 使用上次的图片
        if (time - lastAlarmRgbImgTime < 1500) {
            time = lastAlarmRgbImgTime;
        } else {
            alarmTakePhoto(time + "_rgb_writing.jpg");
        }
        lastAlarmRgbImgTime = time;
        String filePath = time + "_rgb.jpg";
        String timeStr = sdfYMD.format(new Date(time));
        String[] timeArr = timeStr.split("-");
        if (MainApp.uploadFileType == 0) {
            filePath = UConstants.UPLOAD_ALARM_PIC_FILE_DIR + MainApp.mRobot.getId() + "/" + timeArr[0] + "/" + timeArr[1] + "/" + timeArr[2] + "/" + filePath;
        } else {
            filePath = UConstants.UPLOAD_MINIO_ALARM_PIC_FILE_DIR + MainApp.mRobot.getId() + "/" + timeArr[0] + "/" + timeArr[1] + "/" + timeArr[2] + "/" + filePath;
        }
        return filePath;
    }
    private void alarmTakePhoto(String name) {
        WebCamManager.getInstance().takePhoto()
                .timeout(10, TimeUnit.SECONDS)
                .subscribeOn(Schedulers.io())
                .subscribe(new NextErrorObserver<ResponseBody>() {
                    @Override
                    public void onNext(@NonNull ResponseBody responseBody) {
                        ULog.d(TAG, "alarmTakePhoto takePhoto onTakePhotoSuccess:---");

                        byte[] bytes = new byte[0];
                        try {
                            bytes = responseBody.bytes();//response.body()只能调用用一次!
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                        UImg.saveImg(UConstants.ALARM_PIC_DIR, name, name.substring(0, name.indexOf("_writing")) + ".jpg", bytes);
                    }

                    @Override
                    public void onError(@NonNull Throwable e) {
                        ULog.d(TAG, "alarmTakePhoto onTakePhotoFailure:" + e.getMessage());
                    }
                });
    }


    //上传报警图片
    Thread uploadAlarmPicThread = new Thread(() -> {
        Thread.currentThread().setName("up_ala_pic");
        while(true) {
            File videoDir = new File(UConstants.ALARM_PIC_DIR);
            List<File> videoFiles = Arrays.stream(videoDir.listFiles()).sorted(Comparator.comparing(File::getName)).collect(Collectors.toList());;
            if (videoFiles.size() != 0) {
                for (File file : videoFiles) {
                    long fileTime = Long.parseLong(file.getName().substring(0, file.getName().indexOf("_")));
                    if (file.getName().contains("writing")) {
                        //超过20分 则删除文件
                        if (System.currentTimeMillis() - fileTime > 1200_000) {
                            file.delete();
                        }
                        continue;
                    }
                    String timeStr = sdfYMD.format(new Date(fileTime));
                    String[] timeArr = timeStr.split("-");
                    String subFilePath = "/" + timeArr[0] + "/" + timeArr[1] + "/" + timeArr[2];
                    boolean isSuccess = false;
                    while (!isSuccess) {
                        if (MainApp.uploadFileType == 0) {
                            int code = 0;
                            try {
                                code = UOss.getInstance(mActivity).uploadSync(UConstants.UPLOAD_ALARM_PIC_FILE_DIR + MainApp.mRobot.getId() + subFilePath + "/" + file.getName(), file.getAbsolutePath());
                            } catch (ClientException | ServiceException e) {
                                e.printStackTrace();
                            } finally {
                                ULog.d(TAG, "uploadAlarmPic: oss = code " + code + " fileName " + file.getName());
                            }
                            if (code == 200) {
                                isSuccess = true;
                                file.delete();
                            }
                        } else {
                            if (!UString.isEmpty(MainApp.mRobot.getMinioIp())) {
                                try {
                                    isSuccess = Minio.getInstance(MainApp.mRobot.getMinioIp()).uploadFile(file.getAbsolutePath(), UConstants.UPLOAD_MINIO_ALARM_PIC_FILE_DIR + MainApp.mRobot.getId() + subFilePath + "/" + file.getName());
                                } catch (Exception e) {
                                    e.printStackTrace();
                                } finally {
                                    ULog.d(TAG, "uploadAlarmPic: minio = isSuccess " + isSuccess + " fileName " + file.getName());
                                }
                                if (isSuccess) {
                                    file.delete();
                                }
                            }
                        }
                        if (!isSuccess) {
                            try {
                                Thread.sleep(5000);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                }
            }
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    });

    @Override
    public void onIrDataFront(float[] data, int width, int height) {
        inspectManager.nodeFrameNum = 1000;
        UExecutorService.getSpecialTPIrFront().execute(() -> {
            inspectManager.onIrDataFront(data, width, height);
        });
    }

    @Override
    public void onIrDataBack(float[] data, int width, int height) {
        inspectManager.nodeBackFrameNum = 1000;
        UExecutorService.getSpecialTPIrBack().execute(() -> {
            inspectManager.onIrDataBack(data, width, height);
        });
    }

    float startCheckPositionToHead, startCheckPositionToTail, stopCheckPositionToHead, stopCheckPositionToTail;

    @Override
    public void onTemperatureBack(float[] result,int[] resultXy, float[] resultScale, int[] typeIds, int[] objIds, float[] thresholds,
                                  int detectFrameNumBack) {
        if (result.length == 0) {
            //            ULog.e(TAG ,"temperature back data length 0 , the task obj rect data my has errors");
            return;
        }
        if (currentIRValueBack != null) {
            synchronized (irFrameBackLock) {
                currentIRValueBack.clear();
                currentIRValueScale.clear();
                currentIRValueBackXy.clear();
                for (int i = 0; i < result.length; i++) {
                    result[i] = ((float) (((int) (result[i] * 1000)) / 1000.0));
                    resultScale[i] = (float) (((int) (resultScale[i] * 1000)) / 1000.0);
                    currentIRValueBack.add(result[i]);
                    currentIRValueScale.add(resultScale[i]);
                    currentIRValueBackXy.add(new int[]{resultXy[i * 2], resultXy[i * 2 + 1]});
                }
            }
        }
        inspectManager.onTemperatureBack(result,resultXy, resultScale, typeIds, objIds, thresholds, detectFrameNumBack);
    }

    @Override
    public void onTemperatureFront(float[] result,int[] resultXy, float[] resultScale, int[] typeIds, int[] objIds, float[] thresholds,
                                   int detectFrameNum) {

        if (result.length == 0) {
            //            ULog.e(TAG ,"temperature front data length 0 , the task obj rect data may has errors");
            return;
        }
        if (mBotInfoMgr.getRobotActionCode() == RobotActionCode.STATUS_WAITING && mBotInfoMgr.getRobotActionReason() == RobotActionCode.Stop.IR_INIT_STOP) {
            ULog.d(TAG, "机器人等待状态恢复_红外初始化");
            mBotInfoMgr.setRobotActionCode(RobotActionCode.IDLE, null);
        }
        getRobot().setInfraredTemprature(result[0]);

        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_IR_CAMERA_DROP)) {
            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_IR_CAMERA_DROP_RESUME));
            setIsAlarmReported(AlarmTypeEnum.ROBOT_IR_CAMERA_DROP, false);
        }
        if (currentIRValue != null) {
            synchronized (irFrameLock) {
                currentIRValue.clear();
                currentIRObjIds.clear();
                currentIRValueScale.clear();
                currentIRValueXy.clear();
                for (int i = 0; i < result.length; i++) {
                    result[i] = ((float) (((int) (result[i] * 1000)) / 1000.0));
                    resultScale[i] = (float) (((int) (resultScale[i] * 1000)) / 1000.0);
                    currentIRValue.add(result[i]);
                    currentIRObjIds.add(objIds[i]);
                    currentIRValueScale.add(resultScale[i]);
                    currentIRValueXy.add(new int[]{resultXy[i * 2], resultXy[i * 2 + 1]});
                }
            }
        }
        if (result.length > 0) {
            String tepListStr = Arrays.toString(result);
            getRobot().setInfraredTempratureList(tepListStr.substring(1, tepListStr.length() - 1));
        }
        inspectManager.onTemperatureFront(result,resultXy, resultScale, typeIds, objIds, thresholds, detectFrameNum);

    }
    @Override
    public void onKeyTemperature(int index, float centerTemp, float highestTemp, float lowestTemp, float chipTemp) {
//        ULog.d(TAG, "火情报警 highestTemp " + highestTemp + " irFireDetect " + mBotInfoMgr.getRobotConfigParams().getIrFireDetect() + " fireAlarmConfigs " + gson.toJson(fireAlarmConfigs));

        float fireThreshold = getFireAlarmThreshold(mDistance);
        List<SensorData> fireAlarmDataList = mSensorsData.get("FIRE_ALARM");
        if (fireAlarmDataList == null || fireAlarmDataList.size() == 0) {
            fireAlarmDataList = new ArrayList<>();
            SensorData fireAlarmData = new SensorData();
            fireAlarmData.setValuesMap(new HashMap<>());
            fireAlarmDataList.add(fireAlarmData);
            mSensorsData.put("FIRE_ALARM", fireAlarmDataList);
        }
        fireAlarmDataList.get(0).getValuesMap().put("highest_temp", String.valueOf(highestTemp));
        fireAlarmDataList.get(0).getValuesMap().put("fire_threshold", String.valueOf(fireThreshold));
        fireAlarmDataList.get(0).getValuesMap().put("ir_fire_detect", String.valueOf(mBotInfoMgr.getRobotConfigParams().getIrFireDetect()));
        if (mBotInfoMgr.getRobotConfigParams().getIrFireDetect() != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }
        //mBotInfoMgr.getRobotConfigParams().getIrFireTempThreshold()
        if (Float.compare(highestTemp, fireThreshold) >= 0
                && (System.currentTimeMillis() - mLastIrFileAlarmTime > 3000)) {
            ULog.i(TAG, "火情报警；最高温度：" + highestTemp + ", ir index:" + index);
            mLastIrFileAlarmTime = System.currentTimeMillis();


            List<Float> vals = new ArrayList<>();
            vals.add(FormatUtils.keepDecimals(mDistance, 2));
            vals.add(FormatUtils.keepDecimals(highestTemp, 2));
            //mqtt广播通知下用户
//            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_IR_FIRE_ALARM,vals);
//            mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_ir_fire_alarm,vals.get(0),vals.get(1)));

            if (MainApp.isReclaimer) {
                //取料机火情报警通知服务器然后服务器mqtt通知现场另一个mqtt服务
                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.IR_EXCEED_THRESHOLD_EXCEPTION);
                List<String> params = new ArrayList<>();
                params.add(FormatUtils.keepDecimals(mDistance, 2) + "");
                params.add(String.valueOf(FormatUtils.keepDecimals(fireThreshold, 2)));
                params.add(String.valueOf(FormatUtils.keepDecimals(highestTemp, 2)));
                alertEvent.setParams(params);
                alertEvent.setSensorException(true);
                TSensorHistoryRecordException his = getSensorHisData();
                his.setTemperature(BigDecimal.valueOf(highestTemp)); //高温值覆盖环境温度值，管理平台端用于展示
                alertEvent.setSensorHis(his);
                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                RxBus.getInstance().post(alertEvent);
            } else {
                //非取料机火情报警
                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_IR_FIRE_DETECT);
                List<String> params = new ArrayList<>();
                params.add(getSensorAlarmFirstParam());
                params.add(String.valueOf(FormatUtils.keepDecimals(highestTemp, 2)));
                params.add(String.valueOf(fireThreshold));
                alertEvent.setParams(params);
                alertEvent.setSensorException(true);
                TSensorHistoryRecordException his = getSensorHisData();
                his.setTemperature(BigDecimal.valueOf(highestTemp)); //高温值覆盖环境温度值，管理平台端用于展示
                alertEvent.setSensorHis(his);
                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                long fireTime = System.currentTimeMillis();
                alertEvent.setPicIr(getAlarmIrImgFileName(fireTime));
                alertEvent.setPicRgb(getAlarmRgbImgFileName(fireTime));
                RxBus.getInstance().post(alertEvent);
            }
        }
    }

    @Override
    public void onFixPointT(float temp) {
        fT = temp;
        //        ULog.d(TAG, "run: 单次采样温度值 == " + fT);
    }

    private int rgbExceptionNum = 0, irExceptionNum = 0;
    private boolean isRgbException;
    private boolean isIrException;
    private boolean isCameraDrop;

    @Override
    public void onTemperatureException(String reason) {
        irExceptionNum++;
        if (irExceptionNum >= 10) {
            ULog.d(TAG, "onTemperatureException:  重启");
            //            PowerManager pm = (PowerManager) mActivity.getSystemService(Context.POWER_SERVICE);
            //            pm.reboot("");
            RxBus.getInstance().post(new DeviceEvent(DeviceEvent.ACTION_REBOOT_ANDROID, "RGB onTemperatureException"));
        }
        ULog.d(TAG, "onTemperatureException: 掉线检测 reason " + reason);
        if (MODE == MODE_INSPECTION) {
            isIrException = true;
            isCameraDrop = true;
            stmExecute.executeTaskNonQueue(new StmTask().stopMove("onTemperatureException 掉线检测 reason"+ reason +" 41"));

        }
        //红外设备掉线 报警
        if (addAlarmCount(AlarmTypeEnum.ROBOT_IR_CAMERA_DROP) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_IR_CAMERA_DROP)) {
            List<String> params = new ArrayList<String>();
            params.add(",原因:" + reason);
            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_IR_CAMERA_DROP, params));
            setIsAlarmReported(AlarmTypeEnum.ROBOT_IR_CAMERA_DROP, true);
        }
    }

    @Override
    public void onIrInit() {
        ULog.d(TAG, "onIrInit: 红外初始化 MODE = " + MODE);
        //自动建图模式红外初始化机器人不停止移动
        if (MODE != MODE_GOTO_CHARGER && MODE != MODE_AUTO_BUILD_MAP) {
            ULog.d(TAG, "onIrInit: 红外初始化 === 停止移动");
            if (mBotInfoMgr.getRobotActionCode() != RobotActionCode.STATUS_WAITING) {
                mBotInfoMgr.setRobotActionCode(RobotActionCode.STATUS_WAITING, RobotActionCode.Stop.IR_INIT_STOP);
            }
            stmExecute.executeTaskNonQueue(new StmTask().stopMove("红外初始化停止移动 42"));
        }
        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_IR_INIT);
        mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.ir_init));
    }

    @Override
    public void onRGBException() {
        ULog.d(TAG, "onRGBException: 掉线检测 ");
        rgbExceptionNum++;
        if (rgbExceptionNum >= 10) {
            ULog.d(TAG, "onRGBException:  重启");
            //            PowerManager pm = (PowerManager) mActivity.getSystemService(Context.POWER_SERVICE);
            //            pm.reboot("");
            RxBus.getInstance().post(new DeviceEvent(DeviceEvent.ACTION_REBOOT_ANDROID, "rgb exception"));
        }
        if (MODE == MODE_INSPECTION) {
            isRgbException = true;
            isCameraDrop = true;
            stmExecute.executeTaskNonQueue(new StmTask().stopMove("onRGBException 43"));
        }
    }

    @Override
    public void onRgbFrame(byte[] data, int width, int height) {
        //        ULog.e(TAG, "onRgbFrame === " + data.length + " isPushing: " + "  width " + width + "  height  " + height);
        if (rgbBuff[0] == null) {
            return;
        }
        if (width != 0 && height != 0) {
            if (isRgbException) {
                ULog.d(TAG, "onRgbFrame:  ===== 掉线检测 rgb恢复");
                isRgbException = false;
            }

            rgbBuffIndexTemp = (rgbBuffIndex + 1) % rgbBuff.length;
            if (rgbBuff[rgbBuffIndexTemp] != null && rgbBuff[rgbBuffIndexTemp].isReadyToFill) {
                System.arraycopy(data, 0, rgbBuff[rgbBuffIndexTemp].buff, 0, rgbBuff[rgbBuffIndexTemp].buff.length);
                rgbBuffIndex = rgbBuffIndexTemp;
                rgbBuff[rgbBuffIndexTemp].isReadyToFill = false;
            }
        }
    }


    //**********************WIFIStateCallback********************************

    private int currentRssiLevel = 80;
    private int strongestRssiLevel = 80;
    private String currentBssidName = "";
    private String strongestBssidName = "";
    private volatile boolean isReConnect = false;

    @Override
    public void onConnectSuccess(int currentRssi, String currentBssid, int strongestRssi, String strongestBssid) {
//        String rePushUrl = "httpurl " + UrlManager.getBaseUrl() + "/srs/kickoff/" + robotId;
//        String rePushUrl = UrlManager.getBaseUrl() + "/srs/kickoff/" + robotId;
        ULog.e(TAG,  "wifi onConnectSuccess === 连接成功 , 当前信号：" + currentRssi + ",当前信号源：" + currentBssid + ", 最强信号：" + strongestRssi + ",最强信号源：" + strongestBssid);
        currentRssiLevel = currentRssi;
        strongestRssiLevel = strongestRssi;
        currentBssidName = currentBssid;
        strongestBssidName = strongestBssid;

//        URootCmd.execRootCmdSilent(rePushUrl);
//        UOKHttp.get(rePushUrl, new Callback() {
//            @Override
//            public void onFailure(@androidx.annotation.NonNull Call call, @androidx.annotation.NonNull IOException e) {
//                ULog.d(TAG, "onConnectSuccess delPusher onFailure " + e.getMessage());
//            }
//
//            @Override
//            public void onResponse(@androidx.annotation.NonNull Call call, @androidx.annotation.NonNull Response response) throws IOException {
//                ULog.d(TAG, "onConnectSuccess delPusher onResponse " + response.toString());
//            }
//        });
        //重连之后
        if (isReConnect) {
            if (!mHandler.hasMessages(Msg.WHAT_NET_CONNECT_SUCCESS)) {
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_NET_CONNECT_SUCCESS, 1000);
            }
            RxBus.getInstance().post(new RobotHeartEvent(RobotEventConstants.EVENT_SEND_CONNECT_TEST));

            //如果是巡检或回充 继续运行  //此次不要主动调用，等移动检测去触发继续任务
            //            if (MODE == MODE_INSPECTION) {
            //                continueInspection(robotDirection);
            ////                stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate));
            //            }
            //            if (MODE == MODE_GOTO_CHARGER && !inCharger()) {
            //                gotoChargerCheck();
            //            }
            //重置isReConnect防止多次调用
            isReConnect = false;
            mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.ap_connect_success));
        }
    }

    @Override
    public void onReConnect(int currentRssi, String currentBssid, int strongestRssi, String strongestBssid) {
        ULog.e(TAG,
                "wifi onReConnect === 重连网络,  当前信号：" + currentRssi + ",当前信号源：" + currentBssid + ", 最强信号：" + strongestRssi + ",最强信号源：" + strongestBssid);
        currentRssiLevel = currentRssi;
        strongestRssiLevel = strongestRssi;
        currentBssidName = currentBssid;
        strongestBssidName = strongestBssid;
        //正在重连 机器人停止
        isReConnect = true;
        if (!mHandler.hasMessages(Msg.WHAT_NET_CONNECT_SUCCESS)) {
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_NET_CONNECT_SUCCESS, 1000);
        }
/*
        if (isOfflineLocation(mDistance)) {

        } else {
            //自动建图模式重连网络不停止移动
            if (MODE != MODE_AUTO_BUILD_MAP) {
                stmExecute.executeTaskNonQueue(new StmTask().stopMove());
            }
            broadcastMobileShowInfo(mRes.getString(fun.unifun.library.android.R.string.ap_reconnect));
        }*/
    }

    @Override
    public void onConnectFail(int currentRssi, String currentBssid) {
        currentRssiLevel = currentRssi;
        currentBssidName = currentBssid;
        ULog.e(TAG, "wifi onConnectFail === 连接失败 , 当前信号：" + currentRssi + ",当前信号源：" + currentBssid);
        isReConnect = false;
        RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_6));
    }

    @Override
    public void onSameSSIDResult(List<ScanResult> scanResultList) {
        //        for (ScanResult scanResult : scanResultList) {
        //            ULog.e(TAG, "AP === 返回数据  scanResultList.size() = " + scanResultList.size() + ", scanRssi: " + scanResult.level + " scanBssid: " + scanResult.BSSID + "  scanSSID: " + scanResult.SSID);
        //        }
    }


    class SaveTemperatureThread implements Runnable {

        @Override
        public void run() {
            Thread.currentThread().setName("SaveTemperatureThread");
            isStopSave = false;
            while (true) {
                //                if (inCharger()) {
                UFile.saveTemp(fT + " " + environmentalTemperature + " " + (isBeltConveyorStart ? "1" : "0") + " " + (inCharger() ? "1" : "0"));
                //                }
                ULog.d(TAG, "run: isBeltConveyorStart==  " + isBeltConveyorStart);
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                if (isStopSave) {
                    return;
                }
            }
        }
    }

    boolean isSendMobNoInspection;

    /**
     * 是否是自动巡检
     */
    private boolean isAutoInspection() {
        //排班巡检不触发自动巡检  && 取料机巡检不触发自动巡检
        return MainApp.isAutoInspection(getRobot().getChargeStrategy());
    }

    class InspectionEnable extends Thread {


        public InspectionEnable() {
            this("InspectionEnable");
        }

        private InspectionEnable(String name) {
            super(name);
        }

        @Override
        public void run() {
            while (inCharger() && isAutoInspection()) {
                MainApp.bEnable = false;
                ULog.d(TAG,
                        "run:  采样 开始检测 isBeltConveyorStart = " + isBeltConveyorStart + " inCharger = " + inCharger() + " 电量 " + getRobot().getPowerPercent());
                isSendMobNoInspection = false;
                start:
                while (true) {
                    while (!isBeltConveyorStart || isSleep || isSoftEmergencyStop) {
                        if (!inCharger() || !isAutoInspection()) {
                            return;
                        }
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    while (true) {
                        if (!isBeltConveyorStart || isSleep || isSoftEmergencyStop) {
                            break start;
                        }
                        int powerThreshold = 50;
                        if (getRobot().getInspectionPowerThreshold() != null) {
                            powerThreshold = getRobot().getInspectionPowerThreshold();
                        }
                        //                    float mileageThreshold = 2000;
                        //                    if (getRobot().getInspectionMileageThreshold() != null)
                        //                        mileageThreshold = getRobot().getInspectionMileageThreshold();
                        //                    if (getRobot().getAvailableMileage() == null) continue;
                        //if (getRobot().getAvailableMileage() < mileageThreshold) {
                        if (getRobot().getPowerPercent() < powerThreshold) {
                            if (!isSendMobNoInspection) {
                                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_POWER_LOW_CANNOT_START_AUTOMATIC_INSPECTION);
                                mMqttManager.broadcastShowInfo("当前电量不足，无法开始自动巡检");

                                isSendMobNoInspection = true;
                            }
                            try {
                                Thread.sleep(5000);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        } else {
                            break;
                        }
                        //电量阈值判断
                        //                    if (getRobot().getPowerPercent() < powerThreshold) {
                        //                        if (!isSendMobNoInspection) {
                        //                            sendMobileInfo("当前电量太低，无法开始巡检");
                        //                            isSendMobNoInspection = true;
                        //                        }
                        //                        try {
                        //                            Thread.sleep(1000);
                        //                        } catch (InterruptedException e) {
                        //                            e.printStackTrace();
                        //                        }
                        //                    } else {
                        //                        break;
                        //                    }
                    }
                    runTime = System.currentTimeMillis();
                    ctimes = 0;
                    pfTArr = new float[meanLen]; //采样温度序列，长度为meanLen的数组
                    while (!MainApp.bEnable) {
                        if (!isBeltConveyorStart || isSleep || isSoftEmergencyStop) {
                            break start;
                        }
                        nSample++;
                        //采样数求余
                        if (meanLen != 0 && fT != -10000) {
                            int sampRem = nSample % meanLen;
                            ULog.d(TAG, "run:  == 采样 sample = " + nSample + " meanLen = " + meanLen + " rem = " + sampRem);
                            if (sampRem != 0) {
                                pfTArr[sampRem - 1] = fT;
                            } else {
                                nSample = 0;
                                pfTArr[meanLen - 1] = fT;
                                //求采样序列斜率
                                fSlope = VideoUtils.GetTemperatureSlope(pfTArr, meanLen);
                                ULog.d(TAG,
                                        "run: 采样序列斜率 == " + fSlope + " 阈值 = " + thresh + " ctimes = " + ctimes + " ctime阈值 = " + ctimesThresh);
                                if (Math.abs(fSlope) <= thresh) {
                                    ctimes++;
                                } else {
                                    ctimes = 0;
                                }
                                if (ctimes == ctimesThresh) {
                                    MainApp.bEnable = true;
                                }
                            }
                        }
                        ULog.d(TAG, "InspectionEnable sleep " + deltT);
                        //等待一定时间再采样
                        try {
                            Thread.sleep(deltT);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        //判断趋势计算处理时长是否超过等待时长
                        //                runTime++;
                        float timeOut = (float) ((System.currentTimeMillis() - runTime) / 1000.0);


                        ULog.d(TAG, "run:  采样 sample = ===== 超时时间 = " + timeOut + "  阈值 = " + maxRunTime);
                        if (timeOut >= maxRunTime) {
                            MainApp.bEnable = true;
                        }
                    }

                    if (Thread.currentThread().isInterrupted()) {
                        ULog.d(TAG, "皮带机已关闭，终止");
                        return;
                    }
                    ULog.d(TAG, "温度采样满足条件, bEnable:" + MainApp.bEnable);
                    if (MainApp.bEnable) {
                        UPreferences.putInt(mActivity, UConstants.PREFERENCES_FORCE_INSPECTION_KEY, 0);
                        if (getRobot() != null && getRobot().getCleanException() && mSegment != null && mSegment.getMapId() != null) {
                            UpdateAllExceptionByMapId request = new UpdateAllExceptionByMapId();
                            request.setMapId(mSegment.getMapId());
                            request.setException(0);
                            UOKHttp.post(UrlManager.getBaseUrl(),
                                    request,
                                    new UOKHttp.RequestCallBack<UpdateAllExceptionByMapId>(UpdateAllExceptionByMapId.class) {
                                        @Override
                                        public void onFailure(Call call, IOException e) {
                                            ULog.d(TAG, "onFailure:  === UpdateAllExceptionByMapId");
                                        }

                                        @Override
                                        public void onResponseOk(Call call, UpdateAllExceptionByMapId o) {
                                            ULog.d(TAG, "onResponseOk:  === UpdateAllExceptionByMapId");
                                        }

                                        @Override
                                        public void onResponseError(Call call, int i, String s) {
                                            ULog.d(TAG, "onResponseError: == UpdateAllExceptionByMapId");
                                        }
                                    });
                        }
                        if (MODE != MODE_INSPECTION && isAutoInspection()) {
                            ULog.d(TAG, "InspectionEnable 向充电桩确认皮带机是否开启... 网络状态 " + serverHeartNormal);
                            //2021年4月30日 17:09:00 改成机器人如果巡检模式是'皮带机运转' 机器人巡检前再次向充电桩确认皮带机是否开启否则不出去巡检
                            if (isBeltConveyorStart && inCharger() && serverHeartNormal) {
                                startInspection("InspectionEnable");
                                return;
                            }
                        }
                        try {
                            ULog.d(TAG, "延迟30s再次判断");
                            Thread.sleep(30 * 1000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        break;
                    }
                }

            }

        }
    }

    boolean frameLossTest = false;

    long moveTime;

    public void robotMove(int direction) {
        if (robotDirection == direction && (System.currentTimeMillis() - moveTime) < 5000) {
            return;
        }
        moveTime = System.currentTimeMillis();
        setRobotDirection(direction,"10");
        stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
    }


    private float getRealSpeed(double rate) {

        if (rfidReadType == 0 || rfidReadType == 1) {
            return (float) (rate * 1.0 / UConstants.MOTOR_REDUCTION_RATIO / 2 * UConstants.DISTANCE_TWO_ROUND / 60);
        } else if (rfidReadType == 2 || rfidReadType == 3) {
            return (float) rate;
        }
        return 0;
    }

    private void initFileDir() {
        URootCmd.execRootCmdSilent("rm -r /sdcard/aliyun_log");
        File irFile = new File(UConstants.IR_FILE_DIR);
        if (!irFile.exists()) {
            irFile.mkdirs();//创建文件夹
        } else {
            File[] irFiles = irFile.listFiles();
            if (irFiles != null && irFiles.length != 0) {
                for (File file : irFiles) {
                    file.delete();
                }
            }
        }
        String sdPath = UFileUtils.getExternalSdcardPath(mActivity);
        if (!TextUtils.isEmpty(sdPath)) {
            UConstants.ROLLER_FILE_DIR = sdPath + "/roller_record/";
        }
        File rollerFile = new File(UConstants.ROLLER_FILE_DIR);
        if (!rollerFile.exists()) {
            rollerFile.mkdirs();//创建文件夹
        }
        File alarmIrFile = new File(UConstants.ALARM_PIC_DIR);
        if (!alarmIrFile.exists()) {
            alarmIrFile.mkdirs();//创建文件夹
        }
        File videoFragmentDir = new File(UConstants.VIDEO_FRAGMENT_FILE_DIR);
        if (!videoFragmentDir.exists()) {
            videoFragmentDir.mkdirs();//创建文件夹
        }
        File videoIrFragmentDir = new File(UConstants.VIDEO_IR_FRAGMENT_FILE_DIR);
        if (!videoIrFragmentDir.exists()) {
            videoIrFragmentDir.mkdirs();//创建文件夹
        }
        File audioFile = new File(UConstants.AUDIO_FILE_DIR);
        if (!audioFile.exists()) {
            audioFile.mkdirs();//创建文件夹
        } else {
            File[] audioFiles = audioFile.listFiles();
            if (audioFiles != null && audioFiles.length != 0) {
                for (File file : audioFiles) {
                    file.delete();
                }
            }
        }
        File audioPCMFile = new File(UConstants.AUDIO_PCM_FILE_DIR);
        if (!audioPCMFile.exists()) {
            audioPCMFile.mkdirs();//创建文件夹
        } else {
            File[] audioPcmFiles = audioPCMFile.listFiles();
            if (audioPcmFiles != null && audioPcmFiles.length != 0) {
                for (File file : audioPcmFiles) {
                    file.delete();
                }
            }
        }

        File videoCutDir = new File(UConstants.DIR_VIDEO_CUT);
        if (!videoCutDir.exists()) {
            videoCutDir.mkdirs();
        } else {
            File[] vfiles = videoCutDir.listFiles();
            if (vfiles != null && vfiles.length > 0) {
                for (File f : vfiles) {
                    f.delete();
                }
            }
        }

        /**
         * 拉流截帧
         */
        File daniuliveImage = new File(UConstants.DANIU_IMG_SAVE);
        if (!daniuliveImage.exists()) {
            daniuliveImage.mkdirs();
        }

        /**
         * yoloV7obb
         */
        File yoloV7ObbParam = new File(UConstants.YOLO_V7_OBB);
        if (!yoloV7ObbParam.exists()) {
            yoloV7ObbParam.mkdirs();
        }
    }

    private boolean isOfflineLocation(float distance) {
        for (int i = 0; i < offlineLocations.size(); i++) {
            if (distance >= offlineLocations.get(i).getStart() && distance <= offlineLocations.get(i).getEnd()) {
                return true;
            }
        }
        return false;
    }
    private float getFireAlarmThreshold(float distance) {
        for (int i = 0; i < fireAlarmConfigs.size(); i++) {
            if (distance >= fireAlarmConfigs.get(i).getStart() && distance < fireAlarmConfigs.get(i).getEnd()) {
                return fireAlarmConfigs.get(i).getThreshold();
            }
        }
        return 160;
    }

    /**************************SerialPort callBack*****************************/

    boolean inspectionIsStop = false;
    private Map<Integer, Float> nodeDistances = new LinkedHashMap<>();//自动建图 实体rfid标签 的 里程记录
    //private Set<MapNode> updateDistanceFailRfidNodes = new ArraySet<>();//更新 实体rfid标签的里程属性失败的 记录

    /**
     * 拍照
     *
     * @param type 0 普通拍照并保存图片  --1创建需要识别Aruco码的任务节点--  2创建不需要检测Aruco码的任务节点 需要传入taskNode及要返回消息的mqttSource
     */
    private void takePhoto(int type, TaskNode taskNode, String mqttSource) {
        WebCamManager.getInstance().takePhoto()
                .timeout(5,TimeUnit.SECONDS)
                .subscribeOn(Schedulers.io())
                .subscribe(new NextErrorObserver<ResponseBody>() {
                    @Override
                    public void onNext(@NonNull ResponseBody responseBody) {
                        ULog.d(TAG, "takePhoto onTakePhotoSuccess:---");

                        byte[] bytes = new byte[0];
                        try {
                            bytes = responseBody.bytes();//response.body()只能调用用一次!
                        } catch (IOException e) {
                            e.printStackTrace();
                        }

                        if (type == 0) {
                            //普通拍照 上传rgb及ir图像
                            byte[] finalBytes = bytes;

                            //获取系统的日期
                            Calendar calendar = Calendar.getInstance();
                            //年
                            int year = calendar.get(Calendar.YEAR);
                            //月
                            int month = calendar.get(Calendar.MONTH) + 1;
                            //日
                            int day = calendar.get(Calendar.DAY_OF_MONTH);
                            String dayStr = year + "_" + month + "_" + day;

                            WebCamManager.getInstance()
                                    .getZoomAndFocus()
                                    .subscribe(new NextErrorObserver<Map<String, Float>>() {
                                        @Override
                                        public void onNext(@NonNull Map<String, Float> resultMap) {
                                            Date date = new Date(System.currentTimeMillis());
                                            StringBuffer name = new StringBuffer();
                                            name.append(dateFormat.format(date));
                                            name.append("H").append(SteerController.getInstance().getCurHAngle());//水平舵机角度
                                            name.append("V").append(SteerController.getInstance().getCurVAngle());//垂直舵机角度
                                            name.append("F").append(resultMap.get("focus_pos"));//网络摄像头焦距
                                            name.append("Z").append(resultMap.get("zoom_pos"));//网络摄像头倍数
                                            name.append("v").append(getRobot().getSpeed());//机器人速度
                                            name.append("D").append(robotDirection);//机器人方向
                                            name.append("M").append(mDistance);//实时里程
                                            name.append(".jpg");


                                            //String nodeStr = autoMoveManager.mCurrentNode == null ? "无节点ID" : (autoMoveManager.mCurrentNode.getId() == null ? "无节点ID" : autoMoveManager.mCurrentNode.getId() + "");
                                            String serverFileName = UConstants.TAKE_PHOTO_DIR + robotId + "/" + dayStr + "/" /*+ nodeStr + "/"*/ + name.toString();
                                            if (MainApp.uploadFileType == 0) {
                                                int i1 = UOss.getInstance(mActivity).upLoadByteArr(serverFileName, finalBytes);
                                                if (i1 == 200) {
                                                    ULog.d("takePhoto rgb", " :图片文上传至云端成功!");
                                                    sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "RGB图片上传至云端成功!");
                                                } else {
                                                    ULog.d("takePhoto rgb", " :i=" + i1);
                                                    sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "RGB图片上传至云端失败!");
                                                }
                                            } else {
                                                HashMap<String, String> headerMap = new HashMap<>();
                                                headerMap.put("contentType", "image/png");
                                                Minio.getInstance(getRobot().getMinioIp()).upload2(serverFileName, finalBytes, headerMap, new Minio.RequestCallBack() {
                                                    @Override
                                                    public void onSuccess() {
                                                        ULog.d("takePhoto rgb", "拍照上传MinIO成功");
                                                        sendMqtt(getRobot().getId(),
                                                                mqttSource,
                                                                ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE,
                                                                ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION,
                                                                "RGB图片上传至云端成功!");
                                                    }

                                                    @Override
                                                    public void onFail() {
                                                        ULog.d("takePhoto rgb", "拍照上传MinIO失败");
                                                        sendMqtt(getRobot().getId(),
                                                                mqttSource,
                                                                ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE,
                                                                ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION,
                                                                "RGB图片上传至云端失败!");
                                                    }
                                                });

                                            }
                                        }

                                        @Override
                                        public void onError(@NonNull Throwable e) {
                                            sendMqtt(getRobot().getId(),
                                                    mqttSource,
                                                    ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE,
                                                    ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION,
                                                    "拍照前获取焦距失败!");
                                        }
                                    });

                            //红外图片
                            byte[] irData = Recorder.imageDate;
                            int irWidth = Recorder.mWidth;
                            int irHeight = Recorder.mHeight;
                            if(irData != null && irWidth != 0 && irHeight != 0){
                                Date date = new Date(System.currentTimeMillis());
                                StringBuffer name = new StringBuffer();
                                name.append(dateFormat.format(date));
                                name.append("H").append(SteerController.getInstance().getCurHAngle());//水平舵机角度
                                name.append("V").append(SteerController.getInstance().getCurVAngle());//垂直舵机角度
                                name.append("v").append(getRobot().getSpeed());//机器人速度
                                name.append("D").append(robotDirection);//机器人方向
                                name.append("M").append(mDistance);//实时里程
                                name.append("_IR");
                                name.append(".jpg");

                                ULog.d(TAG, "takePhoto" + " :保存红外图像");
                                //需要上传红外记录
                                String irServerFileName = UConstants.TAKE_PHOTO_DIR + robotId + "/" + dayStr + "/" + name.toString();
                                ULog.d(TAG, "takePhoto" + " :保存红外图像地址=" + irServerFileName);
                                if (irData != null) {
                                    try{
                                        Bitmap tempBitmap = Bitmap.createBitmap(irWidth, irHeight, Bitmap.Config.ARGB_8888);
                                        tempBitmap.copyPixelsFromBuffer(ByteBuffer.wrap(irData));
                                        int irBytes = tempBitmap.getByteCount();
                                        ByteBuffer buffer = ByteBuffer.allocate(irBytes);
                                        tempBitmap.copyPixelsToBuffer(buffer);
                                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
                                        tempBitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
                                        byte[] data = baos.toByteArray();
                                        tempBitmap.recycle();
                                        if(MainApp.uploadFileType == 0){
                                           int i2 = UOss.getInstance(MainApp.getInstance()).upLoadByteArr(irServerFileName, data);
                                            if (i2 == 200) {
                                                ULog.d("takePhoto ir", " :图片文上传至云端成功!");
                                                sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "IR图片上传至云端成功!");
                                            } else {
                                                ULog.d("takePhoto ir", " :i=" + i2);
                                                sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "IR图片上传至云端失败!");
                                            }
                                        }else{
                                            HashMap<String, String> headerMap1 = new HashMap<>();
                                            headerMap1.put("contentType", "image/png");
                                            Minio.getInstance(getRobot().getMinioIp()).upload2(irServerFileName, data, headerMap1, new Minio.RequestCallBack() {
                                                @Override
                                                public void onSuccess() {
                                                    ULog.d(TAG, "takePhoto:保存红外图像 onSuccess");
                                                    sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "IR图片上传至云端成功!");
                                                }

                                                @Override
                                                public void onFail() {
                                                    ULog.d(TAG, "takePhoto:保存红外图像 onFail");
                                                    sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "IR图片上传至云端失败!");
                                                }
                                            });
                                        }
                                    }catch (Exception e){
                                        ULog.e(TAG, "takePhoto" +  " :保存红外图像"+e);
                                        sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "IR图片保存失败!");
                                        e.printStackTrace();
                                    }

                                }

                            }else{
                                ULog.e(TAG, "takePhoto :IR图片获取失败!");
                                sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "IR图片获取失败!");
                            }
                        } else if (type == 2) {
                            //创建任务节点 不需要检测Aruco码
                            createTaskNode(taskNode, mqttSource, bytes, 1);
                        }

                    }

                    @Override
                    public void onError(@NonNull Throwable e) {
                        ULog.d(TAG, "onTakePhotoFailure:" + e.getMessage());
                        if(type == 2){
                            sendMqtt(robotId, mqttSource, MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE, MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION, "拍照失败!");
                        }else if(type == 0){
                            sendMqtt(getRobot().getId(), mqttSource, ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE, ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION, "拍照失败!");
                        }else if(type == 1){
                            sendMqtt(robotId, checkArucoAccount, MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE, MqttCommand.ROBOT_CHECK_ONE_FRAME_ARUCO_ACTION, "拍照失败!");
                        }

                    }
                });
    }
    /*---------------------------------------------------------------*/
    // TODO: 2020/2/12 0012 LORA CallBack

    @Override
    public void onLoraSendTask(LoraTask task) {
        ULog.d(TAG, "onLoraSendTask === " + task);
    }

    @Override
    public void onLoraSendData(byte[] data) {
        ULog.d(TAG, "onLoraSendData === " + UByte.print(data, data.length) + ",data.length = " + data.length);
    }

    @Override
    public void onLoraReceiveData(byte[] data) {
        ULog.d(TAG, "onLoraReceiveData === " + UByte.print(data, data.length));
        if (data != null && data.length > 0) {
            int cmdOrder = data[0] & 255;
            ULog.d(TAG, "onLoraReceiveData cmdOrder === " + cmdOrder);
            switch (cmdOrder) {
                case LoraTask.ROBOT_MANAGER_OPEN_CHARGE_ACTION:
                    if (data.length > 1 && ((data[1] & 255) == LoraTask.ROBOT_RESULT_SUCCESS_VALUE)) {
                        openChargeSuccess();
                        ULog.d(TAG, "onLoraReceiveData:  == 开始充电 成功");
                    }
                    break;
                case LoraTask.ROBOT_MANAGER_CLOSE_CHARGE_ACTION:
                    if (data.length > 1 && ((data[1] & 255) == LoraTask.ROBOT_RESULT_SUCCESS_VALUE)) {
                        closeChargeSuccess();
                        ULog.d(TAG, "onLoraReceiveData:  == 结束充电 成功");
                    }
                    break;
                case LoraTask.ROBOT_BELT_CONVEYOR_START:
                    ULog.d(TAG, "onLoraReceiveData:  ==== 皮带机开始运转");
                    if (getRobot() != null && getRobot().getChargeStrategy() != null) {
                        beltConveyorStart();
                        //回复充电桩收到皮带机开启消息
                        loraTaskExecute.executeTask(new LoraTask().resultSuccess(LoraTask.ROBOT_BELT_CONVEYOR_START));
                    }
                    break;

                case LoraTask.ROBOT_BELT_CONVEYOR_STOP:
                    ULog.d(TAG, "onLoraReceiveData:  ==== 皮带机停止运转");
                    if (getRobot() != null && getRobot().getChargeStrategy() != null) {
                        beltConveyorStop();

                        //回复充电桩收到皮带机停止消息
                        loraTaskExecute.executeTask(new LoraTask().resultSuccess(LoraTask.ROBOT_BELT_CONVEYOR_STOP));
                    }
                    break;

                case LoraTask.ROBOT_ENVIRONMENTAL_TEMPERATURE:
                    ULog.d(TAG, "onLoraReceiveData:  ==== 收到充电桩消息，外部环境温度");
                    if (data.length > 4) {
                        environmentalTemperature = Float.intBitsToFloat((data[1] & 255) << 24 | (data[2] & 255) << 16 | (data[3] & 255) << 8 | (data[4] & 255));
                        ULog.d(TAG,"environmentalTemperature update 2 :"+environmentalTemperature);
                        ULog.d(TAG, "onLoraReceiveData:  ==== environmentalTemperature = " + environmentalTemperature);
                        if (environmentalTemperature != UConstants.UNKONW && environmentalTemperature != 0 && environmentalTemperature > -40 && environmentalTemperature < 100) {
                            setAirTmp(environmentalTemperature);
                        }
                    }
                    break;
                case LoraTask.ROBOT_MANAGER_OPEN_DUSTING_ACTION:
                    if (data.length > 1 && ((data[1] & 255) == LoraTask.ROBOT_RESULT_SUCCESS_VALUE)) {
                        startDustingSuccess();
                        ULog.d(TAG, "onLoraReceiveData:  == 开始除尘 成功");
                    }
                    break;
                case LoraTask.ROBOT_MANAGER_DUSTING_FINISH_ACTION:
                    endDustingSuccess();
                    ULog.d(TAG, "onLoraReceiveData:  == 除尘 完成");
                    break;
                case LoraTask.ROBOT_MANAGER_CLOSE_DUSTING_ACTION:
                    if (data.length > 1 && ((data[1] & 255) == LoraTask.ROBOT_RESULT_SUCCESS_VALUE)) {
                        endDustingSuccess();
                        ULog.d(TAG, "onLoraReceiveData:  == 结束除尘 成功");
                    }
                    break;
                default:
                    break;
            }
        }
    }

    /*---------------------------------------------------------------*/
    // TODO: 2019/4/17  STM CallBack
    @Override
    public void onStmSendData(byte[] data) {
        super.onStmSendData(data);
        ULog.d(TAG, "onStmSendData : " + UByte.print(data, data.length));
        if (data.length >= 13) {
            if ((data[12] & 255) == StmTask.READ_MOTOR_INFO) {
                synchronized (heartLock) {
                    readHeartNum++;
                    readSerialNum++;
                }
            }
        }
    }

    double robotOutsideTemperature, robotTemperature;
    int emergencyStopButtonLast = -1, temperatureSensorState = -1, chargingRelayState = -1, mileageRegState = -1;


    private SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS");

    @Override
    public void onStmReceiveData(byte[] data) {
        super.onStmReceiveData(data);

        if (getRobot() == null || mRobotType == null) {
            return;
        }

        if (data.length < 100) {
            //防止传输下位机日志时，打印过多数据
            ULog.d(TAG, "onStmReceiveData : " + UByte.print(data, data.length));
        }

        int cmdStart = data[0] & 255;
        int cmdOrder = data[1] & 255;
        int regAddress, position;

        if (cmdStart == StmTask.DEVICE_ADDRESS) {
            switch (cmdOrder) {
                case StmTask.STOP_MOVE: {
                    if (mAudioManager != null && mAudioManager.isWriteFile) {
                        mAudioManager.stopRecordingFile();
                    }
                    //                    SpeedDetector.getInstance().setStopMove(true);
                }
                break;

                case StmTask.RFID_COMMAND: {
                    position = 2;
                    int operation = data[position] & 0x0F;
                    int status = (data[position++] >> 7) & 1;
                    int num = (data[position++] & 255) << 8 | data[position++] & 255;
                    int distanceMM = (data[position++] & 255) << 24 | (data[position++] & 255) << 16 | (data[position++] & 255) << 8 | data[position++] & 255;
                    String epc = UByte.bytesToHexString(data, position, position + 11);
                    ULog.d(TAG,
                            "RFID onStm_RFID 操作码_" + Integer.toHexString(operation)
                                    .toUpperCase() + "_状态_" + status + "_序号_" + num + "_里程_" + distanceMM + "_EPC_" + epc);
                    switch (operation) {
                        case StmTask.RFID_OPERATION_DEL: //删除数据
                            ULog.d(TAG, "清空下位机rfid数据 stm_rfid 状态 " + status);
                            cleanStmRfids = status == 1;
                            if (status == 1) {
                                if (isDeleteRfidMap) { //是否在执行主动删除地图
                                    isDeleteRfidMap = false;
                                    writeStmRfids.clear();
                                }
                                StorageCenter.getRobotStorage().putString(StorageCenter.KEY_RFID_NODE, "[]");
                                StorageCenter.getRobotStorage().saveAsync();
                                writeRfidInterrupt = true;
                                getExecutorService().execute(new Runnable() {
                                    @Override
                                    public void run() {
                                        Thread.currentThread().setName("rfid_write_stm");
                                        writeRfidInterrupt = false;
                                        if (writeStmRfids.size() != 0) {
                                            MapManager.getInstance().rfidRealDistanceClean();
                                            rfidWriteTotalNum = writeStmRfids.size();
                                            rfidWriteNum = 0;
                                            for (int i = 0; i < writeStmRfids.size(); i++) {
                                                if (writeRfidInterrupt) return;
                                                stmExecute.executeTask(new StmTask().rfidWrite(i,
                                                        writeStmRfids.get(i).getRfidTag(),
                                                        writeStmRfids.get(i).getDistance()));

                                                if (i == writeStmRfids.size() - 1) {
                                                    //防止缺漏，60s再次检查
                                                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_STM_MAP_CONFIG_RESULT, 60_000);
                                                }
                                                try {
                                                    Thread.sleep(10);
                                                } catch (InterruptedException e) {
                                                    e.printStackTrace();
                                                }
                                                if (writeRfidInterrupt) return;
                                            }

                                        } else {
                                            mNeedUpdateStmMap = false;
                                            RxBus.getInstance().post(new RobotEvent(RobotEvent.ACTION_UPDATE_STM_MAP_FINISHED));
                                        }
                                    }
                                });
                            }
                            break;
                        case StmTask.RFID_OPERATION_WRITE: //写入数据
                            ULog.d(TAG, "向下位机写入rfid数据 stm_rfid 总数 = " + rfidWriteTotalNum + " 当前 " + rfidWriteNum + " 状态 " + status);
                            if (status == 1) {
                                rfidWriteNum++;
                                if (num + 1 == rfidWriteTotalNum) {
                                    ULog.d(TAG, "向下位机写入rfid数据 stm_rfid 写入完成");
                                    mNeedUpdateStmMap = false;
                                    mHandler.removeMessages(Msg.WHAT_CHECK_STM_MAP_CONFIG_RESULT);
                                    StorageCenter.getRobotStorage().putString(StorageCenter.KEY_RFID_NODE, gson.toJson(writeStmRfids));
                                    StorageCenter.getRobotStorage().saveAsync();
                                    RxBus.getInstance().post(new RobotEvent(RobotEvent.ACTION_UPDATE_STM_MAP_FINISHED));
                                }
                            } else {
                                mHandler.postDelayed(() -> {
                                    stmExecute.executeTask(new StmTask().rfidWrite(num, epc, (float) (distanceMM / 1000.0)));
                                }, 500);
                            }
                            break;
                        case StmTask.RFID_OPERATION_READ_CURRENT: //查询当前rfid
                            ULog.d(TAG, "主动读标签 stm_rfid " + epc);
                            if ("000000000000000000000000".equals(epc)) {
                                ULog.d(TAG, "主动读 未读到 stm_rfid " + epc);
                                RobotFragment.this.getActivity().runOnUiThread(() -> tvShowEpc.setText("epc:未读到"));
                            } else {
                                RobotFragment.this.getActivity().runOnUiThread(() -> tvShowEpc.setText("epc:"+epc));
                                autoMoveManager.onRfidData(num, epc, distanceMM, true);
                            }
                            break;
                        case 1: //读到标签
                            if (num == 0xffff) {
                                ULog.d(TAG, "读到未知标签 stm_rfid " + epc);
                            }
                            rfidErrorNum = 0;
                            autoMoveManager.onRfidData(num, epc, distanceMM, false);
                            break;
                        case 5: //rfid芯片异常
                            if (num == 0xefef) {
                                ULog.d(TAG, "下位机rfid芯片异常 stm_rfid rfidErrorNum = " + rfidErrorNum);
//                                if (rfidErrorNum == 0) {
                                    resetRfidGpio(1);
//                                }
                                rfidErrorNum++;
                            }
                            break;
                    }
                }
                break;
                //写多字应答
                case StmTask.WRITE_MULTIPLE_DATA: {
                    ULog.d(TAG, "onStmReceiveData : 写多字应答 首个寄存器地址 " + Integer.toHexString(data[3] & 255).toUpperCase());
                    regAddress = (data[2] & 255) << 8 | data[3] & 255;

                    switch (regAddress) {
                        case StmTask.REG_CURR_MOVE_STEP_U16: {
                            //                            SpeedDetector.getInstance().setStopMove(false);
                            setInCharger(false,"下位机返回机器人移动");
                        }
                        break;

                        default:
                            break;
                    }
                }
                break;

                case StmTask.WRITE_SINGLE_DATA:
                    regAddress = (data[2] & 255) << 8 | data[3] & 255;
                    int flag = (data[4] & 255) << 8 | data[5] & 255;
                    ULog.df("onStmReceiveData : StmTask.WRITE_SINGLE_DATA>>regAddress={}; flag={}", regAddress, flag);
                    switch (regAddress) {
                        case StmTask.WebCamera.REG_READ_FILL_LIGHT_LEVEL:
                            //读取补光灯强度
                            this.fillLightLevel = flag;
                            break;
                        case StmTask.REG_READ_CHARGER_ON:
                            ULog.i(TAG, "onStmReceiveData: 上位机主动获取到位开关磁铁状态 flag=" + flag);
                            //在电梯附近直接进行gotoChargerStepThree (电梯中也有到位磁铁防止与充电桩搞混) 电梯附近目前肯定不会存在充电桩
                            if (flag == SIGNAL_IN_PLACE && !MainApp.elevatorDeviceNear) {
                                if (AutoMoveManager.mTargetChargerNodeW != null && AutoMoveManager.mTargetChargerNodeW.getCharger() != null) {
                                    Charger thisCharger = AutoMoveManager.mTargetChargerNodeW.getCharger();
                                    Float installLocation = thisCharger.getInstallLocation();
                                    boolean isCorrect = getInPlaceCorrect(thisCharger);
                                    if (isCorrect && installLocation != null && installLocation > -4 && installLocation <= MapManager.getInstance()
                                            .getMaxDistance() + 2 && Math.abs(mDistance - thisCharger.getInstallLocation()) < 4.0f) {
                                        ULog.e(TAG, "回充 主动查询 充电桩install_position位置校正：" + installLocation);
                                        stmExecute.executeTask(new StmTask().correctDistance(installLocation));
                                    } else {
                                        ULog.e(TAG, "回充 主动查询 充电桩install_position位置有误：" + installLocation + " 是否需要校正 " + isCorrect);
                                    }
                                }
                                autoMoveManager.chargerInPlace();
                                mHandler.postDelayed(() -> goChargerEndHandle(), 1000);
                            } else if (flag == SIGNAL_NO_PLACE || MainApp.elevatorDeviceNear) {
                                mIsFirstDustingAfterBoot = false;
                                setMode(MODE_GOTO_CHARGER, "回充模式-不在充电桩到位磁铁回充");
                                cleanMoveHinder(1);
                                if (AutoMoveManager.mTargetChargerNodeW == null) {
                                    ULog.d(TAG, "gotoChargerStepThree:  == nearestChargerNode is null 222");
                                    break;
                                }
                                if (mBotInfoMgr.isHaveSteer() && isInCleanDeviceArea(mDistance) && mIsHaveNewCleanDevice) {
                                    if (mBotInfoMgr.getRobotConfigParams().getLeaveBySteerVerticalDown() == UConstants.VALUE_SWITCH_STATUS_ON) {
                                        SteerController.getInstance().directSetVAngle(180, SteerControlTag.LEAVE_CLEAN_DEVICE.getReason());
                                    }
                                }
                                autoMoveManager.gotoChargerStepThree();
                            }
                            break;

                        case StmTask.REG_NET_STATUS:
                            if (flag == 1) { //确认关灯
                                netLightOpen = false;
                                if (mHandler.hasMessages(Msg.WHAT_CLOSE_NET_FLASH_LIGHT)) {
                                    mHandler.removeMessages(Msg.WHAT_CLOSE_NET_FLASH_LIGHT);
                                }
                            }
                            break;

                        case StmTask.REG_OBSTACLE_DISTANCE_WRITE:
                            ULog.d(TAG, "onStmReceiveData: 障碍物距离 " + flag);
                            break;

                        case StmTask.REG_MOTOR_DRIVE_ENABLE:
                            if (flag == 1) {//接收到电机使能 强制使能 返回
                                if (mHandler.hasMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE)) {//handler停止继续发送
                                    mHandler.removeMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE);
                                    ULog.i(TAG, "onStmReceiveData: 强制使能: 下位机返回开启成功 上位机handler停止继续发送");
                                }
                                if (MODE == MODE_UN_KNOW) {
                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("强制使能: 下位机返回开启成功 机器人停止指令已发送 44"));
                                    ULog.i(TAG, "onStmReceiveData: 强制使能: 下位机返回开启成功 机器人停止指令已发送");
                                }

                            }

                            break;

                        case StmTask.PowerManager.REG_POWER_CONTROL:
                            if (flag == UConstants.VALUE_SWITCH_STATUS_ON) {
                                //退出省电模式
                                UPreferences.putBoolean(getContext(), UConstants.KEY_IS_IN_SLEEP_MODE, false);
                                mHandler.removeMessages(Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE);

                            } else {
                                if (isPowerKey) {
                                    mActivity.writePowerOffLog("low_power");
                                    try {
                                        Thread.sleep(1000);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }

                                    URootCmd.execRootCmdSilent("reboot -p");
                                    isPowerKey = false;
                                } else {
                                    //进入省电模式
                                    UPreferences.putBoolean(getContext(), UConstants.KEY_IS_IN_SLEEP_MODE, true);
                                    mHandler.removeMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE);
                                    enterPowerSaveMode();
                                }
                            }
                            break;

                        case StmTask.REG_MOTOR_SPEED:
                            //                            SpeedDetector.getInstance().setTargetSpeed(getRealSpeed(flag));
                            break;

                        case StmTask.PowerManager.REG_ENABLE_COMPONENT: {
                            ULog.i(TAG, "组件使能成功：" + Integer.toBinaryString(flag));
                            if ((flag & StmTask.FuncPowerBit.BIT_5V_0) == StmTask.FuncPowerBit.BIT_5V_0) {
                                RxBus.getInstance().post(new DeviceEvent(DeviceEvent.ACTION_USB_HUB_ENABLE_SUCCESS));
                            }
                            if ((flag & StmTask.FuncPowerBit.BIT_SENSOR_POWER) == StmTask.FuncPowerBit.BIT_SENSOR_POWER) {
                                ULog.d(TAG, "sensor_control_true_success");
                                sensorEnableStatus = true;
                                UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCES_SENSOR_ENABLE_STATUS, sensorEnableStatus);
                                RxBus.getInstance().post(new DeviceEvent(DeviceEvent.ACTION_SENSOR_ENABLE_SUCCESS));
                            }
                        }
                        break;

                        case StmTask.PowerManager.REG_DISABLE_COMPONENT: {
                            ULog.i(TAG, "组件失能成功：" + Integer.toBinaryString(flag));
                            if ((flag & StmTask.FuncPowerBit.BIT_5V_0) == StmTask.FuncPowerBit.BIT_5V_0) {
                                RxBus.getInstance().post(new DeviceEvent(DeviceEvent.ACTION_USB_HUB_DISABLE_SUCCESS));
                            }
                            if ((flag & StmTask.FuncPowerBit.BIT_SENSOR_POWER) == StmTask.FuncPowerBit.BIT_SENSOR_POWER) {
                                ULog.d(TAG, "sensor_control_false_success");
                                sensorEnableStatus = false;
                                UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCES_SENSOR_ENABLE_STATUS, sensorEnableStatus);
                                RxBus.getInstance().post(new DeviceEvent(DeviceEvent.ACTION_SENSOR_DISABLE_SUCCESS));
                            }
                        }
                        break;

                        default:
                            break;
                    }

                    break;


                case StmTask.STM_SEND_DATA:
                    int registerAddress = (data[2] & 255) << 8 | data[3] & 255;
                    if (registerAddress != StmTask.REG_UPGRADE_FLAG && registerAddress != StmTask.REG_ROBOT_TYPE) {
                        byte[] copyData = new byte[data.length - 2];
                        System.arraycopy(data, 0, copyData, 0, data.length - 2);
                        ULog.d(TAG, "onStmReceiveData:  ==== " + UByte.print(copyData, copyData.length));
                        stmExecute.executeTaskNonQueue(copyData);//应答
                    }

                    int placeFlag = (data[4] & 255) << 8 | data[5] & 255;
                    switch (registerAddress) {
                        case StmTask.REG_READ_CHARGER_ON:
                            ULog.d(TAG,"(SwitchTrackController||ElevatorController) 到位磁铁相关 > 下位机主动上传到位开关状态 >> placeFlag="+placeFlag);

                            //电梯,变轨装置 当下位机主动读取到到位磁铁之后自己判断是否是在对应设备的附近 是否需要进行下一步操作
                            if(getRobotConfigParams() != null){
                                if(placeFlag == SIGNAL_IN_PLACE){
                                    if(getRobotConfigParams().isHaveSwitchTrack()){
                                        SwitchTrackController.getInstance(this).onRobotReadInPlaceSwitchChange(true);
                                    }
                                    if(getRobotConfigParams().isHaveElevator()){
                                        //TODO 采用接口回调的方式吧 判空 然后在需要注册回调的地方手动注册
                                        ElevatorController.getInstance(this).onRobotReadInPlaceSwitchChange(true);
                                    }

                                }else if(placeFlag == SIGNAL_NO_PLACE){
                                    if(getRobotConfigParams().isHaveSwitchTrack()){
                                        SwitchTrackController.getInstance(this).onRobotReadInPlaceSwitchChange(false);
                                    }
                                    if(getRobotConfigParams().isHaveElevator()) {
                                        ElevatorController.getInstance(this).onRobotReadInPlaceSwitchChange(false);
                                    }
                                }
                            }

                            //自动刷机
                            //超过10秒重置
                            long timeDiff = System.currentTimeMillis() - lastRecoveryInPlaceTime;
                            ULog.d(TAG,
                                    "下位机读取到 到位开关 recovery num == " + recoveryInPlaceNum + " timeDiff = " + timeDiff + " placeFlag=" + placeFlag + " setChargerTarget=" + AutoMoveManager.setChargerTarget);
                            if (timeDiff > 2000 && timeDiff < 8_000) {
                                if (placeFlag == 1) {
                                    recoveryInPlaceNum++;
                                }
                            } else {
                                recoveryInPlaceNum = 0;
                            }
                            lastRecoveryInPlaceTime = System.currentTimeMillis();
                            if (recoveryInPlaceNum >= recoveryThreshold) {
                                //执行刷机
                                MainApp.recoverySystem();
                            }

                            if (placeFlag == SIGNAL_IN_PLACE && AutoMoveManager.setChargerTarget) { //充电桩到位
                                if (MODE == MODE_GOTO_CHARGER) {
                                    if (AutoMoveManager.mTargetChargerNodeW != null && AutoMoveManager.mTargetChargerNodeW.getCharger() != null) {
                                        Charger thisCharger = AutoMoveManager.mTargetChargerNodeW.getCharger();
                                        Float installLocation = thisCharger.getInstallLocation();
                                        boolean isCorrect = getInPlaceCorrect(thisCharger);
                                        if (isCorrect && installLocation != null && installLocation > -4 && installLocation <= MapManager.getInstance()
                                                .getMaxDistance() + 2 && Math.abs(mDistance - thisCharger.getInstallLocation()) < 4.0f) {
                                            ULog.e(TAG, "回充 充电桩install_position位置校正：" + installLocation);
                                            stmExecute.executeTask(new StmTask().correctDistance(installLocation));
                                        } else {
                                            ULog.e(TAG, "回充 充电桩install_position位置有误：" + installLocation + " 是否需要校正 " + isCorrect);
                                        }
                                    }
                                    autoMoveManager.chargerInPlace();
                                    mHandler.postDelayed(() -> goChargerEndHandle(), 1000);
                                }
                            } else if (placeFlag == SIGNAL_NO_PLACE) {
                                if (inCharger()) {
                                    setInCharger(false,"下位机返回离开到位");
                                    UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
                                }
                            } else if (placeFlag == SIGNAL_BOUNDS) {
                                if (MODE != MODE_GOTO_CHARGER && MODE != MODE_AGING_TEST) {
                                    break;
                                }
                                if (MODE == MODE_AGING_TEST && !agingTestGoTOCharger) {
                                    break;
                                }
                                //                                stmExecute.executeTaskNonQueue(new StmTask().stopMove());
                                //                                setSpeed(UConstants.DEFAULT_GOTO_CHARGER_SPEED);
                                setSpeed(0.02f, RobotSetSpeedLogTags.SPEELD_lOG_TAG_20);
                                ULog.e(TAG, "onStmReceiveData:  ===  越界 == " + robotDirection);
                                if (robotDirection == StmTask.MOVE_FRONT) {
                                    setRobotDirection(StmTask.MOVE_END,"12");
                                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                                } else {
                                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_TURN_BACK, 1000);
                                }
                            }
                            break;

                        case StmTask.REG_READ_IN_PLACE_SWITCH: {
                            //除尘时读到到位开关
                            ULog.i(TAG, "除尘模式读到到位开关:" + placeFlag + " rfidReadType " + rfidReadType);
                            if (placeFlag == SIGNAL_IN_PLACE) {
                                //读到信号
                                if (AutoMoveManager.mTargetChargerNodeW != null && AutoMoveManager.mTargetChargerNodeW.getCharger() != null) {
                                    Charger thisCharger = AutoMoveManager.mTargetChargerNodeW.getCharger();;
                                    Float installLocation = thisCharger.getInstallLocation();
                                    boolean isCorrect = getInPlaceCorrect(thisCharger);
                                    if (isCorrect && installLocation != null && installLocation > -4 && installLocation <= MapManager.getInstance()
                                            .getMaxDistance() + 2 && Math.abs(mDistance - thisCharger.getInstallLocation()) < 4.0f) {
                                        ULog.e(TAG, "除尘 充电桩install_position位置校正：" + installLocation);
                                        stmExecute.executeTask(new StmTask().correctDistance(installLocation));
                                    } else {
                                        ULog.e(TAG, "除尘 充电桩install_position位置有误：" + installLocation + " 是否需要校正 " + isCorrect);
                                    }
                                } else {
                                    ULog.w(TAG, "没有绑定的充电桩，无法校准里程");
                                }

                            }
                        }
                        break;


                        //电机报警
                        case StmTask.REG_READ_ALARM_CODE: {
                            ULog.e(TAG, "电机报警 ：" + placeFlag);
                            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_STM_REPORT_MOVEMENT_HINDRANCE));

                            //非巡检、回充模式
                            switch (placeFlag) {
                                case 0x0015:
                                    //电机大电流，电流>=3.5.
                                    ULog.e(TAG, "电机停机 电流过大");
                                    break;

                                default:
                                    ULog.e(TAG, "电机停机 运动阻碍");
                                    break;
                            }
                        }
                        break;

                        default:
                            break;
                    }
                    break;

                case StmTask.READ_MOTOR_INFO:
                    mLastMotorHeartTimeInMills = System.currentTimeMillis();
                    receiveHeartNum++;
                    receiveSerialNum++;
                    double motorTemperature = 0, motor2Temperature = 0, motorVoltage = 0;
                    int warnCode = -1, location = 0;
                    position = 2;
                    if (data.length - 2 <= 2) {
                        break;
                    }
                    warnCode = data[position++] & 255;
                    motorTemperature = ((short) ((data[position++] & 255) << 8 | data[position++] & 255)) / 100.0;
                    motorVoltage = ((data[position++] & 255) << 8 | data[position++] & 255) / 327.0;
                    double mMotorSpeedTemp = 0, motor2SpeedTemp = 0;
                    float mMotorCurrentTemp = 0, motor2CurrentTemp = 0, mPhaseCurrent = 0;

                    RobotBluetoothManager.motorTemperature = motorTemperature;
                    RobotBluetoothManager.motorVoltage = motorVoltage;
                    if (rfidReadType == 0 || rfidReadType == 1) {
                        //单位：转
                        mMotorSpeedTemp = ((short) ((data[position++] & 255) << 8 | data[position++] & 255)) / 10.0;
                    } else if (rfidReadType == 2 || rfidReadType == 3) {
                        //单位：毫米/1000=米
                        mMotorSpeedTemp = ((short) ((data[position++] & 255) << 8 | data[position++] & 255)) / 1000.0;
                    }
                    location = (data[position++] & 255) << 24 | (data[position++] & 255) << 16 | (data[position++] & 255) << 8 | (data[position++] & 255);
                    mMotorCurrentTemp = (float) (((data[position++] & 255) << 8 | data[position++] & 255) / 2000.0);


                    if (data.length >= 16) {
                        warnCode = (data[position++] & 255) << 8 | warnCode & 0xff;
                    }

                    if (data.length >= 18) {
                        int originPhaseCurrent = (data[position++] & 255) << 8 | data[position++] & 255;
                        mPhaseCurrent = originPhaseCurrent / 100.0f;
                    }
                    float motor2Distance = 0;
                    if (data.length >= 28) {
                        motor2Temperature = ((short) ((data[position++] & 255) << 8 | data[position++] & 255)) / 100.0;
                        motor2SpeedTemp = ((short) ((data[position++] & 255) << 8 | data[position++] & 255)) / 1000.0;
                        motor2CurrentTemp = (float) (((data[position++] & 255) << 8 | data[position++] & 255) / 2000.0);
                        motor2Distance = (float) (((data[position++] & 255) << 24 | (data[position++] & 255) << 16 | (data[position++] & 255) << 8 | (data[position++] & 255)) / 1000.0);
                    }

                    if (warnCode != 0 && getRobot() != null && !TextUtils.isEmpty(getRobot().getType())) {
                        //是否是煤安
                        boolean isMaMotor = mRobotType.getSubType() == RobotSubType.FB || mRobotType.getSubType() == RobotSubType.MA;
                        if (isMaMotor) {
                            //煤安
                            //0xEEEE表示驱动板读取失败
                            if (warnCode != 0xEEEE) {
                                //有效电机报警代码
                                int code = warnCode & 0x1B29;
                                if (code != 0) {
                                    ULog.d(TAG,
                                            "电机驱动板报警代码非0。报警代码：" + Integer.toHexString(warnCode) + "， 有效&=" + Integer.toHexString(code) + ", &=" + Integer.toBinaryString(
                                                    code));
                                    //电机驱动板报警, 为避免重复触发，忽略1s内的多次报警
                                    if (System.currentTimeMillis() - mLastMotorManagerAlarmTime > 1000) {
                                        ULog.d(TAG, "电机驱动板报警，可能发生运动阻碍。分发报警事件并重新使能电机");
                                        mLastMotorManagerAlarmTime = System.currentTimeMillis();
                                        RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_MOTOR_MANAGE_BOARD_ALARM));
                                        if (!mHandler.hasMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE)) {
                                            mHandler.sendEmptyMessage(Msg.WHAT_MOTOR_DRIVER_ENABLE);
                                        }
                                    }
                                }
                            } else {
                                ULog.e(TAG, "电机报警代码0xEEEE, 可能驱动板读取失败");
                            }
                        } else {
                            //非煤安
                            //非煤安0x14 堵转，煤安0x20堵转，需要重新使能
                            if (warnCode == 0x14) {
                                if (System.currentTimeMillis() - mLastMotorManagerAlarmTime > 1000) {
                                    ULog.d(TAG, "电机驱动报警，可能发生运动阻碍。分发报警事件并重新使能电机");
                                    mLastMotorManagerAlarmTime = System.currentTimeMillis();
                                    RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_MOTOR_MANAGE_BOARD_ALARM));
                                    if (!mHandler.hasMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE)) {
                                        mHandler.sendEmptyMessage(Msg.WHAT_MOTOR_DRIVER_ENABLE);
                                    }
                                }
/*
                                if (warnCode == 0x14 && getRobot().getSendMotorDriverEnableDelayed() != null && MODE == MODE_UN_KNOW) {
                                    if (!mHandler.hasMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE)) {//如果当前Handler没有在发送电机驱动使能
                                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_MOTOR_DRIVER_ENABLE, getRobot().getSendMotorDriverEnableDelayed());
                                        ULog.i(TAG, "onStmReceiveData: 强制使能: 机器人正常模式下 堵转 开始 发送电机驱动使能 mHandler延迟" + getRobot().getSendMotorDriverEnableDelayed());
                                    }
                                }
*/
                            }

                        }
                    }
                    if (setPidTime != 0 && (System.currentTimeMillis() - setPidTime) > 21000) {
                        ULog.d(TAG, "setPid 长时间不执行，handler可能出现问题，重启当前程序 kill_oneself");
                        URootCmd.execRootCmdSilent("kill -9 " + android.os.Process.myPid());
                    }
                    if (moveHinderNeedSleep && !mHandler.hasMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE)) {
                        if (!isRecordSleepTime) {
                            if (sleepTimeMoveHinder == 10) {
                                sleepTimeMoveHinder = 30;
                            } else if (sleepTimeMoveHinder == 30) {
                                sleepTimeMoveHinder = 60;
                            } else if (sleepTimeMoveHinder == 60) {
                                sleepTimeMoveHinder = 60;
                            } else {
                                sleepTimeMoveHinder = 10;
                            }
                        }
                        ULog.d(TAG, "移动检测中 start_sleep 运动阻碍后需要休眠 发送休眠 休眠时间 " + sleepTimeMoveHinder + "分");
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE, 5 * 60_000);
                    }

                    if (warnCode == 0xEE || warnCode == 0xFF || warnCode == 0xEEEE
                            || warnCode == 0xEE00 || warnCode == 0xFF00
                            || warnCode == 0xEEFF || warnCode == 0xFFEE) {
                        if (getRobot() != null) {
                            getRobot().setAlarm(warnCode);
                        }
                        ULog.d(TAG, "stm_motor warnCode error  = " + warnCode);
                        break;
                    } else {
                        mMotorCurrent = mMotorCurrentTemp;
                        mMotorCurrent2 = motor2CurrentTemp;
                        RobotBluetoothManager.motorCurrent = mMotorCurrent;
                        mMotorSpeed = mMotorSpeedTemp;
                    }

                    if (testMotorCurrentListener != null) {
                        Observable.just(1)
                                .observeOn(Schedulers.io())
                                .subscribe(lv -> {
                                    testMotorCurrentListener.onDataBack(mDistance, mMotorCurrent, mMotorCurrent2);
                                });
                    }

                    if (distanceAndMotorCurrentTestLogSwitch && printWriter != null) {


                        String format = dateFormat.format(new Date());
                        String str = "{\"format\":" + format + "," +
                                "\"mDistance\":" + mDistance + "," +
                                "\"mMotorCurrent\":" + mMotorCurrent + "," +
                                "\"mMotorCurrent2\":" + mMotorCurrent2 + "," +
                                "\"motorVoltage\":" + motorVoltage + "," +
                                "\"mPhaseCurrent\":" + mPhaseCurrent + "," +
                                "\"mCurrent\":" + mCurrent + "}";

                        printWriter.println(str);
                    }

                    //                    ULog.d(TAG, "onStmReceiveData:  === 位置 == " + location + "   " + ((UConstants.ONE_ROUND_STEP * 2.0)) + "  " + UConstants.DISTANCE_TWO_ROUND);
                    //ladybug计算位置 = location/556305.3743

                    if (rfidReadType == 0 || rfidReadType == 1) {
                        mDistance = (float) (location / (UConstants.ONE_ROUND_STEP * 2.0) * UConstants.DISTANCE_TWO_ROUND);
                    } else if (rfidReadType == 2 || rfidReadType == 3) {
                        mDistance = (float) (location / 1000.0);
                    }
                    RobotBluetoothManager.distance = mDistance;
                    MainApp.mRobotSpeed = Float.parseFloat(FormatUtils.keep3Decimals(getRealSpeed(mMotorSpeed)));
                    RobotBluetoothManager.speed = MainApp.mRobotSpeed;
                    MainApp.mUpdateMotorTime = System.currentTimeMillis();
                    MainApp.mDistance = mDistance;
                    if (mLastDistance != UConstants.UNKONW && MainApp.mRobotSpeed != 0) {
                        if (MainApp.mDrivingMileage < 0) MainApp.mDrivingMileage = 0;
                        if (MainApp.mStInfo.getInspectionTotalMileage() < 0) MainApp.mStInfo.setInspectionTotalMileage(0);

                        float mileDiff = Math.abs(mDistance - mLastDistance);
                        if (mileDiff < 5) {
                            MainApp.mDrivingMileage += mileDiff;
                            if (isInspectionMode() && MainApp.inspectIsSelf) {
                                MainApp.mStInfo.setInspectionTotalMileage(MainApp.mStInfo.getInspectionTotalMileage() + mileDiff);
                            }
                        } else {
                            ULog.d(TAG, "里程变化较大 不记入总行驶里程 上次 " + mLastDistance + " 当前 " + mDistance + " 差值 " + mileDiff);
                        }
                    }
                    mLastDistance = mDistance;


                    if (mLastInspectTime != UConstants.UNKONW) {
                        if (MainApp.mStInfo.getInspectionTotalTime() < 0) MainApp.mStInfo.setInspectionTotalTime(0);

                        long timeDiff = System.currentTimeMillis() - mLastInspectTime;
                        if (timeDiff > 0 && timeDiff < 20 * 60_000) {
                            if (isInspectionMode() && MainApp.inspectIsSelf)
                                MainApp.mStInfo.setInspectionTotalTime(MainApp.mStInfo.getInspectionTotalTime() + timeDiff);
                        } else {
                            ULog.d(TAG, "巡检时间变化较大 不记入总巡检时长 上次 " + mLastInspectTime + " 当前 " + System.currentTimeMillis() + " 差值 " + timeDiff);
                        }
                        StorageCenter.getRobotStorage().putLong(UConstants.PREFERENCES_INSPECTION_TOTAL_TIME_KEY, MainApp.mStInfo.getInspectionTotalTime());
                    }
                    mLastInspectTime = System.currentTimeMillis();

                    StorageCenter.getRobotStorage().putFloat(UConstants.PREFERENCES_DRIVING_MILEAGE_KEY, MainApp.mDrivingMileage);
                    StorageCenter.getRobotStorage().putFloat(UConstants.PREFERENCES_INSPECTION_TOTAL_MILEAGE_KEY, MainApp.mStInfo.getInspectionTotalMileage());
                    StorageCenter.getRobotStorage().putInteger("motor_location", location);
                    StorageCenter.getRobotStorage().putFloat("motor_distance", mDistance);
                    StorageCenter.getRobotStorage().saveAsync();


                    if (isNeedInitSteer && RestrictDistanceWatcher.initFinish) {
                        isNeedInitSteer = false;
                        boolean inBy = isInCleanDeviceArea(mDistance);
                        ULog.d(TAG, "SteerController need resetSteer inBy = " + inBy);
                        SteerController.getInstance().resetSteer(inBy);
                    }
                    //                    SpeedDetector.getInstance().setRealSpeed(getRealSpeed(mMotorSpeed));

                    //传感器部分
                    if (getRobot() != null && mSensorManager != null && mSensorManager.cacheInfo().MOTOR_INFO != null) {
                        MotorInfo motorInfo = mSensorManager.cacheInfo().MOTOR_INFO;

                        Map<String, String> motorValueMap = new HashMap<>();
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_VOLTAGE,
                                String.valueOf(FormatUtils.keepDecimals(motorVoltage, 2)));
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_CURRENT, String.valueOf(mMotorCurrent));
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_CURRENT2, String.valueOf(mMotorCurrent2));
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_SPEED,
                                String.valueOf(FormatUtils.keepDecimals(getRealSpeed(mMotorSpeed), 3)));
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_DISTANCE,
                                String.valueOf(FormatUtils.keepDecimals(mDistance, 2)));
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_LOCATION, String.valueOf(location));
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_TEMPERATURE,
                                String.valueOf((float) motorTemperature));
                        motorValueMap.put(MotorConfigConstants.Values.VALUE_MOTOR_WARE_CODE, String.valueOf(warnCode));

                        updateSensorData(SensorType.SENSOR_TYPE_MOTOR, "", motorInfo.getInstallPosition(), "1",
                                motorInfo.getType(), motorValueMap);

                        getRobot().setLocation(location);
                        getRobot().setRealMileage(mDistance);
                        getRobot().setMotorVoltage((float) motorVoltage);
                        //保留四位小数
                        //                        getRobot().setSpeed((float) (((int) (getRealSpeed(mMotorSpeed) * 10000)) / 10000.0));
                        getRobot().setSpeed(MainApp.mRobotSpeed);
                        getRobot().setAlarm(warnCode);
                        RobotBluetoothManager.motorWarnCode = warnCode;
                        getRobot().setMotorTemperature((float) motorTemperature);


                        if (mRobotType.getSubType() == RobotSubType.FB || mRobotType.getSubType() == RobotSubType.MA) {
                            if (lastSpeed != 0 && (System.currentTimeMillis() - speedTime) > 3000 && Math.abs(getRobot().getSpeed()) > lastSpeed + 0.3) {
                                if (System.currentTimeMillis() - speedStopTime > 1000) {
                                    ULog.d(TAG, "煤安机器超速停止");
                                    speedStopTime = System.currentTimeMillis();
                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("煤安机器超速停止 45"));
                                }
                            }
                        }
                    }

                    ULog.d(TAG, "stm_motor distance  = " + mDistance + " motor2distance " + motor2Distance +
                            " speed " + (getRobot() != null ? getRobot().getSpeed() : "null") + " motor2Speed " + motor2SpeedTemp + " DrivingMileage " + FormatUtils.keepDecimals(MainApp.mDrivingMileage, 3) +
                            " warnCode " + warnCode + " motorCurrent_" + mMotorCurrent + ", " + mMotorCurrent2   + " mPhaseCurrent_" + mPhaseCurrent + " motorVoltage_" + motorVoltage + " motorTemperature_" + motorTemperature + " motor2Temperature_" + motor2Temperature +
                            (inspectManager == null ? " inspectManager is null" : inspectManager.getInspectLog()) +
                            " mCurrentNode = " + (inspectManager != null && inspectManager.mCurrentTaskNode != null ? inspectManager.mCurrentTaskNode.getName() : "null") +
                            " oneWayPoleCheck " + (inspectManager != null ? inspectManager.oneWayPoleCheck : "null") +
                            " oneWayPoleCheckBack " + (inspectManager != null ? inspectManager.oneWayPoleCheckBack : "null"));

                    //回调电机信息给巡检使用
                    inspectManager.onMotorInfo(mDistance, Math.abs(getRealSpeed(mMotorSpeed)));

                    MediaService.resetPlayFlag();

                    //里程回调 暂时给检测Aruco码巡检用
                    if (mOnDistanceInfoListener != null) {
                        mOnDistanceInfoListener.onDistanceInfo(mDistance);
                    }

                    if(onDistanceListener4SwitchTrack != null){
                        onDistanceListener4SwitchTrack.onDistanceBack(mDistance);
                    }

                    if (!saveDistanceFlag) {
                        saveDistanceFlag = true;
                        distanceCheck = mDistance;
                    }


                    //电机电压低于一定阈值并且warnCode=0 报警 电压阈值 默认20V
                    //warnCode电机报警代码 0x14：堵转  05：不能通信
                    if (warnCode == 0) {
                        if (getRobot() != null && mSensorManager != null && mSensorManager.cacheInfo().MOTOR_INFO != null) {
                            MotorInfo motorInfo = mSensorManager.cacheInfo().MOTOR_INFO;
                            if (motorVoltage <= motorInfo.getLowVoltageThreshold()) {
                                if (addAlarmCount(AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_LOWER_THAN_THRESHOLD_WITH_LOCATION) >= mAlarmManager.getAlarmTriggerCount(
                                        AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_LOWER_THAN_THRESHOLD_WITH_LOCATION)) {
                                        List<String> params = new ArrayList<>();
                                        params.add(getSensorAlarmFirstParam());
                                        params.add(String.valueOf(motorInfo.getLowVoltageThreshold()));
                                        params.add(String.valueOf(FormatUtils.keepDecimals(motorVoltage, 2)));

                                        AlarmEvent alertEvent =
                                                new AlarmEvent(AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_LOWER_THAN_THRESHOLD_WITH_LOCATION,
                                                        params);
                                        RxBus.getInstance().post(alertEvent);
                                        setIsAlarmReported(AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_LOWER_THAN_THRESHOLD_WITH_LOCATION,
                                                true);
                                }
                            } else {
                                setAlarmCount(AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_LOWER_THAN_THRESHOLD_WITH_LOCATION, 0);
                                if (getIsAlarmReported(AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_LOWER_THAN_THRESHOLD_WITH_LOCATION)) {
                                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_EXCEPTION_RESUME));
                                    setIsAlarmReported(AlarmTypeEnum.ROBOT_MOTOR_VOLTAGE_LOWER_THAN_THRESHOLD_WITH_LOCATION,
                                            false);
                                }
                            }

                        }


                    }

/*                    float slipLowerThreshold = 1.3f;
                    if (SensorInfoCache.MOTOR_INFO != null) {
                        slipLowerThreshold = SensorInfoCache.MOTOR_INFO.getMotorSlipLowerThreshold();
                    }*/

                    //电机电流超过3A后，要进行保护防失速 , 仅适用于巡检和回充模式
                    float overCurrentThreshold = 3.3f;
                    if (mRobotType.getSubType() == RobotSubType.TY) overCurrentThreshold = 8f;
                    if (mSensorManager != null && mSensorManager.cacheInfo().MOTOR_INFO != null) {
                        overCurrentThreshold = mSensorManager.cacheInfo().MOTOR_INFO.getOverCurrentThreshold();
                    }
                    //非煤安机型才需要过流保护，煤安机型依靠电机驱动板设置保护
                    if (mRobotType.getSubType() == RobotSubType.BZ) {
                        //电机电流超过3.3A，可能失速，先掉头后退一定距离，再重试
                        //运动阻碍时延迟1s卸力，所以卸力时先不检测电流
                        if (mMotorCurrentTemp >= overCurrentThreshold && mBotInfoMgr.getRobotActionCode() != RobotActionCode.Hindrance.HINDRANCE_UNLOADING) {
                            mMotorOverCurrentNumber++;
                            ULog.w(TAG, "电机过流bz：" + mMotorCurrent + ", " + mMotorCurrent2 + ", 阈值：" + overCurrentThreshold + ", 连续次数:" + mMotorOverCurrentNumber);
                        } else {
                            mMotorOverCurrentNumber = 0;
                        }

                        if (mMotorOverCurrentNumber >= 3) {
                            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_MOTOR_OVER_CURRENT));
                            mMotorOverCurrentNumber = 0;
                        }
                    } else if (mRobotType.getSubType() == RobotSubType.TY) {
                        if ((mMotorCurrentTemp + motor2CurrentTemp) >= overCurrentThreshold && mBotInfoMgr.getRobotActionCode() != RobotActionCode.Hindrance.HINDRANCE_UNLOADING) {
                            mMotorOverCurrentNumber++;
                            ULog.w(TAG, "电机过流ty：" + mMotorCurrent + ", " + mMotorCurrent2 + ", 阈值：" + overCurrentThreshold + ", 连续次数:" + mMotorOverCurrentNumber);
                        } else {
                            mMotorOverCurrentNumber = 0;
                        }

                        if (mMotorOverCurrentNumber >= 3) {
                            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_MOTOR_OVER_CURRENT));
                            mMotorOverCurrentNumber = 0;
                        }
                    }

                    //后退时间为4s，判断里程暂定为速度的6s时间通过的距离
//                    if (mDistanceBeforeBackward != 0 && Math.abs(mDistanceBeforeBackward - mDistance) >=
//                            Math.max(Math.abs(mSpeedBeforeBackward), 0.13f) * 6f) {
                    //新策略最多为反向1米
                    if (mDistanceBeforeBackward != 0 && Math.abs(mDistanceBeforeBackward - mDistance) >= 1.5) {
                        ULog.d(TAG, "电机过流/运动阻碍 已通过里程，重置数据");
                        mMotorAlertCount = 0;
                        mDistanceBeforeBackward = 0f;
                        setSpeed(mSpeedBeforeBackward, RobotSetSpeedLogTags.SPEED_LOG_TAG_54);
                        mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);
                        //移除堵转反方向移动的消息
                        if(mHandler.hasMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD)){
                            mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                        }
                        mBotInfoMgr.setRobotActionCode(robotDirection == MOVE_FRONT ? RobotActionCode.MOVE_FRONT : RobotActionCode.MOVE_END);
                        mHasTriedGoChargerAfterMotorStall = false;
                    }

                    autoMoveManager.mileageHandle(mDistance, Math.abs(getRealSpeed(mMotorSpeed)));
                    mBotInfoMgr.setDistance(mDistance);

                    if (isInspectionMode() && InspectManager.getHandledVarianceFlag() && startInspectionTime != null) {
                        ULog.d(TAG, "tRollerInspectionReport startInspectionTime " + startInspectionTime.getTime());
                        Date startDate = new Date(startInspectionTime.getTime());
                        startInspectionTime = new Date();
                        UPreferences.putLong(mActivity, UConstants.PREFERENCES_INSPECTION_START_DATE_KEY, startInspectionTime.getTime());
                        InspectManager.resetHandledVarianceFlag();
                        if (MainApp.irDetectMode == 0) {
                            fun.unifun.library.cloud.client.inparam.tRollerInspectionReport.Create request = new fun.unifun.library.cloud.client.inparam.tRollerInspectionReport.Create();
                            request.setStartTime(startDate);
                            request.setEndTime(new Date());
                            request.setMapId(mSegment.getMapId());
                            request.setType(getRobot().getChargeStrategy());
                            mHandler.postDelayed(() -> {
                                UOKHttp.post(UrlManager.getBaseUrl(), request, new UOKHttp.RequestCallBack<fun.unifun.library.cloud.client.inparam.tRollerInspectionReport.Create>(fun.unifun.library.cloud.client.inparam.tRollerInspectionReport.Create.class) {

                                    @Override
                                    public void onFailure(Call call, IOException e) {
                                        ULog.d(TAG, "tRollerInspectionReport onFailure " + e.getMessage());
                                    }

                                    @Override
                                    public void onResponseOk(Call call, fun.unifun.library.cloud.client.inparam.tRollerInspectionReport.Create create) {
                                        ULog.d(TAG, "tRollerInspectionReport onResponseOk");
                                    }

                                    @Override
                                    public void onResponseError(Call call, int i, String s) {
                                        ULog.d(TAG, "tRollerInspectionReport onResponseError " + i + " msg " + s);
                                    }
                                });
                            }, 5000);
                        }
                    } else if (inCharger()) {
                        inspectManager.resetHandledVarianceFlag();
                    }
                    break;

                case StmTask.REG_STANDARD_HEART:
                    parseStandardHeartData(data);
                    break;

                case StmTask.SEND_GAS_SENSOR_BOARD: //设置气体传感器采集板后返回的成功或者失败
                    ULog.i(TAG, "onStmReceiveData 配置气体采集板----------0: data=" + UByte.print(data, data.length));
                    if (!TextUtils.isEmpty(productionClientId) && getRobot() != null) {
                        position = 2;
                        switch (data[position++]) {
                            case (byte) GAS_SENSOR_BOARD_TYPE_CH4://甲烷
                                switch (data[position++]) {
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET://调零
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-甲烷-调零:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION://校准
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-甲烷-校准:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET://复位
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-甲烷-复位:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE://标气值
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            setStandardGasValue(getRobot().getStandardGasValue(), 0, standardGasval);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 成功 " + standardGasval);
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-甲烷-标气值:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE://报警上限
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            getRobot().setCh4Thershold(upperVal);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 成功 " + getRobot().getCh4Thershold());
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-甲烷-报警上限:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            case (byte) GAS_SENSOR_BOARD_TYPE_CO://一氧化碳
                                switch (data[position++]) {
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET://调零
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-一氧化碳-调零:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION://校准
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-一氧化碳-校准:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET://复位
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-一氧化碳-复位:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE://标气值
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            setStandardGasValue(getRobot().getStandardGasValue(), 1, standardGasval);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 成功 " + standardGasval);
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-一氧化碳-标气值:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE://报警上限
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            getRobot().setCoThersholdMa(upperVal);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 成功 " + getRobot().getCoThersholdMa());
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-一氧化碳-报警上限:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            case (byte) GAS_SENSOR_BOARD_TYPE_O2://氧气
                                switch (data[position++]) {
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET://调零
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-氧气-调零:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION://校准
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-氧气-校准:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET://复位
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-氧气-复位:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE://标气值
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            setStandardGasValue(getRobot().getStandardGasValue(), 3, standardGasval);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 成功 " + standardGasval);
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-氧气-标气值:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE://报警上限
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            getRobot().setO2UpperThreshold(upperVal);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 成功 " + getRobot().getO2UpperThreshold());
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-氧气-报警上限:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_LOWER_ALARM_VALUE://报警下限
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_LOWER_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            getRobot().setO2LowerThreshold(upperVal);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_LOWER_ACTION,
                                                    " 成功 " + getRobot().getO2LowerThreshold());
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-氧气-报警下限:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    default:
                                        break;
                                }

                                break;
                            case (byte) GAS_SENSOR_BOARD_TYPE_CO2://二氧化碳
                                switch (data[position++]) {
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET://调零
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-二氧化碳-调零:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION://校准
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-二氧化碳-校准:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET://复位
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_RESET_ACTION,
                                                    " 成功 ");
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-二氧化碳-复位:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE://标气值
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            setStandardGasValue(getRobot().getStandardGasValue(), 2, standardGasval);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION,
                                                    " 成功 " + standardGasval);
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-二氧化碳-标气值:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    case GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE://报警上限
                                        if ((data[4] & 255) == 0) {
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 失败 ");
                                        } else if ((data[4] & 255) == 1) {
                                            getRobot().setCo2Threshold(upperVal);
                                            sendMqtt(getRobot().getId(),
                                                    productionClientId,
                                                    ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE,
                                                    CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION,
                                                    " 成功 " + getRobot().getCo2Threshold());
                                        }
                                        ULog.i(TAG, "onStmReceiveData 配置气体采集板-二氧化碳-报警上限:  (data[4] & 255) =" + (data[4] & 255));
                                        break;
                                    default:
                                        break;
                                }
                                break;
                            default:
                                break;
                        }
                    }
                    break;


                case StmTask.CONFIG_STM:
                    int reg = (data[2] & 0xff) << 8 | (data[3] & 0xff);
                    int val =
                            (data[4] & 0xff) << 24 | (data[5] & 0xff) << 16 | (data[6] & 0xff) << 8 | (data[7] & 0xff);
                    String expectVal = mStmConfigParams.get(reg);
                    Integer valInt = null, expectValInt = null;
                    Float valFloat = null, expectValFloat = null;

                    if (expectVal != null) {
                        if (reg == StmTask.StmConfig.REG_MOTOR_REDUCTION_RATIO && (val & 0xFF000000) >= 1) {
                            valFloat = Float.intBitsToFloat(val);
                            expectValFloat = Float.parseFloat(expectVal);
                        } else {
                            valInt = val;
                            expectValInt = Integer.parseInt(expectVal);
                        }
                        ULog.i(TAG, "下位机参数配置回复，寄存器：0x" + Integer.toHexString(reg) + ",值：" + val + " float " + valFloat);
                        if (valFloat != null && expectValFloat != null && expectValFloat.equals(valFloat)) {
                            mStmConfigParams.remove(reg);
                        } else if (valInt != null && expectValInt != null && expectValInt.equals(valInt)) {
                            mStmConfigParams.remove(reg);
                        } else {
                            ULog.w(TAG, "下位机参数配置失败，寄存器：0x" + Integer.toHexString(reg) + ",值：" + val);
                        }
                    } else {
                        ULog.e(TAG, "下位机参数配置，未知寄存器，地址：0x" + Integer.toHexString(reg) + ",实际值：" + expectVal);
                    }
                    break;

                default:
                    break;
            }
        }
    }

    public void setFixDis(int fixDis, boolean isFront) {
        if (irService != null)
            irService.setFixDis((short) fixDis, isFront);
    }

    public void setAirTmp(float airTmp) {
        if (irService != null)
            irService.setAirTmp(airTmp);
    }

    public void setPutText(boolean putText) {
        Log.d(TAG, "setPutText:  == " + putText);
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_IR_PUT_TEXT, putText);
        if (irService != null)
            irService.setPutText(putText);
    }

    public boolean robotSleep() {
        clearHeadTailInspectFlag();

        if (getRobot().getSleepMode() != null && getRobot().getSleepMode() == 1) {
            boolean isInSleepMode = UPreferences.getBoolean(MainApp.getInstance(), UConstants.KEY_IS_IN_SLEEP_MODE, false);
            boolean continueSleep = checkArrangeInspection(true);
            ULog.d(TAG, "robotSleep == isInSleepMode=" + isInSleepMode + ", continueSleep=" + continueSleep + ", " +
                    "mode=" + MODE);
            if (!continueSleep && MODE != MODE_INSPECTION) {
                mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE);
                return false;
            }
            ULog.d(TAG, "休眠已打开，开始休眠");
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE, 1000);
            return true;
        }

        return false;

    }

    private void clearHeadTailInspectFlag() {
        inspectManager.isInspectHead = false;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_INSPECT_HEAD_KEY, false);
        inspectManager.isInspectTail = false;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_INSPECT_TAIL_KEY, false);
    }

    private void inspectIsBySelf(MqttCommand command) {
        if (command.getSource() != null && command.getSource().contains("self")) {
            ULog.d(TAG, "自触发巡检 source " + command.getSource() + " action " + command.getAction());
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_INSPECT_IS_SELF, true);
        } else {
            ULog.d(TAG, "非自触发巡检 source " + command.getSource() + " action " + command.getAction());
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_INSPECT_IS_SELF, false);
        }
    }

    private boolean isSleepTip = false;
    private boolean needOpenDusting = false; //是否需要除尘

    //回充结束后对统计数据的处理
    public void goChargerEndStatisticInfoHandle() {
        int cacheFlag = UPreferences.getInt(mActivity, "stop_inspect_statistic", 0);
        ULog.d(TAG, "goChargerEndStatisticInfoHandle stop_inspect_statistic " + cacheFlag);
        if (cacheFlag == 1) {
            //巡检次数统计
            float inspectMile = Math.abs(mDistance - startStatisticLocation);
            int cacheDir = UPreferences.getInt(mActivity, "stop_inspect_statistic_dir", 0);
            if (inspectMile >= AutoMoveManager.maxRFIDDistance / 2) {
                if (cacheDir == MOVE_END) {
                    statisticToMapEnd("退出巡检回充结束");
                } else if (cacheDir == MOVE_FRONT) {
                    statisticToMapHead("退出巡检回充结束");
                }
                if (InspectManager.getHeadEndReportFlag()) { //头尾条件都已达成，只差偏差计算
                    InspectManager.handledVarianceFlag();
                }
            }
        }
        UPreferences.putInt(mActivity, "stop_inspect_statistic", 0);
        if (mDistance < 0.11 || mDistance > AutoMoveManager.maxRFIDDistance) {
            ULog.d(TAG, "回充电桩结束 toMapEndNum " + toMapEndNum + " toMapHeadNum " + toMapHeadNum);
            toMapEndNum = 0;
            toMapHeadNum = 0;
            StorageCenter.getRobotStorage().putInteger(UConstants.PREFERENCES_INSPECTION_TO_END_NUM_KEY, toMapEndNum);
            StorageCenter.getRobotStorage().putInteger(UConstants.PREFERENCES_INSPECTION_TO_HEAD_NUM_KEY, toMapHeadNum);
        }
    }
    //回充结束后的操作
    public void goChargerEndHandle() {
        removeHindranceRetryMsg();
        updateHistoryTime(TimeType.ROBOT_REACH_CHARGER_TIME, "4");

        ULog.d(TAG, "onStmReceiveData:  ===== 回充电桩结束 MODE = " + MODE);

        //记录下充电桩的位置作为参考
        if (AutoMoveManager.mTargetChargerNodeW != null) {
            AutoMoveManager.mTargetChargerNodeW.recordChargerLocation(mDistance);
        }
        if (MODE != MODE_BATCH_PRODUCTION_TEST && MODE != MODE_AGING_TEST) {
            setMode(MODE_UN_KNOW, "正常模式-回充结束");
        }
        mMotorAlertCount = 0;
        if (RobotActionCode.isHindranceCode(mBotInfoMgr.getRobotActionCode())) {
            mHandler.removeMessages(Msg.WHAT_QUIT_MOVE_HINDER_STATUS);
            mHandler.sendEmptyMessage(Msg.WHAT_QUIT_MOVE_HINDER_STATUS);
        }
        setStmTarget(StmTask.TARGET_CANCEL, "8");
        AutoMoveManager.setChargerTarget = false;
        stmExecute.executeTaskNonQueue(new StmTask().stopMove("回充电桩结束 46"));
        RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_GO_CHARGER_END));
        setSpeed(UConstants.DEFAULT_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_19);
        ULog.d(TAG, "onStmReceiveData: 回充电桩结束 22222 ");
        setInCharger(true,"回充电桩结束");
        isSleepTip = false;
        {  //运动阻碍后能否回充标识
            moveHinderLowPower = true;
            moveHinderNetDisconnect = true;
            UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_LOW_POWER_GO_CHARGER_KEY, true);
            UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NET_DISCONNECT_GO_CHARGER_KEY, true);
        }
        clearHeadTailInspectFlag();
        UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 1);
        isCloseRepeatCharge = false;//置为false
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_ROBOT_FORCE_CLOSE_CHARGING_KEY, false);

        //        SpeedDetector.getInstance().setStopMove(true);

        RobotConfigParams params = getRobotConfigParams();
        boolean goChargerEndDisablePush = params.getGoChargerEndDisablePush();
        ULog.d(TAG, "回充结束后是否关闭推流 " + goChargerEndDisablePush);
        if (!goChargerEndDisablePush) {
            updateRobotPushEnable(!goChargerEndDisablePush, "0");
        } else {
            mHandler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    updateRobotPushEnable(!goChargerEndDisablePush, "1");
                }
            }, 6000);
        }
        //isNeedCheckAruco的情况下不需要检测平均值异常
        if (isNeedCheckTemperatureException(autoMoveManager.goChargerDirectionBackup) && !RobotFragment.isNeedCheckAruco) {
            inspectManager.handleException(inspectManager.irRecord);
            inspectManager.handleException(inspectManager.irRecordBack);
        }
        autoMoveManager.goChargerDirectionBackup = 0;

        if (NumberUtil.notNullAndEqual(CicadaRoomController.getInstance().haveRoom(), true) && mDistance <= 4.0f) {
            //有Room
            CicadaRoomController.getInstance().controlDoor(CicadaRoomDoorState.CHARGING);
            RobotStatus.setIsWaitRoomDoorClose(true);
            if (!NumberUtil.notNullAndEqual(RobotInfoManager.getInstance().getRobotConfigParams().getIgnoreRoomControl(),
                    UConstants.VALUE_SWITCH_STATUS_ON)) {
                mMqttManager.broadcastShowInfo("Room正在关门...");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROOM_IS_CLOSING_DOOR);
            }
        }

        //延迟10s再检测
        Utils.postDelayed(() -> {
            checkRfidLost();
        }, 5_000);

        if (needDustingFirst()) {
            //除尘超时
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_OPEN_DUSTING_TIMEOUT, 10_000);
            return;
        }
        goChargerEndHandleNext();
    }

    private void goChargerEndHandleNext() {
        //开始充电
        if (mHandler.hasMessages(Msg.WHAT_END_CHARGING)) {
            mHandler.removeMessages(Msg.WHAT_END_CHARGING);
        }
        int startChargeDelayTime = getRobot().getStartChargeInterval() != null ? getRobot().getStartChargeInterval() : 10;

        ULog.d(TAG, "延迟开始充电 ：" + (startChargeDelayTime * 1000));
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_START_CHARGING, startChargeDelayTime * 1000);

        batteryAutoOff = false;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_BATTERY_AUTO_OFF_KEY, false);
        if (!mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_BATTERY_STATUS, startChargeDelayTime * 1000 + SEND_SMS_NO_CHARGING_TIME);
        }


        //        //上传保存的托辊图片
        //        getExecutorService().execute(new RobotFragment.UploadRollerImg());
        if (!UConstants.isFirstBoot(mActivity)) {
            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_GOTO_CHARGER_END);
            mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.goto_charger_end));
        }


        if (getRobot() != null) {
            if (getRobot().getPowerPercent() >= 30 && !mHandler.hasMessages(Msg.WHAT_UPGRADE_STM_CHECK)) {
                isChargerUpgradeCheck = true;
                stmUpgradeCheckNum = 0;
                rkUpgradeCheckNum = 0;
                upgradeCheck(true, 10, 1);
            }
            if (getInspectEnableThreadNeedExec()) {
                mInspectionEnableThread.start();
            }
            if (!mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_BATTERY_STATUS, SEND_SMS_NO_CHARGING_TIME);
            }
            ULog.d(TAG, "onStmReceiveData:  ===== 回充电桩结束 MODE 222= " + MODE);
//            mHandler.postDelayed(new Runnable() {
//                @Override
//                public void run() {
//                    if (!isStmUpgrade) {
//                        autoMoveManager.checkStmRfidDistance();
//                    }
//                }
//            }, 10000);
            if (MODE == MODE_BATCH_PRODUCTION_TEST && !batch_production_test_in_place && MqttManager.getInstance().isConnected()) {
                MqttCommand mqttCommandInPlace = new MqttCommand();
                mqttCommandInPlace.setSource(getRobot().getId());
                mqttCommandInPlace.setTarget(productionClientId);
                mqttCommandInPlace.setType(MqttCommand.ROBOT_BATCH_PRODUCTION_INDEX_TYPE);
                mqttCommandInPlace.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_12_ACTION);
                mMqttManager.publishMessage(mqttCommandInPlace);
            }
        }

        mIsFirstDustingAfterBoot = false;

//        mHandler.postDelayed(new Runnable() {
//            @Override
//            public void run() {
//                checkStartReclaimer();
//            }
//        }, 5000);
    }

    public void checkStartOrStopReclaimer() {
        if(MODE != MODE_RECLAIMER && MainApp.isReclaimer && !ReclaimerInspection.startIng && isBeltConveyorStart){
            ULog.d(TAG, "Reclaimer 回充结束，开始取料机检测");
            if (!inCharger() && MODE != MODE_GOTO_CHARGER) {
                autoMoveManager.gotoChargerCheck("取料机_回充");
                return;
            }
            if (!inCharger()) return;
            if (isUpgrading()){
                ULog.d(TAG, "Reclaimer 回充结束，开始升级，取消取料机检测 ");
                return;
            }
            ReclaimerInspection.getInstance(RobotFragment.this).startRecognise();
        }
        if (MODE == MODE_RECLAIMER && !isBeltConveyorStart) {
            setMode(MODE_UN_KNOW, "正常模式-checkStartOrStopReclaimer");
        }
    }
    /**
     * 检测通过后 开启除尘
     * 是否需要优先除尘，(如果除尘往复运动距离不等于0不会进污损检测)BY需要先除尘再重新回充,GPIO类型除尘不影响
     *
     * @return
     */
    private boolean needDustingFirst() {
        needOpenDusting = false;
        boolean needDusting = false;
        CleanDeviceInfo cleanDeviceInfo = null;
        Charger curDustingCharger = null;
        CleanDeviceInfo robotCleanDeviceInfo = mSensorManager.cacheInfo().CLEAN_DEVICE;
        if (AutoMoveManager.mTargetChargerNodeW != null) {
            curDustingCharger = autoMoveManager.mTargetChargerNodeW.getCharger();
            if (curDustingCharger != null) {
                cleanDeviceInfo = SensorInfoProvider.of(curDustingCharger.getId()).cacheInfo().CLEAN_DEVICE;
            }
        }

        int startChargeDelayTime = getRobot().getStartChargeInterval() != null ? getRobot().getStartChargeInterval() : 10;
        mLastCleanDeviceTimestamp = getLastOpenDustingTimestamp();
        boolean checkRgbSharpness = getRobotConfigParams().isCheckRgbSharpness();
        Integer maxReCheckRgbSharpnessNum = getRobotConfigParams().getMaxReCheckRgbSharpnessNum();
        int openDustingPowerThreshold = getRobotConfigParams().getOpenDustingPowerThreshold();
        long dustingInterval = TimeUnit.MINUTES.toMillis(getRobotConfigParams().getDustingInterval());
        long dustingTimeDiff = System.currentTimeMillis() - mLastCleanDeviceTimestamp;
        boolean powerEnough = getRobot().getPowerPercent() > openDustingPowerThreshold;
        boolean timeEnough = dustingTimeDiff > dustingInterval;
        int checkRounds = RgbSharpnessChecker.getInstance().getCheckRounds();
        Integer backwardDis = null;
        if(cleanDeviceInfo != null){
            backwardDis = cleanDeviceInfo.getBackwardDistance();
        }
        ULog.i(TAG, "除尘 =="
                + "  当前电量：" + getRobot().getPowerPercent()
                + ", 除尘电量阈值：" + openDustingPowerThreshold
                + ", 除尘间隔设置：" + dustingInterval
                + ", 距离上次间隔：" + dustingTimeDiff
                + ", 电量是否满足：" + powerEnough
                + ", 时间是否满足：" + timeEnough
                + ", 除尘类型：" + (cleanDeviceInfo != null ? cleanDeviceInfo.getType() : "null")
                + ", 除尘往复运动距离：" + backwardDis
                + ", 是否检测镜头污损：" + checkRgbSharpness
                + ", 最大污损检测轮次：" + maxReCheckRgbSharpnessNum
                + ", 镜头污损阈值：" + getRobotConfigParams().getRgbLensDirtyThreshold()
                + ", 已检测污损检测轮次：" + checkRounds
                + ", 机器人除尘配置：" + (robotCleanDeviceInfo != null ? gson.toJson(robotCleanDeviceInfo) : "null"));
        boolean flag = false;//如果检测镜头污损 且除尘往复移动距离为0 且检测轮次大于0 就表示已经开始检测污损的流程就可以直接进入除尘
        if(checkRgbSharpness && (backwardDis == null || backwardDis == 0) && checkRounds > 0) {
            flag = true;
        }else{
            flag = timeEnough && powerEnough;
        }

        if (mBotInfoMgr.isHaveSteer()) {
            SteerController.getInstance().rotateToDustingAngle();
        }
        if (robotCleanDeviceInfo != null && !robotCleanDeviceInfo.isEnabled()) {
            needOpenDusting = false;
            return needDusting;
        }
        if (cleanDeviceInfo == null || (cleanDeviceInfo.getType().equals("0") && cleanDeviceInfo.isEnabled())) {
            //没配置除尘或配置的GPIO除尘
            if (flag  && !mIsFirstDustingAfterBoot) {
                //开始除尘
                if (mHandler.hasMessages(Msg.WHAT_END_DUSTING)) {
                    mHandler.removeMessages(Msg.WHAT_END_DUSTING);
                }

                ULog.d(TAG, "延迟开始除尘 ：" + (startChargeDelayTime * 1000L));
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_START_DUSTING, startChargeDelayTime * 1000L);
                mLastCleanDeviceTimestamp = System.currentTimeMillis();
                saveLastOpenDustingTimestamp(mLastCleanDeviceTimestamp);
            }

        } else if (NumberUtil.inArray(cleanDeviceInfo.getType(), false, CleanDeviceType.type_2, CleanDeviceType.type_3, CleanDeviceType.type_4) && cleanDeviceInfo.isEnabled()) {

            //By安全屋 有水箱/无水箱版本
            if (flag && !mIsFirstDustingAfterBoot) {
                long timeDiff = System.currentTimeMillis() - mLastCleanDeviceTimestamp;

                needOpenDusting = inCharger()
                        && autoMoveManager.mCurrentNode != null && timeDiff > Math.max(mLastDustingDurationMillSeconds * 2.5f, 120_000);

                ULog.i(TAG, "BY安全屋 时间差：" + timeDiff + ",mCurrentNode:" + autoMoveManager.mCurrentNode + "," +
                        "本次是否开除尘:" + needOpenDusting);

                if (needOpenDusting) {
                    mHandler.sendEmptyMessage(Msg.WHAT_START_DUSTING);
                    needDusting = true;
                }
            }

        }
        return needDusting;
    }

    //回充到位后是否需要校正里程
    private boolean getInPlaceCorrect(Charger curDustingCharger) {
        if (curDustingCharger == null) {
            return false;
        }
        CleanDeviceInfo cleanDeviceInfo = SensorInfoProvider.of(curDustingCharger.getId()).cacheInfo().CLEAN_DEVICE;
        if (cleanDeviceInfo == null || !NumberUtil.inArray(cleanDeviceInfo.getType(), false, CleanDeviceType.type_2, CleanDeviceType.type_3, CleanDeviceType.type_4) || !cleanDeviceInfo.isEnabled()) {
//            ULog.e(TAG, "没有安全屋，不进入除尘模式");
            return false;
        }
        return cleanDeviceInfo.getBackwardDistance() != 0;
    }
    /**
     * 进入除尘模式
     */
    private void enterDustingMode() {
        CleanDeviceInfo cleanDeviceInfo = null;
        Charger curDustingCharger = null;
        ChargerNodeManager.ChargerNodeWrapper nearestCharger = AutoMoveManager.mTargetChargerNodeW;

        if (nearestCharger == null) {
            ULog.i(TAG, "未计算到最近的充电桩，不进入除尘模式");
            return;
        }

        curDustingCharger = nearestCharger.getCharger();
        if (curDustingCharger != null) {
            cleanDeviceInfo = SensorInfoProvider.of(curDustingCharger.getId()).cacheInfo().CLEAN_DEVICE;
        }

        if (cleanDeviceInfo == null || !NumberUtil.inArray(cleanDeviceInfo.getType(), false, CleanDeviceType.type_2, CleanDeviceType.type_3, CleanDeviceType.type_4) || !cleanDeviceInfo.isEnabled()) {
            ULog.e(TAG, "没有安全屋，不进入除尘模式");
            return;
        }

        //Cicada机型需要来回移动
        ULog.i(TAG, "BY安全屋除尘 开始_sensor_control getBackwardDistance " + cleanDeviceInfo.getBackwardDistance());
        checkDustingSprayWater();
        backwardDistanceIsZero = cleanDeviceInfo.getBackwardDistance() == 0;

        long dustDuration = TimeUnit.MINUTES.toMillis(7);
        if (curDustingCharger.getEstimateDustingDuration() != null) {
            dustDuration = curDustingCharger.getEstimateDustingDuration() * 1000;
        }

        Message obtain = Message.obtain();
        obtain.what = Msg.WHAT_SELF_CYCLE_CLEAN_END_HANDLE;
        obtain.obj = 1;
        ULog.d(TAG,"RgbSharpnessChecker_TEST 倒计时:"+dustDuration+"后自动除尘完成");
        mHandler.sendMessageDelayed(obtain, dustDuration);
        if (backwardDistanceIsZero) {
            ULog.d(TAG, "往复运动为0，机器人不进除尘模式");
            return;
        }
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        setInCharger(false,"进入除尘开始往复运动");
        UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
        setStmTarget(StmTask.TARGET_CLEAN,"9");
        setSpeed(UConstants.DEFAULT_GOTO_CHARGER_SPEED, "Clean");
        stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
        mLastCleanDeviceTimestamp = System.currentTimeMillis();
        mHandler.removeMessages(Msg.WHAT_START_CHARGING);
        mHandler.removeMessages(Msg.WHAT_CHECK_BATTERY_STATUS);

        mLastCleanDeviceTimestamp = System.currentTimeMillis();
        saveLastOpenDustingTimestamp(mLastCleanDeviceTimestamp);

        //关闭避障
        ObstacleController.getInstance().setObstacleOn(false,"16");

        if (nearestCharger.getNode().getType() == NodeType.HEAD_CHARGE) {
            mDustingDistanceMax = cleanDeviceInfo.getFrontDustingMaxDistance();
        } else if (nearestCharger.getNode().getType() == NodeType.TEMPORARY_CHARGE) {
            mDustingDistanceMax = cleanDeviceInfo.getDustingMaxDistance();
        }
        mDustingDistanceMin =
                mDustingDistanceMax - cleanDeviceInfo.getBackwardDistance() / 100.0f;

        mLastDustingDurationMillSeconds = dustDuration;

        setMode(MODE_DEVICE_CLEAN, "除尘模式-进入除尘模式");
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SELF_CYCLE_CLEAN_END_HANDLE, dustDuration);
        ULog.i(TAG,
                "BY安全屋除尘,充电桩：" + nearestCharger + ",除尘持续时间：" + dustDuration + "，最小里程：" + mDustingDistanceMin + "，最大里程：" + mDustingDistanceMax);
    }

    public void checkRfidLost() {
        mIsCheckingRfidLost = true;
        //发短信和向手机端发送mqtt
        List<RfidNode> loseRfidNodes = RfidLostChecker.getInstance().checkLostNodeList();
        if (loseRfidNodes == null || loseRfidNodes.size() == 0) {
            ULog.d(TAG, "未检测到标签丢失");
            mIsCheckingRfidLost = false;
            return;
        }

        for (RfidNode node : loseRfidNodes) {
            ULog.d(TAG, "标签丢失：" + node.getId() + ",rfidTag=" + node.getRfidTag() + ", distance=" + node.getDistance());
        }

        //        StringBuilder sb = new StringBuilder("标签丢失位置为 ");
        //        sb.append(StrUtil.join(loseRfidNodes, "，", RfidNode::getName));
        //对手机端进行提示
        //        mMqttManager.broadcastShowInfo(sb.toString());

        autoMoveManager.updateLoseRfidToServer(loseRfidNodes);

    }


    private long getLastOpenDustingTimestamp() {
        return UPreferences.getLong(MainApp.getInstance(), UConstants.KEY_LAST_OPEN_DUSTING_TIMESTAMP, 0);
    }

    public void saveLastOpenDustingTimestamp(long timestamp) {
        UPreferences.putLong(MainApp.getInstance(), UConstants.KEY_LAST_OPEN_DUSTING_TIMESTAMP, timestamp);
    }


    public void checkUpgradeInCharger() {
        if (getRobot() != null && getRobot().getPowerPercent() >= 30 && !mHandler.hasMessages(Msg.WHAT_UPGRADE_STM_CHECK)) {
            isChargerUpgradeCheck = true;
            stmUpgradeCheckNum = 0;
            rkUpgradeCheckNum = 0;
            upgradeCheck(true, 11, 1);
        }
    }

    private void setStandardGasValue(String standardGasValueJson, int type, double value) {
        GasBoardStandardGasValue gasBoardStandardGasValue = null;
        try {
            gasBoardStandardGasValue = UGson.getGson().fromJson(standardGasValueJson, GasBoardStandardGasValue.class);
        } catch (JsonParseException e) {
            e.printStackTrace();
        }
        if (gasBoardStandardGasValue == null) {
            gasBoardStandardGasValue = new GasBoardStandardGasValue();
        }
        switch (type) {
            case 0://甲烷
                gasBoardStandardGasValue.setCh4StandardGasValue(value);
                break;
            case 1://一氧化碳
                gasBoardStandardGasValue.setCoStandardGasValue(value);
                break;
            case 2://二氧化碳
                gasBoardStandardGasValue.setCo2StandardGasValue(value);
                break;
            case 3://氧气
                gasBoardStandardGasValue.setO2StandardGasValue(value);
                break;
            default:
                break;
        }
        if (getRobot() != null) {
            getRobot().setStandardGasValue(UGson.getGson().toJson(gasBoardStandardGasValue));
        }
    }

    long lowePowertime;
    //最后一次触发排班巡检时间
    long lastStartScheduledInspectionTime = 0;
    long showInfoLowePower;
    @Override
    public void onBmsDataReceived(BmsDataEvent dataEvent) {
        if (getRobot() == null || mRobotType == null) {
            return;
        }

        switch (dataEvent.getAction()) {
            case BmsDataActionConstants.ACTION_QUERY_SINGLE_VOLTAGE_RESULT:
                batteryVoltageList.clear();
                batteryVoltageList.addAll(dataEvent.getSingleVoltageList());
                break;

            case BmsDataActionConstants.ACTION_QUERY_DETAIL_RESULT: {
                BmsDataDetail bmsDataDetail = dataEvent.getBmsDataDetail();
                mCurrent = (short) bmsDataDetail.getCurrent();
                int batteryPercent = bmsDataDetail.getLeftPercent();
                float batteryVoltage = bmsDataDetail.getTotalVoltage();
                RobotBluetoothManager.batteryPercent = batteryPercent;
                RobotBluetoothManager.batteryTotalVoltage = batteryVoltage;
                RobotBluetoothManager.batteryCurrent = mCurrent;
                if (bmsDataDetail.getNtcNum() >= 2 && mCurrent >= 0) {
                    MainApp.BMS_TEMP = bmsDataDetail.getNtcTemps().get(1);
                    int heatStatus = MainApp.BMS_IS_OPEN_HEAT();
                    if (heatStatus == 1 || heatStatus == 0) {
                        MainApp.BMS_HEAT_STATUS = heatStatus;
                        UPreferences.putInt(mActivity, UConstants.PREFERENCES_BMS_HEAT, MainApp.BMS_HEAT_STATUS);
                    }
                } else if (MainApp.BMS_HEAT_STATUS != 0) {
                    MainApp.BMS_HEAT_STATUS = 0;
                    UPreferences.putInt(mActivity, UConstants.PREFERENCES_BMS_HEAT, 0);
                }

                if (getRobot() != null) {
                    getRobot().setRemainBattery(bmsDataDetail.getLeftCapability());
                    getRobot().setPowerVoltage(bmsDataDetail.getTotalVoltage());
                    getRobot().setBatteryCurrent((double) bmsDataDetail.getCurrent());
                    getRobot().setCharging(mCurrent >= 0);


                    String isChargering = UPreferences.getString(mActivity, UConstants.PREFERENCES_IS_CHARGERING_KEY, "");
                    Log.i(TAG, "updateHistoryTime-check=isChargering=" + isChargering);
                    if (mCurrent >= 0) {
                        //正在充电中
                        if ("".equals(isChargering) || "0".equals(isChargering)) {
                            UPreferences.putString(mActivity, UConstants.PREFERENCES_IS_CHARGERING_KEY, "1");
                            updateHistoryTime(TimeType.CHARGER_START_CHARGING_TIME, "2");
                        }
                        if (mLastBmsInfoTime != UConstants.UNKONW) {
                            if (MainApp.mStInfo.getChargingTotalTime() < 0) MainApp.mStInfo.setChargingTotalTime(0);

                            long timeDiff = System.currentTimeMillis() - mLastBmsInfoTime;
                            if (timeDiff > 0 && timeDiff < 20 * 60_000) {
                                MainApp.mStInfo.setChargingTotalTime(MainApp.mStInfo.getChargingTotalTime() + timeDiff);
                            } else {
                                ULog.d(TAG, "充电时间变化较大 不记入总充电时长 上次 " + mLastBmsInfoTime + " 当前 " + System.currentTimeMillis() + " 差值 " + timeDiff);
                            }
                            StorageCenter.getRobotStorage().putLong(UConstants.PREFERENCES_CHARGING_TOTAL_TIME_KEY, MainApp.mStInfo.getChargingTotalTime());
                        }
                        mLastBmsInfoTime = System.currentTimeMillis();

                        Optional<Float> minV = batteryVoltageList.stream().min(Comparator.naturalOrder());
                        if (minV != null && minV.get() != null) {
                            if (MainApp.batteryCheckStatus != 0 && minV.get() >= 4.15 && mCurrent <= 1500) {
                                ULog.d(TAG, "BMS_check 检测到电池电压大于4.15v 完成满充");
                                MainApp.batteryCheckStatus = 0;
                                StorageCenter.getRobotStorage().putInteger(KeyConstant.Storage.BATTERY_CHECK_STATUS, 0);
                            }
                        }
                    } else {
                        //未在充电
                        if ("".equals(isChargering) || "1".equals(isChargering)) {
                            UPreferences.putString(mActivity, UConstants.PREFERENCES_IS_CHARGERING_KEY, "0");
                            updateHistoryTime(TimeType.CHARGER_STOP_CHARGING_TIME, "3");
                        }
                        mLastBmsInfoTime = UConstants.UNKONW;

                        Optional<Float> minV = batteryVoltageList.stream().min(Comparator.naturalOrder());
                        if (minV != null && minV.get() != null) {
                            if (MainApp.checkBMSStatus) {
                                float estimateBattery = UConstants.getBatteryPercentByVolt(minV.get());
                                MainApp.batteryCheckStatus = StorageCenter.getRobotStorage().getInteger(KeyConstant.Storage.BATTERY_CHECK_STATUS, 0);
                                ULog.d(TAG, "BMS_check minVolt 最小电压 " + minV.get() + " 估算电量 " + estimateBattery + " 实际电量 " + batteryPercent + " batteryCheckStatus " + MainApp.batteryCheckStatus);
                                if (batteryPercent - estimateBattery >= 20 && MainApp.batteryCheckStatus == 0) {
                                    ULog.d(TAG, "BMS_check 检测到电池电量值不准确 需要满放满充");
                                    MainApp.batteryCheckStatus = 1;
                                    StorageCenter.getRobotStorage().putInteger(KeyConstant.Storage.BATTERY_CHECK_STATUS, 1);
                                }
                            }
                            if (MainApp.batteryCheckStatus == 1 && minV.get() < 3) {
                                ULog.d(TAG, "BMS_check 最小单体电压小于3V, 应进入满充阶段 inCharger " + inCharger + " CHECK_BATTERY_STATUS " + (!mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)));
                                MainApp.batteryCheckStatus = 2;
                                StorageCenter.getRobotStorage().putInteger(KeyConstant.Storage.BATTERY_CHECK_STATUS, 2);
                                if (inCharger && !mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
                                    ULog.d(TAG, "BMS_check 准备进入满充阶段 发送开始充电");
                                    mHandler.sendEmptyMessage(Msg.WHAT_START_CHARGING);
                                }
                            }
                        }
                    }

                    if (mCurrent >= 0 && inCharger()) {
                        //重置寻找到位开关次数
                        repeatFindInPlaceNum = 0;

                        if (mAlarmManager.getIsAlarmReported(AlarmTypeEnum.ROBOT_IN_PLACE_SWITCH)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_IN_PLACE_SWITCH_RESUME));
                            mAlarmManager.setIsAlarmReported(AlarmTypeEnum.ROBOT_IN_PLACE_SWITCH, false);
                        }
                    }

                    if (mIsWaitToLeaveCharger && !getRobot().getCharging()) {
                        RxBus.getInstance().post(new RobotChargeEvent(RobotEventConstants.EVENT_CLOSE_CHARGER_SUCCESS));
                    }

                    if (mSensorManager.cacheInfo().BMS_INFO != null) {
                        HashMap<String, String> valuesMap = new HashMap<>();
                        valuesMap.put(BmsConfigConstants.Values.VALUE_TOTAL_VOLTAGE, String.valueOf(bmsDataDetail.getTotalVoltage()));
                        valuesMap.put(BmsConfigConstants.Values.VALUE_CURRENT, String.valueOf(bmsDataDetail.getCurrent()));
                        valuesMap.put(BmsConfigConstants.Values.VALUE_POWER_PERCENT, String.valueOf(bmsDataDetail.getLeftPercent()));
                        updateSensorData(SensorType.SENSOR_TYPE_BMS, "", mSensorManager.cacheInfo().BMS_INFO.getInstallPosition(), "1",
                                mSensorManager.cacheInfo().BMS_INFO.getType(), valuesMap);
                    }

                    RobotConfigParams robotConfigParams = getRobotConfigParams();
                    isFullBattery = (checkHigherBatteryVoltage(getRobot().getBatteryMaxVoltage()).getResult() || mCurrent == 0) && batteryPercent >= 95;
                    if (batteryVoltageList.size() != 0) {
                        ULog.d(TAG, "onBMSReceiveData:开始检查是否回充 电压阈值:" + voltageLow + "V, 单体电压:" + getBatterySingleVoltage() + " powerKey电压阈值:" + robotConfigParams.getPowerKeyVoltageThreshold()+"V, 低电量阈值 " + getRobot().getLowPowerThreshold());
                        //检查电压 - 电量小于阈值并且电压小于3.2V 回充
                        if (getRobot().getLowPowerThreshold() != null) {
                            isLowPowerGoTocharger = (batteryPercent < getRobot().getLowPowerThreshold() || checkLowerBatteryVoltage(voltageLow).getResult()) && mCurrent < 0 && !inCharger();
                            if (isLowPowerGoTocharger && MODE != MODE_GOTO_CHARGER) {
                                ULog.d(TAG, "onBMSReceiveData:  == 开始检查低电压 == 低电量或低电压去充电桩 moveHinderNeedSleep " + moveHinderNeedSleep + " moveHinderLowPower " + moveHinderLowPower);
                                if (RobotBluetoothManager.getInstance().isConnect()) {
                                    ULog.w(TAG, "bluetooth 蓝牙连接中，取消低电量回充！");
                                } else if (MODE == MODE_AUTO_BUILD_MAP) {
                                    ULog.d(TAG, "自动建图中，忽略低电量回充 " + showInfoLowePower);
                                    if (System.currentTimeMillis() - showInfoLowePower > 60_000) {
                                        mMqttManager.broadcastShowInfo("机器人电量或电压过低，请及时充电");
                                        showInfoLowePower = System.currentTimeMillis();
                                    }
                                } else if (MapManager.getInstance().getRfidNodeList().size() == 0) {
                                    ULog.w(TAG, "尚未获取到地图，暂不回充");
                                } else if (MODE == MODE_DEVICE_CLEAN) {
                                    ULog.d(TAG, "正在除尘中，忽略低电量回充");
                                } else if (mBotInfoMgr.getRobotActionCode() == RobotActionCode.STATUS_WAITING && mBotInfoMgr.getRobotActionReason() != RobotActionCode.Stop.IR_INIT_STOP) {
                                    //红外初始化不应该影响回充功能
                                    ULog.w(TAG, "机器人处于等待状态，暂不回充，等待原因：" + mBotInfoMgr.getRobotActionReason());
                                } else if (!isInitializedFinished()) {
                                    ULog.w(TAG,"低电量回充 == 机器人尚未初始化完成");
                                } else if (moveHinderNeedSleep && !moveHinderLowPower) {
                                    ULog.w(TAG,"低电量回充 == 运动阻碍，等待人为控制，不执行回充逻辑");
                                } else {
                                    if (moveHinderNeedSleep) {
                                        moveHinderLowPower = false;
                                        UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_LOW_POWER_GO_CHARGER_KEY, false);
                                    }
                                    boolean gotoCharger = true;

                                    if (mHandler.hasMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING)) {
                                        if (!mHasTriedGoChargerAfterMotorStall) {
                                            mHasTriedGoChargerAfterMotorStall = true;
                                            removeHindranceRetryMsg();
                                        } else {
                                            ULog.d(TAG, "发生过运动阻碍且尝试过回充失败，不再回充");
                                            gotoCharger = false;
                                        }
                                    }

                                    if (gotoCharger) {
                                        if (!mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
                                            if (inCharger()) {
                                                ULog.d(TAG, "低电量回充");
                                                setInCharger(false,"低电量回充");
                                                UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
                                            }
                                        }
                                        MainApp.bEnable = false;
                                        autoMoveManager.gotoChargerCheck("bms低电量_回充");
                                        //通知手机端机器人触发了低电量回充
//                                    getExecutorService().execute(new LowPowerGotoChargerEnable());
                                    }
                                }
                            }
                        }

                        ULog.d(TAG, "onBMSReceiveData: 开始检查极端电压  阈值: 极高("+veryHighSingleVoltage+"v) 极低("+veryLowSingleVoltage+"v)");
                        //极低电压或极高电压 关机报警
                        CheckBatteryVoltageResult checkVeryHighSingleVoltage = checkHigherBatteryVoltage(veryHighSingleVoltage);
                        CheckBatteryVoltageResult checkVeryLowSingleVoltage = checkLowerBatteryVoltage(veryLowSingleVoltage);

                        if (checkVeryHighSingleVoltage.getResult()) {
                            //报警
                            ULog.d(TAG, "onBMSReceiveData: 单体电池高电压超阈值 累计次数:"+getAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_OVER_VOLTAGE_EXCEPTION)+1 +
                                    " 需要触发报警次数:"+mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_OVER_VOLTAGE_EXCEPTION));
                            if (addAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_OVER_VOLTAGE_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_OVER_VOLTAGE_EXCEPTION)) {
                                List<String> params = new ArrayList<String>();
                                params.add(getRobot().getName());//机器人名称
                                params.add(getSensorAlarmFirstParam());//位置信息
                                params.add(String.valueOf(FormatUtils.keepDecimals(checkVeryHighSingleVoltage.getVal(), 2)));//实际值
                                params.add(String.valueOf(FormatUtils.keepDecimals(veryHighSingleVoltage,2)));//阈值
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_OVER_VOLTAGE_EXCEPTION,params);
                                ULog.d(TAG, "onBMSReceiveData: 单体电池高电压报警 参数:"+params);
                                RxBus.getInstance().post(alertEvent);
                                alarmResume(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_OVER_VOLTAGE_EXCEPTION);//目前本报警不需要恢复报警 报完重置报警次数等下次报
                            }
                            //关机
                            // TODO: 2020/10/17 0017 关机报警
                            // URootCmd.execRootCmdSilent("reboot -p");
                        }else if(checkVeryLowSingleVoltage.getResult()){
                            ULog.d(TAG, "onBMSReceiveData: 单体电池低电压超阈值 累计次数:"+getAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_UNDER_VOLTAGE_EXCEPTION)+1 +
                                    " 需要触发报警次数:"+mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_UNDER_VOLTAGE_EXCEPTION));
                            if (addAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_UNDER_VOLTAGE_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_OVER_VOLTAGE_EXCEPTION)) {
                                List<String> params = new ArrayList<String>();
                                params.add(getRobot().getName());//机器人名称
                                params.add(getSensorAlarmFirstParam());//位置信息
                                params.add(String.valueOf(FormatUtils.keepDecimals(checkVeryLowSingleVoltage.getVal(), 2)));//实际值
                                params.add(String.valueOf(FormatUtils.keepDecimals(veryLowSingleVoltage,2)));//阈值
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_UNDER_VOLTAGE_EXCEPTION,params);
                                ULog.d(TAG, "onBMSReceiveData: 单体电池低电压报警 参数:"+params);
                                RxBus.getInstance().post(alertEvent);
                                alarmResume(AlarmTypeEnum.ROBOT_BATTERY_SINGLE_UNDER_VOLTAGE_EXCEPTION);//目前本报警不需要恢复报警 报完重置报警次数等下次报
                            }
                        }
                    }

                    if (batteryPercent <= 100) {
                        getRobot().setPowerPercent(batteryPercent);
                        boolean isReclaimerDynamic = MainApp.isReclaimer && !isBeltConveyorStart && MODE != MODE_RECLAIMER;
                        ULog.d(TAG, "onBMSReceiveData:  ====== getRobot().getChargeStrategy()=" + getRobot().getChargeStrategy() +
                                "   mCurrent=" + mCurrent + "   batteryPercent=" + batteryPercent + "   inCharger" + inCharger() +
                                "   isSleep=" + isSleep + " isSoftEmergencyStop " + isSoftEmergencyStop + "  Corn: " + getRobot().getCornExpress() + " isReclaimerDynamic: " + isReclaimerDynamic + " checkBMSStatus " + MainApp.checkBMSStatus + " batteryCheckStatus " + MainApp.batteryCheckStatus);

                        if ((isReclaimerDynamic || getRobot().getChargeStrategy() == ChargingStrategy.INSPECTION_LOW_POWER_CHARGING_FULL) && isFullBattery && inCharger() && !isSleep && !isSoftEmergencyStop && MainApp.isBmsCheckPass()) {
                            ULog.d(TAG, "电量大于95，强制巡检 网络状态 " + serverHeartNormal);
                            if (serverHeartNormal && isInitializedFinished()) {
                                MqttCommand startCommand = new MqttCommand();
                                startCommand.setSource("self");
                                startCommand.setTarget(getRobot().getId());
                                startCommand.setType(MqttCommand.ROBOT_INSPECTION_INDEX_TYPE);
                                startCommand.setAction(MqttCommand.ROBOT_INSPECTION_FORCE_ACTION);
                                onMessageReceived(startCommand);
                            }
                        }

                        if ((MainApp.isArrangeInspect(getRobot().getChargeStrategy()) && !TextUtils.isEmpty(
                                getRobot().getCornExpress()))
                                && batteryPercent >= getRobot().getInspectionPowerThreshold()
                                && inCharger() && !isSleep && !isSoftEmergencyStop && !MainApp.isEntryPowerSaveModeDelaying()) {
                            //设置排班巡检、且Crontab表达式不为空，且充满电（电量百分比超过或等于95）,且在充电桩,且非休眠，开启排班巡检


                            //范例：00 00 14-17/1 * * ?   意思是每天下午2点到5点，每个小时执行一次；    00 0/10 14-17 * * ?   意思是每天下午2点到5点，每10分钟执行一次；
                            if (isInitializedFinished() && MODE != MODE_INSPECTION && MODE != MODE_CHECKING_STOP) {
                                if (!mHandler.hasMessages(Msg.WHAT_START_SCHEDULED_INSPECTION) && (System.currentTimeMillis() - lastStartScheduledInspectionTime) > 40_000) {
                                    if (!checkArrangeInspection(false) && !isUpgrading) {
                                        if (nextArrangeDate != 0) {
                                            long delay = 0;
                                            if (nextArrangeDate < System.currentTimeMillis()) {
                                                delay = 2_000;
                                            } else {
                                                delay = nextArrangeDate - System.currentTimeMillis();
                                            }
                                            ULog.d(TAG, "符合排班条件，强制巡检 倒计时 = " + (delay / 1000) + "秒 lastStartScheduledInspectionTime = " + lastStartScheduledInspectionTime);
                                            lastStartScheduledInspectionTime = System.currentTimeMillis();
                                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_START_SCHEDULED_INSPECTION,
                                                    delay);
                                        }
                                    }
                                }
                            }
                        }
                        if (MODE == MODE_AGING_TEST) {
                            if (batteryPercent > 90 && inCharger() && getRobot().getCharging()) {
                                agingTestGoTOCharger = false;
                                setRobotDirection(StmTask.MOVE_END,"13");
                                stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                            }
                        }
                    }
                    if (getRobot().getCharging() && getIsAlarmReported(AlarmTypeEnum.ROBOT_CANNOT_CHARGE)) {
                        //恢复充电 短信提醒
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_CANNOT_CHARGE_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_CANNOT_CHARGE, false);
                    }
                    if (batteryPercent < 15 && mCurrent < 0) {
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_LOWER_THAN_15) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_LOWER_THAN_15)) {
                            if ((System.currentTimeMillis() - lowePowertime) > 5 * 60_000) {
                                lowePowertime = System.currentTimeMillis();
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_LOWER_THAN_15));
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_LOWER_THAN_15, true);
                            }
                        }
                    }

                    if (batteryPercent <= 20 && mCurrent < 0 && getRobot() != null
                            && (RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_FB || RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_MA)
                            && ChargerNodeManager.getInstance().getAllBindChargers() != null
                            && ChargerNodeManager.getInstance().getBindActiveChargers().size() == 0
                            && NumberUtil.notNullAndEqual(CicadaRoomController.getInstance().haveRoom(), false)) {
                        if (addAlarmCount(AlarmTypeEnum.BATTERY_REPLACE_REMIND) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.BATTERY_REPLACE_REMIND)) {
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.BATTERY_REPLACE_REMIND);
                            List<String> params = new ArrayList<>();
                            params.add(batteryPercent + "");
                            alertEvent.setParams(params);
                            RxBus.getInstance().post(alertEvent);
                        }
                    }
                    ULog.d(TAG,
                            "upgrade = batteryPercent " + batteryPercent + " mCurrent " + mCurrent + " inCharger " + inCharger() + " needOpenDusting " + needOpenDusting + " Msg.WHAT_UPGRADE_STM_CHECK " + mHandler.hasMessages(
                                    Msg.WHAT_UPGRADE_STM_CHECK) + " isChargerUpgradeCheck " + isChargerUpgradeCheck);
                    if (batteryPercent > 30 && mCurrent >= 0 && inCharger() && !needOpenDusting) {
                        if (!mHandler.hasMessages(Msg.WHAT_UPGRADE_STM_CHECK) && !isChargerUpgradeCheck) {
                            isChargerUpgradeCheck = true;
                            stmUpgradeCheckNum = 0;
                            rkUpgradeCheckNum = 0;
                            //                                        updateStmCheck();
                            upgradeCheck(true, 12, 1);
                        }
                    }
                    boolean powerKeyVoltage = checkLowerBatteryVoltage(robotConfigParams.getPowerKeyVoltageThreshold()).getResult();
                    if (powerKeyVoltage && mCurrent < 0) {
                        powerKeyLowVoltageNum++;
                        ULog.d(TAG, "低电量关机 == 电量 = " + batteryPercent + " 电流 = " + mCurrent + " num " + powerKeyLowVoltageNum);
                        if (powerKeyLowVoltageNum >= 5) {
                            stmExecute.executeTaskNonQueue(new StmTask().stopMove("低电量关机 47"));
                            mHandler.postDelayed(new Runnable() {
                                @Override
                                public void run() {
                                    isPowerKey = true;
                                    stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_POWER_CONTROL,
                                            UConstants.VALUE_SWITCH_STATUS_OFF));
                                    stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_SLEEP_WAKEUP_INTERVAL,
                                            60));
                                }
                            }, 5000);
                        }
                    } else {
                        powerKeyLowVoltageNum = 0;
                    }
                    if (MODE == MODE_BATCH_PRODUCTION_TEST) { //量产测试
                        MqttCommand commandBattery = new MqttCommand();
                        commandBattery.setSource(getRobot().getId());
                        commandBattery.setTarget(productionClientId);
                        commandBattery.setType(MqttCommand.ROBOT_BATCH_PRODUCTION_INDEX_TYPE);
                        if (!batch_production_test_power_bms_network) {
                            if (batteryPercent > 0 && batteryPercent <= 100) {
                                commandBattery.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_1_3_ACTION);
                                if (MqttManager.getInstance().isConnected()) {
                                    MqttManager.getInstance().publishMessage(commandBattery);
                                }
                            } else {
                                commandBattery.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_SHOW_INFO_ACTION);
                                commandBattery.setValue("电池电量异常");
                                if (MqttManager.getInstance().isConnected()) {
                                    MqttManager.getInstance().publishMessage(commandBattery);
                                }
                            }
                        }
                        if (!batch_production_test_wired_charging && test_wired_charging) {
                            commandBattery.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_SHOW_INFO_ACTION);
                            if (mCurrent > 0) {
                                commandBattery.setValue("有线充电成功");
                            } else {
                                commandBattery.setValue("有线充电失败");
                            }
                            if (MqttManager.getInstance().isConnected()) {
                                MqttManager.getInstance().publishMessage(commandBattery);
                            }
                        }
                        if (!batch_production_test_wireless_charging && test_wireless_charging) {
                            commandBattery.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_SHOW_INFO_ACTION);
                            if (mCurrent > 0) {
                                commandBattery.setValue("无线充电成功");
                            } else {
                                commandBattery.setValue("无线充电失败");
                            }
                            if (MqttManager.getInstance().isConnected()) {
                                MqttManager.getInstance().publishMessage(commandBattery);
                            }
                        }
                    }
                }

                //电池过流
                if (Math.abs(mCurrent) < BaseBmsCommunicator.mOverCurrentThreshold * 1000f) {
                    setAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION)) {
                        ULog.i(TAG, "电池电流 异常恢复 mCurrent=" + mCurrent);

                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_CURRENT_EXCEPTION, false);
                    }
                }

                //机器人电池电压超过一定阈值 报警 默认阈值 (电池串数 * 4.25V)
                if (mSensorManager != null && mSensorManager.cacheInfo().BMS_INFO != null) {
                    BmsInfo bmsInfo = mSensorManager.cacheInfo().BMS_INFO;
                    ULog.d(TAG,"onBMSReceiveData: 检查电池整体电压是否过压:"+(batteryVoltage >= bmsInfo.getHighVoltageThreshold()) + " 阈值:"+bmsInfo.getHighVoltageThreshold()+ " 实际值:"+batteryVoltage+
                            " 报警次数:"+getAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION)+" 触发报警次数阈值:"+mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION));
                    ULog.d(TAG,"onBMSReceiveData: 检查电池整体电压是否欠压:"+(batteryVoltage <= bmsInfo.getLowVoltageThreshold())+ " 阈值:"+bmsInfo.getLowVoltageThreshold()+ " 实际值:"+batteryVoltage+
                            " 报警次数:"+getAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION)+" 触发报警次数阈值:"+mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION));

                    if (batteryVoltage >= bmsInfo.getHighVoltageThreshold()) {
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION)) {
                                List<String> params = new ArrayList<String>();
                                params.add(getRobot().getName());//机器人名称
                                params.add(getSensorAlarmFirstParam());//位置信息
                                params.add(String.valueOf(FormatUtils.keepDecimals(batteryVoltage, 2)));//实际电压
                                params.add(String.valueOf(FormatUtils.keepDecimals(bmsInfo.getHighVoltageThreshold(),2)));//过压阈值
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION, params);
                                ULog.w(TAG,"onBMSReceiveData: 电池整体电压过压触发报警 当前电压:"+batteryVoltage +" 报警参数:"+params);
                                RxBus.getInstance().post(alertEvent);
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION, true);
                        }
                        //电池欠压报警
                    }else if(batteryVoltage <= bmsInfo.getLowVoltageThreshold()){
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION)) {
                            List<String> params = new ArrayList<String>();
                            params.add(getRobot().getName());//机器人名称
                            params.add(getSensorAlarmFirstParam());//位置信息
                            params.add(String.valueOf(FormatUtils.keepDecimals(batteryVoltage, 2)));//实际电压
                            params.add(String.valueOf(FormatUtils.keepDecimals(bmsInfo.getLowVoltageThreshold(),2)));//欠压阈值
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION, params);
                            ULog.w(TAG,"onBMSReceiveData: 电池整体电压欠压触发报警 当前电压:"+batteryVoltage);
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION, true);
                        }
                    } else {
                        //报警恢复
                        setAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION, 0);
                        setAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION) || getIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION)) {
                            ULog.w(TAG,"onBMSReceiveData: 电池整体电压恢复正常 当前电压:"+batteryVoltage);
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_VOLTAGE_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_OVER_VOLTAGE_EXCEPTION, false);
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_UNDER_VOLTAGE_EXCEPTION, false);
                        }
                    }
                }


                //机器人内电池保护 报警 非零就报
                if (bmsDataDetail.getProtectStatus() != 0) {
                    ULog.d(TAG, "电池保护 = " + bmsDataDetail.getProtectStatus());
                }
                //                if (((data[20] & 255) << 8 | data[21] & 255) != 0) {
                //                    if (addAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION)) {
                //                        AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION);
                //                        alertEvent.setValue(((data[20] & 255) << 8 | data[21] & 255));
                //                        RxBus.getInstance().post(alertEvent);
                //
                //                        setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION, true);
                //                    }
                //                } else {
                //                    setAlarmCount(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION, 0);
                //                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION)) {
                //                        AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION_RESUME);
                //                        RxBus.getInstance().post(alertEvent);
                //                        setIsAlarmReported(AlarmTypeEnum.ROBOT_BATTERY_PROTECT_EXCEPTION, false);
                //                    }
                //                }

                int lowPower = 20;
                int extremelyLowPower = 10;
                if (getRobot() != null) {
                    lowPower = getRobot().getLowPowerThreshold();
                    extremelyLowPower = getRobot().getLowPowerThreshold();
                }
                //                if (MODE != MODE_COLLECTION_RAW_DATA_MP4 && MODE != MODE_AGING_TEST) {
                //                    if (batteryPercent <= lowPower && mCurrent < 0 && MODE != MODE_GOTO_CHARGER && !inCharger()) {
                //                        ULog.d(TAG, "onBMSReceiveData:  == 低电量去充电桩");
                //                        MainApp.bEnable = false;
                //                        gotoChargerCheck();
                //                        //通知手机端机器人触发了低电量回充
                //                        MqttCommand lowPowerCommand = new MqttCommand();
                //                        lowPowerCommand.setSource(getRobot().getId());
                //                        lowPowerCommand.setType(MqttCommand.ROBOT_LOW_POWER_GO_TO_CHARGE_TYPE);
                //                        for (String accountId : accounts) {
                //                            lowPowerCommand.setTarget(accountId);
                //                            mMqttManager.publishMessage(lowPowerCommand);
                //                        }
                //                    }
                //                }
                if (MODE == MODE_AGING_TEST && batteryPercent <= lowPower && mCurrent < 0 && !inCharger() && !agingTestGoTOCharger) {
                    agingTestGoTOCharger = true;
                }
                if (mCurrent < 0) {
                    ULog.d(TAG,
                            "重复上电信息，当前电量：" + getRobot().getPowerPercent() + ",batteryPowerOn:" + batteryPowerOn
                                    + ",inCharger:" + inCharger() + ",isCloseRepeatCharge:" + isCloseRepeatCharge + ",mIsWaitToLeaveCharger:"
                                    + mIsWaitToLeaveCharger + ",MODE:" + MODE + " batteryAutoOff " + batteryAutoOff);
                    if (!mHandler.hasMessages(Msg.WHAT_START_CHARGING) && !isCloseRepeatCharge && (batteryPercent < batteryPowerOn || (getRobot() != null && getRobot().getChargeStrategy() != null && getRobot().getChargeStrategy() == ChargingStrategy.INSPECTION_LOW_POWER_CHARGING_FULL)) && !mIsWaitToLeaveCharger) {
//                        if (batteryAutoOff) {
//                            if (mHandler.hasMessages(Msg.WHAT_END_CHARGING)) {
//                                mHandler.removeMessages(Msg.WHAT_END_CHARGING);
//                            }
//
//                            //回充电桩
//                            if (MODE != MODE_GOTO_CHARGER && !mHandler.hasMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE)) {
//                                ULog.d(TAG, "30秒后开始回充");
//                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_REPEAT_FIND_IN_PLACE, 30 * 1000);
//                            }
//                        } else
                        if (inCharger()) {
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_START_CHARGING, 30 * 1000);
                        }
                    }
                    if ((MODE == MODE_INSPECTION || MODE == MODE_GOTO_CHARGER) && mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
                        mHandler.removeMessages(Msg.WHAT_START_CHARGING);
                    }
                } else {
                    if (getRobot() != null && (getRobot().getException() >> 4 & 0x1) == 1) {
                        getRobot().setException(getRobot().getException() - 0b10000);
                        //                        if (!mHandler.hasMessages(Msg.WHAT_UPLOAD_EXCEPTION_STATE)) {
                        //                            mHandler.sendEmptyMessage(Msg.WHAT_UPLOAD_EXCEPTION_STATE);
                        //                        }
                    }

                    //                    if (batteryPercent >= batteryPowerOff && inCharger()) {
                    //                        ULog.d(TAG, "电量大于97 关闭充电 === batteryPercent：" + batteryPercent + ",batteryPowerOff:" + batteryPowerOff + ",inCharger:" + inCharger());
                    //                        previousCommand = "";
                    //                        batteryAutoOff = true;
                    //                        if (!mHandler.hasMessages(Msg.WHAT_END_CHARGING))
                    //                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_END_CHARGING, 1_000);
                    //                    }

                }
                //                if (!mHandler.hasMessages(Msg.WHAT_CHARGING_TIME_TALLY)) {
                //                    if (batteryPercent >= 95 && current > 0 && MODE != MODE_INSPECTION) {
                //                        startInspection();
                //                    }
                //                }

                if (batteryPercent <= extremelyLowPower) { //极低
                    //                    stmExecute.executeTask(new StmTask().setExceptionStatus(StmTask.REG_POWER_STATUS, StmTask.EX_BATTERY_EXTREMELY_LOW));
                    batteryStatus = StmTask.EX_BATTERY_EXTREMELY_LOW;
                } else if (batteryPercent <= lowPower) { //低
                    //                    stmExecute.executeTask(new StmTask().setExceptionStatus(StmTask.REG_POWER_STATUS, StmTask.EX_BATTERY_LOW));
                    batteryStatus = StmTask.EX_BATTERY_LOW;
                } else {
                    batteryStatus = StmTask.EX_BATTERY_NORMAL;
                }

                //更新CicadaRoom状态
                if (mDistance < 0 && NumberUtil.notNullAndEqual(CicadaRoomController.getInstance().haveRoom(), true)) {
                    CicadaRoomController.getInstance().updateChargingStatus();
                }
            }
            break;

            default:
                break;
        }

        boolean isFullVoltage = checkHigherBatteryVoltage(getRobot().getBatteryMaxVoltage()).getResult();
        ULog.d(TAG, "查询电池状态 满电 " + isFullVoltage + " mcurrent " + mCurrent + " 电量 " + getRobot().getPowerPercent() +" robot.getBatteryMaxVoltage:"+getRobot().getBatteryMaxVoltage());
        if (isFullBattery) {
            int bmsInterval = getRobotConfigParams().getBmsQueryInterval();
            bmsInterval = bmsInterval > 0 ? bmsInterval : 600;
            //满电后10分钟查一次
            if (BaseBmsCommunicator.getInstance().getQueryInterval() != bmsInterval * 1000) {
                BaseBmsCommunicator.getInstance().changeQueryInterval(bmsInterval * 1000);
                BaseBmsCommunicator.getInstance().restartContinuousQuery();
            }
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_BMS_QUERY_SLOW, true);
        } else {
            if (BaseBmsCommunicator.getInstance().getQueryInterval() != 2500) {
                BaseBmsCommunicator.getInstance().changeQueryInterval(2500);
                BaseBmsCommunicator.getInstance().restartContinuousQuery();
            }
        }
    }

    /**
     * 检查电压值是否过高
     *
     * @param batteryVoltage 电压值
     *
     * @return true过高
     */
    private CheckBatteryVoltageResult checkHigherBatteryVoltage(Float batteryVoltage) {
        if(batteryVoltage == null){
            batteryVoltage = 4.15f;
        }
        CheckBatteryVoltageResult result = new CheckBatteryVoltageResult();
        for (double voltage : batteryVoltageList) {
            if (voltage >= batteryVoltage) {
                result.setResult(true);
                result.setVal(voltage);
                break;
            }
        }
        return result;
    }

    /**
     * 检查电压值是否过低
     *
     * @param batteryVoltage 电压值
     *
     * @return true过低
     */
    private CheckBatteryVoltageResult checkLowerBatteryVoltage(float batteryVoltage) {
        CheckBatteryVoltageResult result = new CheckBatteryVoltageResult();
        for (double voltage : batteryVoltageList) {
            if (voltage <= batteryVoltage) {
                result.setResult(true);
                result.setVal(voltage);
                break;
            }
        }
        return result;
    }

    private static class CheckBatteryVoltageResult{
        private boolean result;
        private double val;
        public CheckBatteryVoltageResult() {}
        public CheckBatteryVoltageResult(boolean result, double val) {
            this.result = result;
            this.val = val;
        }

        public boolean getResult() {
            return result;
        }

        public void setResult(boolean error) {
            this.result = error;
        }

        public double getVal() {
            return val;
        }

        public void setVal(double val) {
            this.val = val;
        }
    }

    /**
     * 获取单体电压字符串
     *
     * @return 电压字符串
     */
    private String getBatterySingleVoltage() {
        StringBuilder sb = new StringBuilder();
        for (double voltage : batteryVoltageList) {
            sb.append(voltage);
            sb.append("v");
            sb.append(",");
        }
        //去掉末尾逗号
        String batteryStr = sb.toString();
        if (!UString.isEmpty(batteryStr) && batteryStr.endsWith(",")) {
            batteryStr = batteryStr.substring(0, batteryStr.length() - 1);
        }
        return batteryStr;
    }

    /*---------------------------------------------------------------*/

    Map<String, SensorStatusRecord> sensorStatusRecordMap = new HashMap<>();

    private void updateSegmentSensorStatus() {
        ULog.d(TAG, "updateSegmentSensorStatus == ");
        if (mSegment == null) return;
        if (mSegment.getMapId() == null) return;
        Observable.just(1)
                .observeOn(Schedulers.io())
                .subscribe(event -> {
                    FindByMapId request = new FindByMapId();
                    request.setMapId(mSegment.getMapId());
                    UOKHttp.post(UrlManager.getBaseUrl(), request, new UOKHttp.RequestCallBack<FindByMapId>(FindByMapId.class) {
                        @Override
                        public void onFailure(Call call, IOException e) {
                            ULog.e(TAG, "onFailure:  updateSegmentSensorStatus==");
                        }

                        @Override
                        public void onResponseOk(Call call, FindByMapId result) {
                            //                            ULog.e(TAG, "onResponseOk:  updateSegmentSensorStatus======  sensor num  " + (result.getSegmentSensorList() == null ? "null" : result.getSegmentSensorList().size()) + " getSegmentSensorList " + gson.toJson(result.getSegmentSensorList()));
                            if (result.isSuccess() && result.getSegmentSensorList() != null && result.getSegmentSensorList().size() != 0) {
                                for (int i = 0; i < result.getSegmentSensorList().size(); i++) {
                                    //雨量传感器 & 在线
                                    if (result.getSegmentSensorList().get(i).getType() == 9 && result.getSegmentSensorList()
                                            .get(i)
                                            .getStatus() == 1) {
                                        if (sensorStatusRecordMap.containsKey(result.getSegmentSensorList().get(i).getSku())) {
                                            String sku = result.getSegmentSensorList().get(i).getSku();
                                            sensorStatusRecordMap.get(sku).setException(result.getSegmentSensorList()
                                                    .get(i)
                                                    .getException() == 1);
                                            sensorStatusRecordMap.get(sku).setValue(result.getSegmentSensorList().get(i).getValue());
                                            sensorStatusRecordMap.get(sku).setUpdateTime(new Date());
                                        } else {
                                            SensorStatusRecord sensorStatus = new SensorStatusRecord();
                                            sensorStatus.setSku(result.getSegmentSensorList().get(i).getSku());
                                            sensorStatus.setType(result.getSegmentSensorList().get(i).getType());
                                            sensorStatus.setException(result.getSegmentSensorList().get(i).getException() == 1);
                                            sensorStatus.setValue(result.getSegmentSensorList().get(i).getValue());
                                            sensorStatus.setUpdateTime(new Date());
                                            sensorStatusRecordMap.put(result.getSegmentSensorList().get(i).getSku(), sensorStatus);
                                        }
                                    } else if (sensorStatusRecordMap.containsKey(result.getSegmentSensorList().get(i).getSku())) {
                                        sensorStatusRecordMap.remove(result.getSegmentSensorList().get(i).getSku());
                                    }
                                }
                            }
                            for (SensorStatusRecord value : sensorStatusRecordMap.values()) {
                                ULog.e(TAG, "onResponseOk:  updateSegmentSensorStatus== " + gson.toJson(value));
                            }
                        }

                        @Override
                        public void onResponseError(Call call, int i, String s) {
                            ULog.e(TAG, "onResponseError:  updateSegmentSensorStatus==");
                        }
                    });
                });
    }

    private void robotStatusUpload(int tag) {
        ULog.d(TAG, "robotStatusUpload == " + tag);
        if (tag != 3) isUpdateRobot = true;
        //        if (tag == 5) {
        //            CurrentCameraAngle currentCameraAngle = new CurrentCameraAngle();
        //            currentCameraAngle.setH(SteerController.getInstance().getCurHAngle());
        //            currentCameraAngle.setV(SteerController.getInstance().getCurVAngle());
        //            getRobot().setCurrentCameraAngle(UGson.getGson().toJson(currentCameraAngle));
        //            ULog.d(TAG, "setSteerEngineAngle 更新舵机角度 " + getRobot().getCurrentCameraAngle());
        //        }
        Observable.just(1)
                .observeOn(Schedulers.io())
                .subscribe(event -> {
                    fun.unifun.library.cloud.client.inparam.robot.UpdateByIdFrequent request = new fun.unifun.library.cloud.client.inparam.robot.UpdateByIdFrequent();
                    try {
                        version = USystemProperties.get(mActivity, UConstants.VERSION);
                    } catch (IllegalArgumentException e) {
                        e.printStackTrace();
                        version = AppUtils.getAppVersionName();
                    }
                    if (TextUtils.isEmpty(stmVersion)) {
                        mHandler.sendEmptyMessage(Msg.WHAT_GET_STM_VERSION);
                    } else {
                        getRobot().setStmVersion(stmVersion);
                    }
                    Robot uploadRobot = new Robot();
                    uploadRobot.setId(getRobot().getId());
                    uploadRobot.setInit(getRobot().getInit());
                    uploadRobot.setMode(MODE);
                    uploadRobot.setUploadFileType(UrlManager.notPublicServer() ? 1 : 0);
                    uploadRobot.setVersion(version);
                    uploadRobot.setSelfIp(UNet.getDefaultIpAddresses(mActivity));
                    uploadRobot.setMapNodeId(getRobot().getMapNodeId());
                    uploadRobot.setException(getRobot().getException());
                    uploadRobot.setRobotTemperatureException(getRobot().getRobotTemperatureException());
                    uploadRobot.setSpeed(getRobot().getSpeed());
                    uploadRobot.setPowerPercent(getRobot().getPowerPercent());
                    uploadRobot.setCharging(getRobot().getCharging());
                    uploadRobot.setPowerVoltage(getRobot().getPowerVoltage());
                    uploadRobot.setDecibel(getRobot().getDecibel());
                    uploadRobot.setInfraredTemprature(getRobot().getInfraredTemprature());
                    uploadRobot.setMotorTemperature(getRobot().getMotorTemperature());
                    uploadRobot.setMotorVoltage(getRobot().getMotorVoltage());
                    uploadRobot.setStm32Temperature(getRobot().getStm32Temperature());
                    uploadRobot.setObstacle(getRobot().getObstacle());
                    uploadRobot.setAlarm(getRobot().getAlarm());
                    uploadRobot.setBuzzing(getRobot().getBuzzing());
                    uploadRobot.setApClientIp(getRobot().getApClientIp());
                    uploadRobot.setChargeStatus(getRobot().getChargeStatus());
                    uploadRobot.setPreviousRobot(getRobot().getPreviousRobot());
                    uploadRobot.setNextRobot(getRobot().getNextRobot());
                    uploadRobot.setRobotTemperature(getRobot().getRobotTemperature());
                    uploadRobot.setHeating(getRobot().getHeating());
                    uploadRobot.setCleanException(getRobot().getCleanException());
                    uploadRobot.setEmergencyStopButton(getRobot().getEmergencyStopButton());
                    uploadRobot.setNetworkState(getRobot().getNetworkState());
                    uploadRobot.setRemainBattery(getRobot().getRemainBattery());
                    uploadRobot.setRealMileage(getRobot().getRealMileage());
                    uploadRobot.setAvailableMileage(getRobot().getAvailableMileage());
                    uploadRobot.setBatteryPerHour(getRobot().getBatteryPerHour());
                    uploadRobot.setNetworkMode(getRobot().getNetworkMode());
                    uploadRobot.setCheckRollerNum(getRobot().getCheckRollerNum());
                    uploadRobot.setCurrentRssi(getRobot().getCurrentRssi());
                    uploadRobot.setStrongestRssi(getRobot().getStrongestRssi());
                    uploadRobot.setSmoke(getRobot().getSmoke());
                    uploadRobot.setCo(getRobot().getCo());
                    uploadRobot.setDust(getRobot().getDust());
                    uploadRobot.setGas(getRobot().getGas());
                    uploadRobot.setHumidity(getRobot().getHumidity());
                    uploadRobot.setNetworkRxSpeed(getRobot().getNetworkRxSpeed());
                    uploadRobot.setNetworkTxSpeed(getRobot().getNetworkTxSpeed());
                    uploadRobot.setLeftFrontLeak(getRobot().getLeftFrontLeak());
                    uploadRobot.setRightFrontLeak(getRobot().getRightFrontLeak());
                    uploadRobot.setLeftBehindLeak(getRobot().getLeftBehindLeak());
                    uploadRobot.setRightBehindLeak(getRobot().getRightBehindLeak());
                    uploadRobot.setStmVersion(getRobot().getStmVersion());
                    uploadRobot.setCurrentBssid(getRobot().getCurrentBssid());
                    uploadRobot.setStrongestBssid(getRobot().getStrongestBssid());
                    uploadRobot.setRobotExternalTemperatureHumiditySensorStatus(getRobot().getRobotExternalTemperatureHumiditySensorStatus());
                    uploadRobot.setGasCollectionBoardState(getRobot().getGasCollectionBoardState());
                    uploadRobot.setO2(getRobot().getO2());
                    uploadRobot.setCo2(getRobot().getCo2());
                    uploadRobot.setCh4(getRobot().getCh4());
                    uploadRobot.setCoMa(getRobot().getCoMa());
                    uploadRobot.setSmokeSensorStatus(getRobot().getSmokeSensorStatus());
                    uploadRobot.setDustSensorStatus(getRobot().getDustSensorStatus());
                    uploadRobot.setBatteryCurrent(getRobot().getBatteryCurrent());
                    uploadRobot.setInfraredTempratureList(getRobot().getInfraredTempratureList());
                    uploadRobot.setBatteryGroupInfo(getRobot().getBatteryGroupInfo());
                    uploadRobot.setLocation(getRobot().getLocation());
                    uploadRobot.setH2s(getRobot().getH2s());
                    uploadRobot.setH2sStatus(getRobot().getH2sStatus());
                    uploadRobot.setNh3(getRobot().getNh3());
                    uploadRobot.setNh3Status(getRobot().getNh3Status());
                    uploadRobot.setPm10(getRobot().getPm10());
                    uploadRobot.setPm10Status(getRobot().getPm10Status());
                    uploadRobot.setInternalHumidity(getRobot().getInternalHumidity());
                    uploadRobot.setEth0Mac(URootCmd.execRootCmd("cat /sys/class/net/eth0/address"));
                    uploadRobot.setWlan0Mac(URootCmd.execRootCmd("cat /sys/class/net/wlan0/address"));
                    uploadRobot.setLocalPushIrUrl(TextUtils.isEmpty(getRobot().getLocalPushIrUrl()) ? mLocalPushIrUrl : getRobot().getLocalPushIrUrl());
                    uploadRobot.setLocalPushWebCameraUrl(TextUtils.isEmpty(getRobot().getLocalPushWebCameraUrl()) ? mLocalPushWebCameraUrl : getRobot().getLocalPushWebCameraUrl());
                    uploadRobot.setLocalPushAudioUrl(TextUtils.isEmpty(getRobot().getLocalPushAudioUrl()) ? mLocalPushAudioUrl : getRobot().getLocalPushAudioUrl());
                    uploadRobot.setCurrentCameraAngle(getRobot().getCurrentCameraAngle());
                    uploadRobot.setSensorDatas(getRobot().getSensorDatas());
                    uploadRobot.setNowCreateMapAccount(getRobot().getNowCreateMapAccount());
                    uploadRobot.setWebCameraNum(webCameraNum);
                    uploadRobot.setRfidTagName(getRobot().getRfidTagName());
                    if(MainApp.maxMotorSpeed != null){
                        uploadRobot.setSpeedMax(MainApp.maxMotorSpeed);
                    }
                    if (MainApp.mDrivingMileage >= 0) {
                        uploadRobot.setDrivingMileage(FormatUtils.keepDecimals(MainApp.mDrivingMileage, 3));
                    } else {
                        uploadRobot.setDrivingMileage(getRobot().getDrivingMileage());
                    }
                    uploadRobot.setInCharger(inCharger());
                    uploadRobot.setMotorCurrent(mMotorCurrent);
                    uploadRobot.setMotorCurrent2(mMotorCurrent2);

                    if (InspectManager.getInstance(getContext(), RobotFragment.this).mCurrentTaskNode != null) {
                        uploadRobot.setTaskNodeId(InspectManager.getInstance(getContext(), RobotFragment.this).mCurrentTaskNode.getId());
                    }
                    if (!TextUtils.isEmpty(mBotInfoMgr.getAndroidBoardId())) {
                        uploadRobot.setAndroidBoardId(mBotInfoMgr.getAndroidBoardId());
                    }
                    if (!TextUtils.isEmpty(mBotInfoMgr.getStm32Id())) {
                        uploadRobot.setStm32Id(mBotInfoMgr.getStm32Id());
                    }
                    Long realTime = UConstants.getRealTime(mActivity);
                    if (realTime != null) {
                        MainApp.mStInfo.setOnlineTotalTime(realTime + SystemClock.elapsedRealtime());//SystemClock.elapsedRealtime() 获取已开机时间 单位毫秒
                    }

                    //统计巡检次数
                    if (toMapHeadNum > 0 && toMapEndNum > 0) {
                        int num = Math.min(toMapEndNum, toMapHeadNum);
                        toMapEndNum -= num;
                        toMapHeadNum -= num;
                        if (MainApp.mStInfo.getInspectionTotalNum() < 0) MainApp.mStInfo.setInspectionTotalNum(0);
                        MainApp.mStInfo.setInspectionTotalNum(MainApp.mStInfo.getInspectionTotalNum() + num);
                        StorageCenter.getRobotStorage().putInteger(UConstants.PREFERENCES_INSPECTION_TO_END_NUM_KEY, toMapEndNum);
                        StorageCenter.getRobotStorage().putInteger(UConstants.PREFERENCES_INSPECTION_TO_HEAD_NUM_KEY, toMapHeadNum);
                        StorageCenter.getRobotStorage().putInteger(UConstants.PREFERENCES_INSPECTION_TOTAL_NUM_KEY, MainApp.mStInfo.getInspectionTotalNum());
                    }
                    if (MainApp.mStInfo != null) {
                        MainApp.mStInfo.setBatteryCheckStatus(MainApp.checkBMSStatus ? MainApp.batteryCheckStatus : 0);
                        StorageCenter.getRobotStorage().putString(UConstants.PREFERENCES_ROBOT_STATUS_VALUE_KEY, gson.toJson(MainApp.mStInfo));
                    }
                    uploadRobot.setStatusValue(gson.toJson(MainApp.mStInfo));
                    request.setRobot(uploadRobot);
                    final long requestTime = System.currentTimeMillis();
                    request.setTime(requestTime);
                    ULog.d(TAG, "UpdateRobotStatesByRobotId requestId = " + requestTime + " 统计信息 " + uploadRobot.getStatusValue());
                    UOKHttp.post(UrlManager.getBaseUrl(),
                            request,
                            new UOKHttp.RequestCallBack<fun.unifun.library.cloud.client.inparam.robot.UpdateByIdFrequent>(fun.unifun.library.cloud.client.inparam.robot.UpdateByIdFrequent.class) {

                                @Override
                                public void onFailure(Call call, IOException e) {
                                    ULog.e(TAG,
                                            "onFailure:  UpdateRobotStatesByRobotId======requestId " + requestTime + " e=" + e.getMessage());
                                }

                                @Override
                                public void onResponseOk(Call call,
                                                         fun.unifun.library.cloud.client.inparam.robot.UpdateByIdFrequent result) {
                                    ULog.e(TAG,
                                            "onResponseOk:  UpdateRobotStatesByRobotId======requestId " + requestTime + "  isGrayUpgrade  " + (result.getRobot() == null ? "null " : result.getRobot()
                                                    .getGrayUpgrade()) + " pushEnable " + (result.getRobot() == null ? "null " : result.getRobot()
                                                    .getPushEnable()) + " sleepMode " + (result.getRobot() == null ? "null " : result.getRobot()
                                                    .getSleepMode()));
                                    if (result.isSuccess() && result.getRobot() != null && getRobot() != null) {
                                        mHandler.sendMessage(mHandler.obtainMessage(Msg.WHAT_PUSH_UPDATE, result.getRobot()));
                                        UPreferences.putLong(mActivity, UConstants.PREFERENCES_CACHE_SYSTEM_TIME, System.currentTimeMillis());
//                                        RobotPreferences.getInstance(getContext()).setRobot(getContext(), result.getRobot());
                                        //检测更新推流相关工作
                                        if (result.getRobot().getSleepWakeupInterval() != null && !result.getRobot()
                                                .getSleepWakeupInterval()
                                                .equals(getRobot().getSleepWakeupInterval())) {
                                            getRobot().setSleepWakeupInterval(result.getRobot().getSleepWakeupInterval());
                                        }
                                        if (result.getRobot().getSleepMode() != null && !result.getRobot()
                                                .getSleepMode()
                                                .equals(getRobot().getSleepMode())) {
                                            getRobot().setSleepMode(result.getRobot().getSleepMode());
                                            if (checkArrangeInspection(true) && inCharger()) {
                                                ULog.d(TAG, "休眠已打开，开始休眠 " + getRobot().getSleepWakeupInterval());
                                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE, 1000);
                                            }else{
                                                isSleepTip = false;
                                            }
                                        }
                                        if (getRobot().getGrayUpgrade() != null) {
                                            isGrayUpgrade = result.getRobot().getGrayUpgrade();
                                        }

                                        if (getRobot().getRecordLocalSwitch() != null) {
                                            recordLocalSwitch = result.getRobot().getRecordLocalSwitch();
                                        }
                                        //                    refreshRobot(updateRobotStatesByRobotId.getRobot());
                                        int loraAddress = UPreferences.getInt(mActivity, UConstants.PREFERENCES_LORA_ADDRESS_KEY);
                                        int loraChannel = UPreferences.getInt(mActivity, UConstants.PREFERENCES_LORA_CHANNEL_KEY);
                                        int loraAddressNew = result.getRobot().getSelfLoraAddress() == null ? -1 : result.getRobot()
                                                .getSelfLoraAddress();
                                        int loraChannelNew = result.getRobot().getSelfLoraChannel() == null ? -1 : result.getRobot()
                                                .getSelfLoraChannel();
                                        if (loraAddress != loraAddressNew || loraChannel != loraChannelNew) {
                                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_LORA_ADDRESS_KEY, loraAddressNew);
                                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_LORA_CHANNEL_KEY, loraChannelNew);
                                            getRobot().setSelfLoraAddress(result.getRobot().getSelfLoraAddress());
                                            getRobot().setSelfLoraChannel(result.getRobot().getSelfLoraChannel());
                                            RxBus.getInstance().post(new LoraEvent(RobotEventConstants.EVENT_LORA_INFO_SETTINGS,
                                                    loraAddressNew, loraChannelNew));
                                        }
                                        // -----------------------------
                                        //wifi
                                        String mSsid = UPreferences.getString(mActivity, UConstants.PREFERENCES_AP_SSID_KEY, "");
                                        String mPwd = UPreferences.getString(mActivity, UConstants.PREFERENCES_AP_SSID_PWD_KEY, "");
                                        String ssidNew = result.getRobot().getSsid() == null ? "" : result.getRobot().getSsid();
                                        String pwdNew = result.getRobot().getSsidPwd() == null ? "" : result.getRobot().getSsidPwd();
                                        if (!mSsid.equals(ssidNew)) {
                                            UPreferences.putString(mActivity, UConstants.PREFERENCES_AP_SSID_KEY, ssidNew);
                                            getRobot().setSsid(result.getRobot().getSsid());
                                        }
                                        if (!mPwd.equals(pwdNew)) {
                                            UPreferences.putString(mActivity, UConstants.PREFERENCES_AP_SSID_PWD_KEY, pwdNew);
                                            getRobot().setSsidPwd(result.getRobot().getSsidPwd());
                                        }

                                        //更新报警处理开关
                                        if (result.getRobot().getAlarmStop() != null) {
                                            AlarmManager.getInstance(mActivity.getApplicationContext())
                                                    .setIsNeedToWaitAlarmProcessed(result.getRobot()
                                                            .getAlarmStop() == UConstants.VALUE_SWITCH_STATUS_ON);
                                        }


                                        //休眠处理
/*                                if (result.getRobot().getSleepMode() != null && result.getRobot().getSleepMode() == UConstants.VALUE_SWITCH_STATUS_ON) {
                                    mHandler.sendEmptyMessage(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE);
                                }*/

                                        //                                RobotConfigParams updatedParams =
                                        //                                        mBotInfoMgr.parseRobotConfigParams(result.getRobot().getConfigParams());
                                        //如果需要处理变更项，在这里处理

                                        //建图模式处理
                                        if (mIsWaitToQuitAutoBuildMapMode && result.getRobot().getMode() != MODE_AUTO_BUILD_MAP) {
                                            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_QUIT_AUTO_BUILD_MAP_MODE_SUCCESS));
                                            mIsWaitToQuitAutoBuildMapMode = false;
                                        }
                                        if (mIsWaitToEnterAutoBuildMapMode && result.getRobot().getMode() == MODE_AUTO_BUILD_MAP) {
                                            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_ENTER_AUTO_BUILD_MAP_MODE_SUCCESS));
                                            mIsWaitToEnterAutoBuildMapMode = false;
                                        }
//                                        这种方式解析json存在问题  {"isRecordIRRawData":true 解析出来为false 可能和get/set方法名有关
//                                        RobotConfigParams newParams = JsonHelper.parseJson(result.getRobot().getConfigParams(),
//                                                RobotConfigParams.class);
                                        RobotConfigParams newParams = JSON.parseObject(result.getRobot().getConfigParams(), RobotConfigParams.class);
                                        if (newParams != null) {
                                            lowTempThreshold = newParams.getLowTempThreshold();
                                            boolean isSoftEmergencyStopNew = newParams.getSoftEmergencyStop();
                                            if (isSoftEmergencyStopNew != isSoftEmergencyStop) {//本地和远程的值不相同的情况下才检查用那个
                                                if(getRobotConfigParams().getSoftEmergencyStopUpdateTime() != null && newParams.getSoftEmergencyStopUpdateTime() != null){
                                                    if(newParams.getSoftEmergencyStopUpdateTime() >= getRobotConfigParams().getSoftEmergencyStopUpdateTime()){
                                                        //如果远程和本地值不相同的情况下 且 远程的更新时间比本地更新 则使用远程的状态 否则保持本地不做操作
                                                        if (isSoftEmergencyStopNew)
                                                            openSoftEmergencyStop("检查到机器人配置改变1 开启软件急停");
                                                        else
                                                            closeSoftEmergencyStop("检查到机器人配置改变1 关闭软件急停");
                                                        getRobotConfigParams().setSoftEmergencyStop(isSoftEmergencyStopNew);
                                                    }else if(newParams.getSoftEmergencyStopUpdateTime() < getRobotConfigParams().getSoftEmergencyStopUpdateTime()){
                                                        //当本地的软件急停状态修改时间比远程新 主动将本地状态更新到服务端 无论成功或失败 下次检测的时候还是判断尝试
                                                        setSoftEmergencyStop(getRobotConfigParams().getSoftEmergencyStop(),getRobotConfigParams().getSoftEmergencyStopUpdateTime(),"检测到本地状态比远程新1");
                                                    }
                                                }else{
                                                    if(getRobotConfigParams().getSoftEmergencyStopUpdateTime() == null){
                                                        //如果远程和本地有一个的更新时间是null 则检查是不是本地的更新时间为null 如果是则使用远程的 否则保持本地不做操作
                                                        if (isSoftEmergencyStopNew)
                                                            openSoftEmergencyStop("检查到机器人配置改变2 开启软件急停");
                                                        else
                                                            closeSoftEmergencyStop("检查到机器人配置改变2 关闭软件急停");
                                                        getRobotConfigParams().setSoftEmergencyStop(isSoftEmergencyStopNew);
                                                    }else if(newParams.getSoftEmergencyStopUpdateTime() == null){
                                                        //远程没更新时间 将本地状态和时间更新到远程
                                                        setSoftEmergencyStop(getRobotConfigParams().getSoftEmergencyStop(),getRobotConfigParams().getSoftEmergencyStopUpdateTime(),"检测到远程没更新时间将本地状态和时间更新到远程1");
                                                    }
                                                }
                                            }

//                                            ULog.d(TAG, "MainApp.isRecordIrRawData " + result.getRobot().getConfigParams());
//                                            RobotConfigParams newParams1 = JSON.parseObject(result.getRobot().getConfigParams(), RobotConfigParams.class);
                                            boolean isRecordIRRawDataNew = newParams.getRecordIRRawData();
//                                            ULog.d(TAG, "MainApp.isRecordIrRawData " + MainApp.isRecordIrRawData + " new " + newParams.getRecordIRRawData() + " new1 " + newParams1.getRecordIRRawData());
                                            if (isRecordIRRawDataNew != MainApp.isRecordIrRawData) {
                                                ULog.d(TAG, "MainApp.isRecordIrRawData update " + MainApp.isRecordIrRawData);
                                                MainApp.isRecordIrRawData = isRecordIRRawDataNew;
                                                getRobotConfigParams().setRecordIRRawData(isRecordIRRawDataNew);
                                            }
                                            boolean tempShowIrTime = newParams.getShowIrTime();
                                            if (tempShowIrTime != MainApp.isShowIrTime) {
                                                ULog.d(TAG, "MainApp.isShowIrTime update old " + MainApp.isShowIrTime);
                                                MainApp.isShowIrTime = tempShowIrTime;
                                                getRobotConfigParams().setShowIrTime(tempShowIrTime);
                                            }
                                            boolean tempUploadIrFrameTemp = newParams.getIsUploadIrFrame();
                                            if (tempUploadIrFrameTemp != isUploadIrFrameTemp) {
                                                ULog.d(TAG, "isUploadIrFrameTemp update old " + isUploadIrFrameTemp);
                                                isUploadIrFrameTemp = tempUploadIrFrameTemp;
                                                if (isUploadIrFrameTemp) uploadIrFrameTempJump = true;
                                                getRobotConfigParams().setIsUploadIrFrame(tempUploadIrFrameTemp);
                                            }
                                            String tempUploadIrFrameHost = newParams.getUploadIrFrameHost();
                                            if (!TextUtils.isEmpty(tempUploadIrFrameHost) && !tempUploadIrFrameHost.equals(uploadIrFrameHost)) {
                                                ULog.d(TAG, "uploadIrFrameHost update old " + uploadIrFrameHost);
                                                uploadIrFrameHost = tempUploadIrFrameHost;
                                                getRobotConfigParams().setUploadIrFrameHost(tempUploadIrFrameHost);
                                            }
                                            int tempIrDetectMode = newParams.getIrDetectMode();
                                            if (tempIrDetectMode != MainApp.irDetectMode) {
                                                ULog.d(TAG, "MainApp.irDetectMode update old " + MainApp.irDetectMode);
                                                MainApp.irDetectMode = tempIrDetectMode;
                                                getRobotConfigParams().setIrDetectMode(tempIrDetectMode);
                                            }
                                            boolean tempCheckBMSStatus = newParams.getCheckBMSStatus();
                                            if (tempCheckBMSStatus != MainApp.checkBMSStatus) {
                                                ULog.d(TAG, "MainApp.checkBMSStatus update old " + MainApp.checkBMSStatus);
                                                MainApp.checkBMSStatus = tempCheckBMSStatus;
                                                getRobotConfigParams().setCheckBMSStatus(tempCheckBMSStatus);
                                            }

                                            int tempControlMode = newParams.getControlMode();
                                            if (tempControlMode != MainApp.controlMode) {
                                                ULog.d(TAG, "自动模式/手动模式 MainApp.controlMode update old " + MainApp.controlMode);
                                                MainApp.controlMode = tempControlMode;
                                                getRobotConfigParams().setControlMode(tempControlMode);
                                                controlModeChange(MainApp.controlMode);
                                            }

                                            boolean tempAIRB = newParams.getArrangeInspectRelateBeltStatus();
                                            if (tempAIRB != MainApp.arrangeInspectRelBelt) {
                                                ULog.d(TAG, "MainApp.arrangeInspectRelBelt update old " + MainApp.arrangeInspectRelBelt);
                                                MainApp.arrangeInspectRelBelt = tempAIRB;
                                                getRobotConfigParams().setArrangeInspectRelateBeltStatus(tempAIRB);
                                            }

                                            boolean rgbRecognitionNew = newParams.getRgbRecognition();
                                            if (rgbRecognitionNew != MainApp.isRgbRecognition) {
                                                ULog.d(TAG, "MainApp.isRgbRecognition update " + MainApp.isRgbRecognition);
                                                MainApp.isRgbRecognition = rgbRecognitionNew;
                                                getRobotConfigParams().setRgbRecognition(rgbRecognitionNew);
                                            }
                                            float bmsHeatOpenTemp = newParams.getBmsHeatLowThreshold();
                                            if (bmsHeatOpenTemp != MainApp.BMS_HEAT_OPEN) {
                                                ULog.d(TAG, "MainApp.BMS_HEAT_OPEN update " + MainApp.BMS_HEAT_OPEN);
                                                MainApp.BMS_HEAT_OPEN = bmsHeatOpenTemp;
                                                getRobotConfigParams().setBmsHeatLowThreshold(bmsHeatOpenTemp);
                                            }
                                            float bmsHeatCloseTemp = newParams.getBmsHeatHighThreshold();
                                            if (bmsHeatCloseTemp != MainApp.BMS_HEAT_CLOSE) {
                                                ULog.d(TAG, "MainApp.BMS_HEAT_CLOSE update " + MainApp.BMS_HEAT_CLOSE);
                                                MainApp.BMS_HEAT_CLOSE = bmsHeatCloseTemp;
                                                getRobotConfigParams().setBmsHeatHighThreshold(bmsHeatCloseTemp);
                                            }

                                            RecordIrData.recordIrRawDataTempThreshold = getRobotConfigParams().getRecordIrRawDataTempThreshold();
                                            float recordIrRawDataTempThresholdNew = newParams.getRecordIrRawDataTempThreshold();
                                            if (recordIrRawDataTempThresholdNew != RecordIrData.recordIrRawDataTempThreshold) {
                                                ULog.d(TAG, "RecordIrData.recordIrRawDataTempThreshold update " + RecordIrData.recordIrRawDataTempThreshold);
                                                RecordIrData.recordIrRawDataTempThreshold = recordIrRawDataTempThresholdNew;
                                                getRobotConfigParams().setRecordIrRawDataTempThreshold(recordIrRawDataTempThresholdNew);
                                            }

                                            boolean closePushOfSaveNetworkNew = newParams.getClosePushOfSaveNetwork();
                                            getRobotConfigParams().setClosePushOfSaveNetwork(closePushOfSaveNetworkNew);
                                            mBotInfoMgr.updateConfigParams(newParams);
                                        }
                                    }
                                }

                                @Override
                                public void onResponseError(Call call, int i, String s) {

                                    ULog.e(TAG, "onResponseError:  UpdateRobotStatesByRobotId======requestId " + requestTime + " s=" + s);
                                }
                            });

                });
    }

    //控制模式发生变化
    private void controlModeChange(int controlMode) {
        if (controlMode == 0) { //恢复自动模式
            int tempMode = UPreferences.getInt(mActivity, UConstants.PREFERENCES_CONTROL_MODE_CACHE_KEY, -1);
            ULog.d(TAG, "恢复自动模式 cacheMode = " + tempMode + " currentMode " + MODE);
            if (MODE == MODE_UN_KNOW) {
                switch (tempMode) {
                    case MODE_GOTO_CHARGER:
                    case MODE_DEVICE_CLEAN:
                        autoMoveManager.gotoChargerCheck("检测到下雨_回充");
                        break;
                    case MODE_INSPECTION:
                    case MODE_CHECKING_STOP:
                        setRobotDirection(UPreferences.getInt(mActivity, UConstants.PREFERENCES_CONTROL_MODE_CACHE_DIR_KEY, robotDirection), "手动切自动");
                        continueInspection(robotDirection);
                        break;
                }
            }
        } else if (controlMode == 1) { //进入手动模式 自触发停止
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_CONTROL_MODE_CACHE_KEY, MODE);
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_CONTROL_MODE_CACHE_DIR_KEY, robotDirection);
            MqttCommand startCommand = new MqttCommand();
            startCommand.setSource("self");
            startCommand.setTarget(getRobot().getId());
            startCommand.setType(MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE);
            startCommand.setAction(MqttCommand.ROBOT_STOP_ACTION);
            onMessageReceived(startCommand);
        }
    }

    //******************重写baseFragment*******************
    @Override
    public boolean inCharger() {
        return inCharger;
    }

    public void setInCharger(boolean val,String logTag){
        ULog.d("setInCharger val:"+val+" logTag:"+logTag);
        inCharger = val;
        if(getRobotConfigParams().isCheckRgbSharpness() && !val && RgbSharpnessChecker.getInstance().getCheckRounds() > 0){
            RgbSharpnessChecker.getInstance().stop(true,"不在充电桩不再检测");
        }
    }

    @Override
    public void normalStartUp() {
        ULog.d(TAG, "normalStartUp === RobotFragment");
        initData();
    }

    @Override
    public void onStartStmUpgrade() {
        if (taskComputeMile != null) {
            taskComputeMile.cancel(true);
        }
        if (taskReadMotorInfo != null) {
            taskReadMotorInfo.cancel(true);
        }
    }


    @Override
    public byte[] getDeviceType() {
        if (mIsRobotInitialized) {
            //仅在上位机启动完成后才上报，防止刚启动时的误报
            RxBus.getInstance().post(new Stm32Event(Stm32Event.STM_QUERY_DEVICE_TYPE));
        }

        //下位机重启时重置避障状态
        ObstacleController.getInstance().resetStatus();
//        SteerController.getInstance().resetSteer();
        isNeedInitSteer = true;
        FillLightController.getInstance().resetWhenStmReboot();

        byte[] receiveData = new byte[17];
        receiveData[0] = 0x01;
        receiveData[1] = StmTask.READ_STATE_DATA;
        ULog.d(TAG, "mBotInfoMgr " + (mBotInfoMgr == null ? "null" : mBotInfoMgr.getRobotType()));
        if (mBotInfoMgr != null && mBotInfoMgr.getRobotType() != null) {
            sensorEnableStatus = UPreferences.getBoolean(MainApp.getInstance(), UConstants.PREFERENCES_SENSOR_ENABLE_STATUS, true);
            ULog.d(TAG, "下位机重启 传感器状态 sensor_control " + sensorEnableStatus);
            if (!sensorEnableStatus) {
                if (!mHandler.hasMessages(Msg.WHAT_SENSOR_ENABLE)) {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_ENABLE, getRobotConfigParams().getSensorRecoveryEnableTime() * 1000);
                }
                stmExecute.executeTask(new StmTask().switchComponentEnable(false, StmTask.FuncPowerBit.BIT_SENSOR_POWER));
            }

            receiveData[2] = (byte) mBotInfoMgr.getRobotType().getTypeCode();

            //防止重启后回充，即使在2m外也会误触发到位
            if (getRobot().getMode() == MODE_GOTO_CHARGER) {
                if (AutoMoveManager.mTargetChargerNodeW != null && Math.abs(mDistance - AutoMoveManager.mTargetChargerNodeW.getTargetDistance()) < 2) {
                    receiveData[3] = (byte) MODE_GOTO_CHARGER;
                } else {
                    receiveData[3] = (byte) 0;
                }
            } else {
                receiveData[3] = (byte) (getRobot().getMode() != null ? getRobot().getMode() : 0);
            }

            if (mBotInfoMgr.isHaveSteer()) {
                int steerAngleH = (int) SteerController.getInstance().getCurHAngle() * 100;
                int steerAngleV = (int) SteerController.getInstance().getCurVAngle() * 100;

                if (inspectManager.mCurrentTaskNode != null && !TextUtils.isEmpty(inspectManager.mCurrentTaskNode.getAngleJson())) {
                    float[] angle = UConstants.getAngle(inspectManager.mCurrentTaskNode.getAngleJson());

                    steerAngleH = (int) (angle[0] * 100);
                    steerAngleV = (int) (angle[1] * 100);
                    SteerController.getInstance().resetAngleValueTo(angle[0], angle[1]);
                }

                receiveData[4] = ((byte) (steerAngleH >> 8));
                receiveData[5] = ((byte) steerAngleH);
                receiveData[6] = ((byte) (steerAngleV >> 8));
                receiveData[7] = ((byte) steerAngleV);

                receiveData[8] = ((byte) (9000 >> 8));
                receiveData[9] = ((byte) 9000);
                receiveData[10] = ((byte) (9000 >> 8));
                receiveData[11] = ((byte) 9000);
            }

            int local = StorageCenter.getRobotStorage().getInteger("motor_location", -1);
            ULog.d(TAG, "01 27 motor_location = " + local + " getRobot().getLocation = " + getRobot().getLocation());
            if (local == -1 && getRobot().getLocation() != null) {
                local = getRobot().getLocation();
            }

            receiveData[12] = ((byte) (local >> 24));
            receiveData[13] = ((byte) (local >> 16));
            receiveData[14] = ((byte) (local >> 8));
            receiveData[15] = ((byte) local);
            if (getRobot().getRfidDirection() == 0) {
                receiveData[16] = ((byte) -1);
            } else if (getRobot().getRfidDirection() == 1) {
                receiveData[16] = ((byte) 1);
            }

            //无缓存或非电梯机器，读新的方向，否则读缓存方向(在下位机获取设备类型的时候 设置机器人rfid方向
            if (UPreferences.getInt(mActivity, UConstants.ACTION_ROBOT_RFID_DIRECTION_ACTION, -1) == -1
                    || (getRobotConfigParams() == null
                    || (getRobotConfigParams() != null && !getRobotConfigParams().isHaveElevator())))
            {
                rfidDirection = getRobot().getRfidDirection() != null ? getRobot().getRfidDirection() : 1;
                UPreferences.putInt(mActivity, UConstants.ACTION_ROBOT_RFID_DIRECTION_ACTION, rfidDirection);
            } else {
                rfidDirection = UPreferences.getInt(mActivity, UConstants.ACTION_ROBOT_RFID_DIRECTION_ACTION, 1);
            }

            ULog.d(TAG,"getDeviceType rfidDirection:"+rfidDirection);

            if (rfidDirection == 0) {
                receiveData[16] = ((byte) -1);
            } else if (rfidDirection == 1) {
                receiveData[16] = ((byte) 1);
            }

            StmTask.updateDirection(rfidDirection,"q3");

            if (mIsRobotInitialized) {
                mHandler.removeMessages(Msg.WHAT_CHECK_WHEN_STM_RESET);
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_WHEN_STM_RESET, 4000);
            }
        }

        return receiveData;
    }

    private void offsetCorrect() {
        //控件
        View dialog_view = View.inflate(mActivity, R.layout.dialog_offset_calibration, null);
        EditText edtMile = dialog_view.findViewById(R.id.edt_mile_offset);
        EditText edtHOffset = dialog_view.findViewById(R.id.edt_h_offset);
        EditText edtVOffset = dialog_view.findViewById(R.id.edt_v_offset);
        Button btnConfirm = dialog_view.findViewById(R.id.btn_confirm);
        Button btnCancel = dialog_view.findViewById(R.id.btn_cancel);

        edtMile.setText(String.valueOf(MainApp.mileOffset));
        edtHOffset.setText(String.valueOf(MainApp.hAngleOffset));
        edtVOffset.setText(String.valueOf(MainApp.vAngleOffset));

        //初始化dialog
        AlertDialog serServerDialog = new AlertDialog.Builder(mActivity).setView(dialog_view).create();

        btnConfirm.setOnClickListener(v -> {
            String mOffset = edtMile.getText().toString().trim();
            String hOffset = edtHOffset.getText().toString().trim();
            String vOffset = edtVOffset.getText().toString().trim();
            if (TextUtils.isEmpty(mOffset) || TextUtils.isEmpty(hOffset) || TextUtils.isEmpty(vOffset)) {
                mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "不能为空", Toast.LENGTH_SHORT).show());
                return;
            }
            try {
                float tempM = Float.parseFloat(mOffset);
                int tempH = Integer.parseInt(hOffset);
                int tempV = Integer.parseInt(vOffset);
                MainApp.mileOffset = tempM;
                MainApp.hAngleOffset = tempH;
                MainApp.vAngleOffset = tempV;
                UPreferences.putFloat(mActivity, "MILE_OFFSET", MainApp.mileOffset);
                UPreferences.putInt(mActivity, "H_ANGLE_OFFSET", MainApp.hAngleOffset);
                UPreferences.putInt(mActivity, "V_ANGLE_OFFSET", MainApp.vAngleOffset);
            } catch (NumberFormatException e) {
                e.printStackTrace();
                mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "数值错误", Toast.LENGTH_SHORT).show());
                return;
            }

            serServerDialog.dismiss();
        });

        btnCancel.setOnClickListener(v -> {
            serServerDialog.dismiss();
        });

        serServerDialog.show();
    }
    private AlertDialog uploadConfigDialog;
    private void uploadSensorConfig() {
        View dialog_view = View.inflate(mActivity, R.layout.dialog_upload_sensor_config, null);
        RecyclerView rclView = dialog_view.findViewById(R.id.rcl_list);
        TextView emptyView = dialog_view.findViewById(R.id.tv_upload_config_empty);
        EditText etPath = dialog_view.findViewById(R.id.edt_minio_addr);

        String cacheDir = mActivity.getCacheDir().getAbsolutePath();
        ULog.d(TAG, "sensor_config cacheDir = " + cacheDir);
        boolean isEmpty = true;
        File[] childFiles = null;
        File configDir = new File(cacheDir);
        if (configDir.isDirectory()) {
            childFiles = configDir.listFiles();
            if (childFiles != null && childFiles.length > 0) {
                isEmpty = false;
            }
        }
        if (isEmpty) {
            rclView.setVisibility(View.GONE);
            emptyView.setVisibility(View.VISIBLE);
        } else {
            rclView.setVisibility(View.VISIBLE);
            emptyView.setVisibility(View.GONE);

            List<File> dataList = new ArrayList<>();
            for(File f : childFiles) {
                dataList.add(f);
            }
            MyBaseAdapter mAdapter = new MyBaseAdapter<File>(dataList, R.layout.item_upload_config) {
                @Override
                public void bindView(MyViewHolder holder, int position) {
                    if (dataList.size() > 0) {
                        holder.setNameText(R.id.tv_upload_config, dataList.get(position).getName());
                        holder.itemView.findViewById(R.id.bt_upload_config).setOnClickListener((view) -> {
                            String filePath = etPath.getText().toString();
                            if (TextUtils.isEmpty(filePath)) {
                                ULog.d(TAG, "sensor_config 请输入minIO地址");
                                mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "请输入minIO地址", Toast.LENGTH_SHORT).show());
                                return;
                            }
                            if (filePath.startsWith("https://")) {
                                filePath = "http://" + filePath.substring(7);
                            }
                            if (!filePath.contains("http")) {
                                filePath = "http://" + filePath;
                            }
                            String fName = dataList.get(position).getName();
                            if (!fName.contains("_sensor")) {
                                mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "文件名异常", Toast.LENGTH_SHORT).show());
                                return;
                            }
                            String dId = fName.substring(0, fName.indexOf("_sensor"));
                            if (TextUtils.isEmpty(dId)) {
                                mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "文件名异常!", Toast.LENGTH_SHORT).show());
                                return;
                            }
                            String serverName = "Config/sensor/" + dId + "/sensor_config.json";
                            ULog.d(TAG, "sensor_config url " + filePath + " local = " + dataList.get(position).getAbsolutePath() + " server " + serverName);
                            Minio configMinio = Minio.getInstance(filePath, filePath);
                            configMinio.client.setTimeout(10_000, 60_000, 60_000);
                            ((Button)view).setText("上传中");
                            configMinio.upload(dataList.get(position).getAbsolutePath(), serverName, new Minio.RequestCallBack() {
                                @Override
                                public void onSuccess() {
                                    ULog.d(TAG, "upload sensor_config= onSuccess");
                                    mActivity.runOnUiThread(() -> ((Button)view).setText("上传成功"));
                                }

                                @Override
                                public void onFail() {
                                    ULog.d(TAG, "upload sensor_config= onFail");
                                    mActivity.runOnUiThread(() -> ((Button)view).setText("上传失败"));
                                }
                            });
                        });
                    }
                }

            };
            LinearLayoutManager manager = new LinearLayoutManager(mActivity);
            rclView.setLayoutManager(manager);
            rclView.setAdapter(mAdapter);
        }

        AlertDialog.Builder builder = new AlertDialog.Builder(mActivity);
        builder.setView(dialog_view)
                .setCancelable(false)
                .setNegativeButton("关闭", (dialog, which) -> {
//                    isManualUpgrade = false;
//                    StmTaskExecute.isUpgrade = false;
//                    if (timer != null) {
//                        timer.cancel();
//                    }
//                    if (stmExecute != null) {
//                        stmExecute.unRegisterOnTaskListener(stmTaskListener);
//                    }
//                    isStmUpgrade = false;
                    uploadConfigDialog.dismiss();
                });
        uploadConfigDialog = builder.create();
        uploadConfigDialog.show();
    }
    //*************************************
    int repeatFindInPlaceNum = 0;//重复寻找到位开关次数

    private AlertDialog steerTestDialog;
    int[] steerTestArgs = new int[5];
    int steerTestMotor;
    TextView steerNum;
    //舵机老化测试
    private void steerTest() {
        View dialog_view = View.inflate(mActivity, R.layout.dialog_steer_test, null);
        Button steerStart = dialog_view.findViewById(R.id.bt_steer_start),
                steerStop = dialog_view.findViewById(R.id.bt_steer_stop),
                steerMotorB = dialog_view.findViewById(R.id.bt_steer_motor_back),
                steerMotorF = dialog_view.findViewById(R.id.bt_steer_motor_front);
        steerNum = dialog_view.findViewById(R.id.tv_steer_num);
        EditText etH = dialog_view.findViewById(R.id.edt_steer_h);
        EditText etV = dialog_view.findViewById(R.id.edt_steer_v);
        EditText etInterval = dialog_view.findViewById(R.id.edt_send_interval);
        steerNum.setText("次数统计: " + steering_engine_test_num);
        if (steerTestArgs[0] > 0) {
            etInterval.setText(String.valueOf(steerTestArgs[0]));
            etH.setText(steerTestArgs[1] + "/" + steerTestArgs[2]);
            etV.setText(steerTestArgs[3] + "/" + steerTestArgs[4]);
        }

        try {
            steerStart.setOnClickListener(view -> {
                String etHStr = etH.getText().toString(),
                        etVStr = etV.getText().toString(),
                        etIntervalStr = etInterval.getText().toString();
                if (TextUtils.isEmpty(etHStr) || TextUtils.isEmpty(etVStr) || TextUtils.isEmpty(etIntervalStr) ||
                        !etHStr.contains("/") || !etVStr.contains("/")) {
                    mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "参数错误!", Toast.LENGTH_SHORT).show());
                    return;
                }
                String[] argsH = etHStr.split("/");
                String[] argsV = etVStr.split("/");
                if (argsH.length != 2 || argsV.length != 2) {
                    mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "参数格式错误!", Toast.LENGTH_SHORT).show());
                    return;
                }
                int interval = Integer.parseInt(etIntervalStr),
                        minH = Integer.parseInt(argsH[0]),
                        maxH = Integer.parseInt(argsH[1]),
                        minV = Integer.parseInt(argsV[0]),
                        maxV = Integer.parseInt(argsV[1]);

                steerTestArgs = new int[] {interval, minH, maxH, minV, maxV};
                ULog.d(TAG, "舵机测试参数 " + Arrays.toString(steerTestArgs));
                mHandler.removeMessages(Msg.WHAT_STEERING_ENGINE_TEST);
                steering_engine_test_num = 0;
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_STEERING_ENGINE_TEST, 100);
            });
            steerStop.setOnClickListener(view -> {
                mHandler.removeMessages(Msg.WHAT_STEERING_ENGINE_TEST);
                steerTestMotor = 0;
                steering_engine_test_num = 0;
            });
            steerMotorB.setOnClickListener(view -> {
                steerTestMotor = 2;
            });
            steerMotorF.setOnClickListener(view -> {
                steerTestMotor = 1;
            });
        } catch (NumberFormatException e) {
            e.printStackTrace();
            mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "参数格式错误!!", Toast.LENGTH_SHORT).show());
            return;
        }

        AlertDialog.Builder builder = new AlertDialog.Builder(mActivity);
        builder.setView(dialog_view)
                .setCancelable(false)
                .setNegativeButton("关闭", (dialog, which) -> {
                    steerTestDialog.dismiss();
                });
        steerTestDialog = builder.create();
        steerTestDialog.show();
    }

    @Override
    @RequiresApi(api = Build.VERSION_CODES.FROYO)
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        ReclaimerInspection.getInstance(this).handleMessage(msg);
        switch (msg.what) {
            case Msg.WHAT_GET_READ_FILL_LIGHT_LEVEL:
                //读取补光灯亮度
                FillLightController.getInstance().getFillLightLevel();
                if (mHandler.hasMessages(Msg.WHAT_GET_READ_FILL_LIGHT_LEVEL)) {
                    mHandler.removeMessages(Msg.WHAT_GET_READ_FILL_LIGHT_LEVEL);
                }
                //每隔2秒获取一次
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_READ_FILL_LIGHT_LEVEL, 2 * 1000);
                break;
            case Msg.WHAT_BELT_CONVEYOR_STATUS:
                if (beltConveyorStatus != null && beltConveyorStatus.isConnect()) {

                    if (mHandler.hasMessages(Msg.WHAT_BELT_CONVEYOR_STATUS)) {
                        mHandler.removeMessages(Msg.WHAT_BELT_CONVEYOR_STATUS);
                    }
                    ULog.d(TAG, "handleMessage: 酸刺沟-主斜井- 皮带启停 发送消息询问继电器");
                    beltConveyorStatus.readInputStatus();
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_BELT_CONVEYOR_STATUS, 20 * 1000);
                }
                break;
            case Msg.WHAT_MOTOR_DRIVER_ENABLE://发送电机驱动使能
                ULog.i(TAG, "handleMessage: 强制使能:  mHandler接收到  发送电机驱动使能 指令 已发送给下位机");
                if (getRobot() != null && getRobot().getSendMotorDriverEnableDelayed() != null && MODE == MODE_UN_KNOW) {//正常模式
                    if (!mHandler.hasMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE)) {//如果当前Handler没有在发送电机驱动使能
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_MOTOR_DRIVER_ENABLE, getRobot().getSendMotorDriverEnableDelayed());
                        ULog.i(TAG, "handleMessage: 强制使能: 发送电机驱动使能 给 下位机 准备时常 " + getRobot().getSendMotorDriverEnableDelayed() + " 后再次发送");
                    }
                } else {
                    if (mHandler.hasMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE)) {
                        mHandler.removeMessages(Msg.WHAT_MOTOR_DRIVER_ENABLE);
                    }
                }
                stmExecute.executeTaskNonQueue(new StmTask().forceMotorDriveEnable());
                break;

            case Msg.WHAT_GET_STMID:
                if (TextUtils.isEmpty(stm32Id)) {
                    stmExecute.executeTask(new StmTask().readStmId());
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_STMID, 1000);
                }
                break;


            case Msg.WHAT_INIT_MQTT:
                ULog.d(TAG, "handler init mqtt");
                Observable.just(1)
                        .observeOn(Schedulers.io())
                        .subscribe(event -> {
                            //Mqtt初始化需要启动后台服务，Android限制应用需要在前台才能启动服务
                            if (UAppUtil.getInstance().isAppForeground(BaseApplication.getInstance(),
                                    BaseApplication.getInstance().getPackageName())) {
                                int mqttType = getRobot().getMqttType();
                                //本地服务local
                                ULog.d(TAG,"MqttHeartChecker 初始化mqtt...");
                                mMqttManager.init(mActivity.getApplicationContext(), getRobot().getId(), mqttType, UrlManager.getMqttAddr());
                                mMqttManager.registerMqttEventListener(this);
                            } else {
                                ULog.w(TAG, "APP不在前台，5s后再次初始化MQTT");
                                Message message = Message.obtain();
                                message.what = Msg.WHAT_INIT_MQTT;
                                mHandler.sendMessageDelayed(message, 5000);
                            }
                        });

                break;
            case Msg.WHAT_SEND_HEART:
                UExecutorService.getSpecialTPSendHeart().execute(() -> {
                    if (getRobot() != null && !TextUtils.isEmpty(getRobot().getType())) {
                        stmExecute.executeTaskNonQueue(new StmTask().sendStandardHeart(getRobot().getCharging(), batteryStatus));
                    }
                });
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_SEND_HEART, UConstants.HEART_INTERVAL);
                break;
            case Msg.WHAT_STEERING_ENGINE_TEST:
                if (steerTestArgs[0] <= 0) {
                    mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "参数错误!!!", Toast.LENGTH_SHORT).show());
                    break;
                }
                //15 75
                //345 180
                if (steering_engine_test_num % 2 == 0) {
//                    SteerController.getInstance().setSteerAngle(5, 75, RobotSetSpeedLogTags.SPEELD_lOG_TAG_11);
                    stmExecute.executeTask(new StmTask().setSteerEngineAngle(1, 1, steerTestArgs[1]));
                    stmExecute.executeTask(new StmTask().setSteerEngineAngle(1, 2, steerTestArgs[3]));
                } else {
                    stmExecute.executeTask(new StmTask().setSteerEngineAngle(1, 1, steerTestArgs[2]));
                    stmExecute.executeTask(new StmTask().setSteerEngineAngle(1, 2, steerTestArgs[4]));
//                    SteerController.getInstance().setSteerAngle(355, 180, RobotSetSpeedLogTags.SPEELD_lOG_TAG_11);
                }
                steering_engine_test_num++;
                if (steerTestMotor == 1) {
                    setRobotDirection(StmTask.MOVE_END,"steer_test_back");
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                } else if (steerTestMotor == 2) {
                    setRobotDirection(MOVE_FRONT,"steer_test_front");
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                }
                if (steerNum != null) {
                    mActivity.runOnUiThread(() ->steerNum.setText("次数统计: " + steering_engine_test_num));
                }
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_STEERING_ENGINE_TEST, steerTestArgs[0] * 1000);
                break;
            case Msg.WHAT_RFID_TIMEOUT: //RFID采集超时
                String timeOutTargetId = "";
                for (int i = 0; i < mqttMsgList.size(); i++) {
                    Map<String, String> map = mqttMsgList.get(i);
                    if (map.containsValue(MqttCommand.ROBOT_COLLECTION_INDEX_TYPE)) {
                        for (String key : map.keySet()) {
                            if (!TextUtils.isEmpty(key)) {
                                timeOutTargetId = key;
                                break;
                            }
                        }
                        if (!TextUtils.isEmpty(timeOutTargetId)) {
                            mqttMsgList.remove(map);
                            break;
                        }
                    }
                }
                if (TextUtils.isEmpty(timeOutTargetId)) {
                    break;
                }
                MqttCommand command = new MqttCommand();
                command.setSource(getRobot().getId());
                command.setTarget(timeOutTargetId);
                command.setType(MqttCommand.ROBOT_COLLECTION_INDEX_TYPE);
                command.setAction(MqttCommand.ROBOT_RESULT_FAIL_ACTION);
                if (MqttManager.getInstance().isConnected()) {
                    MqttManager.getInstance().publishMessage(command);
                }
                break;
            case Msg.WHAT_LIGHT_CLOSE:
                stmExecute.executeTask(new StmTask().sayByeBye());
                break;
            case Msg.WHAT_UPDATE_TV:
                tvSE.setText("舵机H:" + SteerController.getInstance().getCurHAngle() + " V:" + SteerController.getInstance().getCurVAngle());
                tvDistance.setText("位置:" + mDistance);
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_UPDATE_TV, 1500);
                break;
            case Msg.WHAT_PUSH_INIT:
                //                if (mAlivcLivePusher == null && getRobot() != null) {
                //                    getExecutorService().execute(new Runnable() {
                //                        @Override
                //                        public void run() {
                //                            Looper.prepare();
                //                            initPush();
                //                        }
                //                    });
                //                } else {
                //                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_PUSH_INIT, 2000);
                //                }
                break;
            case Msg.WHAT_PUSH_UPDATE://推流数据检测及更新
                Robot robot = (Robot) msg.obj;
                if (robot != null) {
//                    if (!getRobot().getPushEnable() && robot.getPushEnable()) {
//                        ULog.d(TAG, "updatePusher webCamera 网络摄像头上电");
//                        pushDeviceControl(true);
//                    }
//
	                if (getRobot().getPushEnable() != robot.getPushEnable()) {
		                if (robot.getPushEnable()) {
			                pushDeviceControl(true,"4", false);
		                } else {
			                pushDeviceControl(false,"5", true);
		                }
	                } else {
                        if (!robot.getPushEnable() && !IRService.isIrClosed) {
                            pushDeviceControl(false,"防止关推流时摄像头设备上电", true);
                        }
                    }

                    getRobot().setPushEnable(robot.getPushEnable());
                    getRobot().setCameraDomain(robot.getCameraDomain());
                    getRobot().setPlayCameraDomain(robot.getPlayCameraDomain());
                    getRobot().setNetworkCameraResolution(robot.getNetworkCameraResolution());
                    getRobot().setPushStreamType(robot.getPushStreamType());
                    getRobot().setPushLocalIp(robot.getPushLocalIp());
                }
                updatePusher(1);
                break;
            case Msg.WHAT_INIT_IN_IR_SDK_SUCCESS:
                isUpdateIrPusherIng = false;
                updateIrPusher(1);
                break;
            case Msg.WHAT_INIT_IR_SDK:
                //                    Looper.prepare();
                //                    Looper.loop();
                try {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IN_IR_SDK_SUCCESS, 1000);
                    getExecutorService().execute(() -> {
                        Thread.currentThread().setName("initLib");
                        mHandler.removeMessages(Msg.WHAT_INIT_IN_IR_SDK_SUCCESS);
                        initLib();
                    });
                } catch (Exception e) {
                    isUpdateIrPusherIng = false;
                    updateIrPusher(2);
                    e.printStackTrace();
                }
                break;
/*            case Msg.WHAT_UPLOAD_ST_ANGLE:
                //更新服务器舵机角度
                robotStatusUpload(5);
                break;*/
            case Msg.WHAT_SERVER_ROBOT_STATUS_HEART:
                Observable.just(1)
                        .observeOn(Schedulers.io())
                        .subscribe(event -> {
                            if (getRobot() != null) {
                                if (!isUpdateRobot) {
                                    robotStatusUpload(3);
                                }
                            }
                            isUpdateRobot = false;
                            if (getRobot() != null && getRobot().getPowerUpdateIntervalSecond() != 0) {
                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_SERVER_ROBOT_STATUS_HEART,
                                        getRobot().getPowerUpdateIntervalSecond() * 1000);
                            } else {
                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_SERVER_ROBOT_STATUS_HEART, 3000);
                            }
                        });
                break;
            case Msg.WHAT_SENSOR_RECORD_UPDATE:
                updateSegmentSensorStatus();
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_RECORD_UPDATE, 10_000);
                break;
            case Msg.WHAT_CONTINUE_INSPECTION:
                continueInspection(msg.arg1);
                break;
            case Msg.WHAT_CONTINUE_TASK:
                //红外录制时，如果遇到烟雾报警，延迟继续巡检，等待烟雾恢复
                if (mIsSmokeExceptionStop) {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_CONTINUE_TASK, 10 * 1000);
                    return;
                }

                inspectionIsStop = false;
                currentNodeIsExcepted = false;
                currentNodeIsExceptedBack = false;
                currentNodeAudioIsExcepted = false;

                if (MODE != MODE_INSPECTION && MODE != MODE_GOTO_CHARGER) {
                    return;
                }

                autoMoveManager.lastRealRFID = "";
                if (autoMoveManager.mCurrentNode != null && autoMoveManager.mCurrentNode.getType() != null) {
                    if (autoMoveManager.mCurrentNode.getType() == NodeType.HEAD || autoMoveManager.mCurrentNode.getType() == NodeType.HEAD_CHARGE) {
                        setRobotDirection(StmTask.MOVE_END,"14");
                    }
                    if (autoMoveManager.mCurrentNode.getType() == NodeType.TAIL || autoMoveManager.mCurrentNode.getType() == NodeType.TAIL_CHARGE) {
                        setRobotDirection(StmTask.MOVE_FRONT,"15");
                    }
                }
                //                if (!getRobot().getRobotTemperatureException())
                stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                break;
            case Msg.WHAT_TEST_BROAD:
                mActivity.sendBroadcast(new Intent("guard_test"));
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_TEST_BROAD, 2000);
                break;
            case Msg.WHAT_START_QUERY_DECIBEL:
                decibelExecute.executeTask(new DecibelTask().queryDecibel());
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_START_QUERY_DECIBEL, 100);
                break;
            case Msg.WHAT_READ_CACHE:
                readCache();
                break;
            case Msg.WHAT_LEAVE_CHARGER:
//                ULog.d(TAG, "Msg.WHAT_LEAVE_CHARGER 电量过高 离开充电桩");
//                prepareLeaveCharger();
//                float round = (float) (preventOverchargeDistance / 100.0 * 2.0 / UConstants.DISTANCE_TWO_ROUND);
//                stmExecute.executeTask(new StmTask().move(StmTask.MOVE_END, round));
                break;

            case Msg.WHAT_INSPECT_ALARM:
                int alarmInterval = getRobotConfigParams().getInspectAlarmAudioInterval();
                ULog.d(TAG, "巡检提示音 " + alarmInterval);
                if (alarmInterval <= 0) break;
                if (MODE == MODE_INSPECTION) {
                    AlarmManager.getInstance(MainApp.getInstance()).playInspectAlarm();
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_INSPECT_ALARM, (alarmInterval * 1000 + 2200));
                }
                break;
            case Msg.WHAT_NORMAL_STARTUP:
                ULog.d(TAG, "handleMessage: 正常启动 Msg.WHAT_NORMAL_STARTUP");
                //正常启动
                initData();
                break;
            case Msg.WHAT_CLEAN_STM_RFID:
                ULog.d(TAG, "Msg.WHAT_CLEAN_STM_RFID == rfid_clean_check = " + cleanStmRfids);
                if (!cleanStmRfids) {
                    stmExecute.executeTask(new StmTask().rfidClean());
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_STM_RFID, 3000);
                }
                break;
            case Msg.WHAT_UPDATE_BELT_STATUS:
                ULog.d(TAG, "beltConfig jdq checkExceptionData Msg.WHAT_UPDATE_BELT_STATUS obj " + msg.obj);
                if (System.currentTimeMillis() - lastUpdateBeltConfigTime < 5000) {
                    break;
                }
                lastUpdateBeltConfigTime = System.currentTimeMillis();

                if (mSegment != null && beltCheckType != -1) {
                    fun.unifun.library.cloud.client.inparam.segment.UpdateById segmentUpdateRequest = new fun.unifun.library.cloud.client.inparam.segment.UpdateById();
                    Segment param = new Segment();
                    param.setId(mSegment.getId());
                    param.setBeltResult((String) msg.obj);
                    ULog.d(TAG, "beltConfig jdq checkExceptionData upload getBeltResult = " + param.getBeltResult());
                    segmentUpdateRequest.setSegment(param);
                    UOKHttp.post(UrlManager.getBaseUrl(),
                            segmentUpdateRequest,
                            new UOKHttp.RequestCallBack<fun.unifun.library.cloud.client.inparam.segment.UpdateById>(fun.unifun.library.cloud.client.inparam.segment.UpdateById.class) {
                                @Override
                                public void onFailure(Call call, IOException e) {
                                    ULog.d(TAG, "onFailure: jdq checkExceptionData beltConfig Msg.WHAT_UPDATE_BELT_STATUS");
                                }

                                @Override
                                public void onResponseOk(Call call, fun.unifun.library.cloud.client.inparam.segment.UpdateById o) {
                                    ULog.d(TAG, "onResponseOk: jdq checkExceptionData beltConfig Msg.WHAT_UPDATE_BELT_STATUS");
                                }

                                @Override
                                public void onResponseError(Call call, int i, String s) {
                                    ULog.d(TAG, "onResponseError: jdq checkExceptionData beltConfig Msg.WHAT_UPDATE_BELT_STATUS");
                                    ;
                                }
                            });
                }
                break;
            case Msg.WHAT_CLOSE_NET_FLASH_LIGHT:
                if (netLightOpen) {
                    stmExecute.executeTask(new StmTask().setNetStatus(1));
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLOSE_NET_FLASH_LIGHT, 2000);
                }
                break;
            case Msg.WHAT_CHECK_BATTERY_STATUS:
                if (getRobot() != null) {
                    if (!getRobot().getCharging() && !batteryAutoOff) {
                        if ((getRobot().getException() >> 4 & 0x1) == 0) {
                            getRobot().setException(getRobot().getException() + 0b10000);
                            //                            if (!mHandler.hasMessages(Msg.WHAT_UPLOAD_EXCEPTION_STATE)) {
                            //                                mHandler.sendEmptyMessage(Msg.WHAT_UPLOAD_EXCEPTION_STATE);
                            //                            }
                        }
                        //无法充电 报警
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_CANNOT_CHARGE) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_CANNOT_CHARGE)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_CANNOT_CHARGE));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_CANNOT_CHARGE, true);
                        }

                        //充电异常 重新寻找到位开关
                        if (inCharger() && repeatFindInPlaceNum < 5) {
                            ULog.d("重新寻找到位开关 === repeatFindInPlaceNum:" + repeatFindInPlaceNum);
                            repeatFindInPlaceNum++;
                            MqttCommand moveBackCommand = new MqttCommand();
                            moveBackCommand.setSource("self");
                            moveBackCommand.setTarget(getRobot().getId());
                            moveBackCommand.setType(MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE);
                            moveBackCommand.setAction(MqttCommand.ROBOT_MOVE_BACK_ACTION);
                            onMessageReceived(moveBackCommand);
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_REPEAT_FIND_IN_PLACE_RELAY, 3 * 1000);
                        } else {
                            robotSleep();
                        }
/*                        Map<String, Object> chargingErrMap = new HashMap<>();
                        chargingErrMap.put("chargingError", 1);
                        MainApp.from(mActivity).pushLogMap(chargingErrMap);*/
                    } else if (getRobot().getCharging()) {
                        MainApp.batteryCheckStatus = StorageCenter.getRobotStorage().getInteger(KeyConstant.Storage.BATTERY_CHECK_STATUS, 0);
                        if (MainApp.batteryCheckStatus == 1) { //需要满放
                            ULog.d(TAG, "BMS_check 需要满放 尝试关闭发射端");
                            mHandler.sendEmptyMessage(Msg.WHAT_END_CHARGING);
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_END_CHARGING_CHECK, 60_000);
                        } else if (MainApp.batteryCheckStatus == 2) { //需要满充
                            ULog.d(TAG, "BMS_check 需要满充 等待电池充满");
                        }
                    }
                }
                break;
            case Msg.WHAT_REPEAT_FIND_IN_PLACE_RELAY:
                mHandler.sendEmptyMessage(Msg.WHAT_REPEAT_FIND_IN_PLACE);
                break;
            case Msg.WHAT_REPEAT_FIND_IN_PLACE:
                stmExecute.executeTaskNonQueue(new StmTask().stopMove("重新寻找到位开关 48"));
                MqttCommand inspectionChargingCommand = new MqttCommand();
                inspectionChargingCommand.setSource("self");
                inspectionChargingCommand.setTarget(getRobot().getId());
                inspectionChargingCommand.setType(MqttCommand.ROBOT_INSPECTION_INDEX_TYPE);
                inspectionChargingCommand.setAction(MqttCommand.ROBOT_INSPECTION_CHARGING_ACTION);
                onMessageReceived(inspectionChargingCommand);
                break;
            //            case Msg.WHAT_BACK:
            //                returnPreviousNode(msg.arg1);
            //                break;
            case Msg.WHAT_SET_PUT_TEXT:
                setPutText(UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_IR_PUT_TEXT, true));
                break;
            case Msg.WHAT_BIND_IR_SERVICE:
                if (getRobot().getIrCameraNum() == null || getRobot().getIrCameraNum() == 0) {
                    break;
                }
                bindIrService();
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_BIND_IR_SERVICE, 3000);
                break;
            case Msg.WHAT_BIND_RGB_SERVICE:
                if (getRobot().getRgbCameraNum() == null || getRobot().getRgbCameraNum() == 0) {
                    break;
                }
                bindRgbService();
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_BIND_RGB_SERVICE, 3000);
                break;
            case Msg.WHAT_BIND_NETWORK_SERVICE:
                bindNetworkService();
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_BIND_NETWORK_SERVICE, 3000);
                break;
            case Msg.WHAT_INIT_IR_ARR:
                Observable.just(1)
                        .observeOn(Schedulers.computation())
                        .subscribe(event -> {
                            ULog.d(TAG,
                                    "handleMessage:PUSH_STREAM_TYPE  ==== Msg.WHAT_INIT_IR_ARR   ir == " + widthIr + "  " + heightIr + "  rgb  = " + widthRgb + "   " + heightRgb);

                            //                            handleMessage:PUSH_STREAM_TYPE  ==== Msg.WHAT_INIT_IR_ARR   ir == 0  0  rgb  = 0   0
                            if (getRobot() == null || ((widthRgb == 0 || heightRgb == 0) && getRobot().getRgbCameraNum() != 0)) {
                                if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_ARR)) {
                                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_ARR, 3000);
                                }
                                return;
                            }
                            if (irServiceIsAlive() && irService.getWidth() != 0) {
                                widthIr = irService.getWidth();
                                heightIr = irService.getHeight();
                                irType = irService.getIrType();

                                if (widthIr == 206 && heightIr == 156) {
                                    frameRate = 9;
                                    widthIr = 208;
                                    heightIr = 160;
                                }
                                if (pushType == 0) {
                                    if (getRobot() != null) {
                                        if (getRobot().getIrCameraNum() == 1) {
                                            width = Math.max(widthIr, widthRgb);
                                            pushWidthIr = widthIr;
                                            pushHeightIr = heightIr;
                                        } else if (getRobot().getIrCameraNum() == 2) {
                                            width = Math.max(widthIr * 2, widthRgb);
                                            pushWidthIr = widthIr * 2;
                                            pushHeightIr = heightIr;
                                        } else if (getRobot().getIrCameraNum() == 3) {
                                            width = Math.max(widthIr * 3, widthRgb);
                                            pushWidthIr = widthIr * 3;
                                            pushHeightIr = heightIr;
                                        }
                                        if (getRobot().getRgbCameraNum() == 0) {
                                            height = heightIr;
                                        } else if (getRobot().getRgbCameraNum() == 1) {
                                            height = heightIr + heightRgb;
                                            pushWidthRgb = widthRgb;
                                            pushHeightRgb = heightRgb;
                                        } else if (getRobot().getRgbCameraNum() == 2) {
                                            height = heightIr + heightRgb * 2;
                                            pushWidthRgb = widthRgb;
                                            pushHeightRgb = heightRgb * 2;
                                        }
                                        ULog.d(TAG,
                                                "onMessageReceived: PUSH_STREAM_TYPE=== 3333 " + widthIr + "  irH " + heightIr + " rgbW " + widthRgb + "  rgbH " + heightRgb);
                                    }
                                } else if (pushType == 1 || pushType == 2) {
                                    if (getRobot().getIrCameraNum() == 1) {
                                        width = widthIr;
                                        pushWidthIr = widthIr;
                                    } else if (getRobot().getIrCameraNum() == 2) {
                                        width = widthIr * 2;
                                        pushWidthIr = widthIr * 2;
                                    } else if (getRobot().getIrCameraNum() == 3) {
                                        if (pushType == 1) {
                                            width = widthIr * 2;
                                            pushWidthIr = widthIr * 2;
                                        } else if (pushType == 2) {
                                            width = widthIr;
                                            pushWidthIr = widthIr;
                                        }
                                    }
                                    pushHeightIr = heightIr;
                                    height = heightIr;
                                }
                                ULog.d(TAG, "onMessageReceived: PUSH_STREAM_TYPE=== 44444=== " + width + "  = " + height);
                                if (width != 0 && height != 0) {
                                    outputNV12 = new byte[width * height * 3 / 2];
                                    h264 = new byte[width * height * 3 / 2];
                                    pushFrame = new byte[width * height * 4];
                                    outputFrame = new byte[width * height * 4];
                                    for (int i = 0; i < irBuff.length; i++) {
                                        irBuff[i] = new VideoBuff(pushWidthIr * pushHeightIr * 4);
                                        rgbBuff[i] = new VideoBuff(pushWidthRgb * pushHeightRgb * 4);
                                        pushBuff[i] = new VideoBuff(width * height * 4);
                                        if (mBotInfoMgr.getRobotMainType() == RobotMainType.CICADA) {
                                            recordBuff[i] = new VideoBuff(pushWidthIr * pushHeightIr * 4);
                                        } else {
                                            recordBuff[i] = new VideoBuff(width * height * 4);
                                        }
                                    }
                                }
                                if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                                    mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_SDK);
                                }
                            } else {
                                if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_ARR)) {
                                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_ARR, 3000);
                                }
                            }

                        });

                break;
            case Msg.WHAT_INIT_RGB_ARR:
                ULog.d(TAG, "handleMessage: Msg.WHAT_INIT_RGB_ARR   " + widthRgb + "   " + heightRgb + "   ==  " + rgbService.getWidth());
                if (rgbServiceIsAlive() && rgbService.getWidth() != 0) {
                    widthRgb = rgbService.getWidth();
                    heightRgb = rgbService.getHeight();
                } else {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_RGB_ARR, 3000);
                }

                break;
            case Msg.WHAT_CLEAN_PIC:
                getExecutorService().execute(new Thread(new Runnable() {
                    @Override
                    public void run() {
                        Thread.currentThread().setName("UploadExceptImg");
                        File picFile = new File(UConstants.ROLLER_FILE_DIR);
                        if (picFile.exists()) {
                            File[] picFiles = picFile.listFiles();
                            if (picFiles != null && picFiles.length != 0) {
                                List<String> uploadPic = new ArrayList<>(inspectManager.uploadPic);
                                for (File file : picFiles) {
                                    String fileName = file.getName();
                                    if (uploadPic.contains(fileName)) {
                                        ULog.d(TAG, "UploadExceptImg Msg.WHAT_CLEAN_PIC 异常图片 跳过删除 " + fileName);
                                        continue;
                                    }
                                    String idStr = fileName.substring(fileName.lastIndexOf("_") + 1, fileName.lastIndexOf("."));
                                    long timeStamp = Long.parseLong(fileName.substring(0, fileName.lastIndexOf("_")));
                                    long currentTime = System.currentTimeMillis();
                                    if (currentTime - timeStamp > 24 * 3600 * 1000) {
                                        ULog.d(TAG, "UploadExceptImg Msg.WHAT_CLEAN_PIC 超过24小时，删除 " + fileName);
                                        file.delete();
                                    }
                                }
                            }
                        }
                    }
                }));
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_PIC, 3600_000);//每小时检测一次
                break;
            //            case Msg.WHAT_IR_CHECK:
            //                if (getRobot() != null) {
            //                    if (irMaxTemperatures == null || irMaxTemperatures.size() == 0) {
            //                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_IR_CHECK, 10 * 1000);
            //                        break;
            //                    }
            //                    double[] tempTotals = new double[irMaxTemperatures.size()];
            //                    for (int i = 0; i < irMaxTemperatures.size(); i++) {
            //                        for (double temp : irMaxTemperatures.get(i)) {
            //                            tempTotals[i] += temp;
            //                        }
            //                    }
            //                    boolean isException = false;
            //                    for (double total : tempTotals) {
            //                        if (total == 0) {
            //                            isException = true;
            //                            break;
            //                        }
            //                    }
            //
            //                    if (isException) {
            //                        int stmBreak = UPreferences.getInt(mActivity, UConstants.PREFERENCES_STM_EXCEPTION_KEY, -1);
            //                        if (stmBreak == 0 || stmBreak == -1) {
            //                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_STM_EXCEPTION_KEY, 1);
            //                            //红外设备异常 报警
            //                            if (addAlarmCount(AlarmTypeEnum.ROBOT_IR_DEVICE_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_IR_DEVICE_EXCEPTION)) {
            //                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_IR_DEVICE_EXCEPTION));
            //                                setIsAlarmReported(AlarmTypeEnum.ROBOT_IR_DEVICE_EXCEPTION, true);
            //                            }
            //                        } else {
            //                            break;
            //                        }
            //                    }
            //                }
            //                mHandler.sendEmptyMessageDelayed(Msg.WHAT_IR_CHECK, 10 * 1000);
            //                break;
            case Msg.WHAT_SERVER_HEART:
                connectTest();
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_SERVER_HEART, 5000);
                break;
            case Msg.WHAT_SENSOR_RECORD:
                sensorRecordUpload();
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_RECORD, 15_000);
                break;
            case Msg.WHAT_COKE_OVEN_INSPECT:
                ULog.d(TAG, "CokeOven 焦炉巡检重试 = " + msg.arg1);
                startInspection(msg.arg1,"焦炉巡检重试");
                break;
            case Msg.WHAT_RGB_RECOGNITION_INSPECT:
                ULog.d(TAG, "RGB_RECOGNITION_INSPECT rgb上传文件识别巡检重试 = " + msg.arg1);
                startInspection(msg.arg1,"rgb上传文件识别巡检重试");
                break;
            case Msg.WHAT_RECORD_VIDEO_RECOGNITION_INSPECT:
                ULog.d(TAG, "RECORD_VIDEO_RECOGNITION_INSPECT 录像自动标定巡检重试 = " + msg.arg1);
                startInspection(msg.arg1,"录像自动标定巡检重试");
                break;
            case Msg.WHAT_START_CHARGING: //开始充电
                if (mCurrent >= 0) {
                    break;
                }
                if (mHandler.hasMessages(Msg.WHAT_END_CHARGING)) {
                    mHandler.removeMessages(Msg.WHAT_END_CHARGING);
                }
                if (MODE == MODE_AGING_TEST && !TextUtils.isEmpty(agingTestChargerId)) {
                    if (MqttManager.getInstance().isConnected()) {
                        MqttCommand startCharging = new MqttCommand();
                        startCharging.setSource(getRobot().getId());
                        startCharging.setTarget(agingTestChargerId);
                        startCharging.setType(MqttCommand.ROBOT_MANAGER_CHARGER_STATE_INDEX);
                        startCharging.setAction(MqttCommand.ROBOT_MANAGER_OPEN_CHARGE_ACTION);
                        mMqttManager.publishMessage(startCharging);
                    }
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_START_CHARGING, 15 * 1000);
                    break;
                }

                if (!inCharger()) {
                    return;
                }
                sendMessageToCharger(msg.what);
                break;

            case Msg.WHAT_SEND_CHARGER_MESSAGE:
                int type = msg.arg1;
                Observable.just(type)
                        .observeOn(Schedulers.io())
                        .subscribe(messageType -> {
                            ULog.d(TAG, "handleMessage: === 向充电桩发送消息 isChargerOnline = " + isChargerOnline + ", " +
                                    "mNearestCharger" + AutoMoveManager.mTargetChargerNodeW);
                            if (AutoMoveManager.mTargetChargerNodeW != null && AutoMoveManager.mTargetChargerNodeW.getCharger() != null) {
                                LoraTask.DEVICE_ADDRESS = AutoMoveManager.mTargetChargerNodeW.getCharger().getSelfLoraAddress() == null ? 0 : AutoMoveManager.mTargetChargerNodeW.getCharger().getSelfLoraAddress();
                                LoraTask.CHANNEL = AutoMoveManager.mTargetChargerNodeW.getCharger().getSelfLoraChannel() == null ? 0 : AutoMoveManager.mTargetChargerNodeW.getCharger().getSelfLoraChannel();
                            }

                            if (sendMessageMode == 0 && MqttManager.getInstance().isConnected() && isChargerOnline) {
                                MqttCommand sendCharger = new MqttCommand();
                                sendCharger.setSource(getRobot().getId());
                                sendCharger.setTarget(nearestChargerId);
                                if (type == Msg.WHAT_START_CHARGING) {
                                    ULog.d(TAG, "handleMessage: === 开始充电 发送");
                                    sendCharger.setType(MqttCommand.ROBOT_MANAGER_CHARGER_STATE_INDEX);
                                    sendCharger.setAction(MqttCommand.ROBOT_MANAGER_OPEN_CHARGE_ACTION);
                                } else if (type == Msg.WHAT_END_CHARGING) {
                                    ULog.d(TAG, "handleMessage: === 结束充电 发送");
                                    sendCharger.setType(MqttCommand.ROBOT_MANAGER_CHARGER_STATE_INDEX);
                                    sendCharger.setAction(MqttCommand.ROBOT_MANAGER_CLOSE_CHARGE_ACTION);
                                } else if (type == Msg.WHAT_START_DUSTING) {
                                    ULog.d(TAG, "handleMessage: === 开始除尘 发送");
                                    checkDustingSprayWater();
                                    sendCharger.setType(MqttCommand.ROBOT_MANAGER_DUSTING_STATE_INDEX);
                                    sendCharger.setAction(MqttCommand.ROBOT_MANAGER_OPEN_DUSTING_ACTION);
                                } else if (type == Msg.WHAT_END_DUSTING) {
                                    ULog.d(TAG, "handleMessage: === 结束除尘 发送");
                                    sendCharger.setType(MqttCommand.ROBOT_MANAGER_DUSTING_STATE_INDEX);
                                    sendCharger.setAction(MqttCommand.ROBOT_MANAGER_CLOSE_DUSTING_ACTION);
                                } else if (type == Msg.WHAT_OPEN_HEATER) {
                                    ULog.d(TAG, "handleMessage: === 打开加热 发送");
                                    sendCharger.setType(MqttCommand.CHARGER_TEMPERATURE_CONTROL_TYPE);
                                    sendCharger.setAction(MqttCommand.CHARGER_TEMPERATURE_CONTROL_OPEN_HEATER_ACTION);
                                } else if (type == Msg.WHAT_CLOSE_HEATER) {
                                    ULog.d(TAG, "handleMessage: === 关闭加热 发送");
                                    sendCharger.setType(MqttCommand.CHARGER_TEMPERATURE_CONTROL_TYPE);
                                    sendCharger.setAction(MqttCommand.CHARGER_TEMPERATURE_CONTROL_CLOSE_HEATER_ACTION);
                                } else if (type == Msg.WHAT_OPEN_COOLER) {
                                    ULog.d(TAG, "handleMessage: === 打开制冷 发送");
                                    sendCharger.setType(MqttCommand.CHARGER_TEMPERATURE_CONTROL_TYPE);
                                    sendCharger.setAction(MqttCommand.CHARGER_TEMPERATURE_CONTROL_OPEN_COOLER_ACTION);
                                } else if (type == Msg.WHAT_CLOSE_COOLER) {
                                    ULog.d(TAG, "handleMessage: === 关闭制冷 发送");
                                    sendCharger.setType(MqttCommand.CHARGER_TEMPERATURE_CONTROL_TYPE);
                                    sendCharger.setAction(MqttCommand.CHARGER_TEMPERATURE_CONTROL_CLOSE_COOLER_ACTION);
                                }
                                mMqttManager.publishMessage(sendCharger);
                            } else {
                                if (type == Msg.WHAT_START_CHARGING) {
                                    ULog.d(TAG, "onLora 通知充电桩 === 开始充电");
                                    loraTaskExecute.executeTask(new LoraTask().openCharger());
                                } else if (type == Msg.WHAT_END_CHARGING) {
                                    ULog.d(TAG, "onLora 通知充电桩 === 结束充电");
                                    loraTaskExecute.executeTask(new LoraTask().closeCharger());
                                } else if (type == Msg.WHAT_START_DUSTING) {
                                    ULog.d(TAG, "onLora 通知充电桩 === 开始除尘");
                                    loraTaskExecute.executeTask(new LoraTask().openDusting());
                                } else if (type == Msg.WHAT_END_DUSTING) {
                                    ULog.d(TAG, "onLora 通知充电桩 === 结束除尘");
                                    loraTaskExecute.executeTask(new LoraTask().closeDusting());
                                }
                            }
                        });

                break;
            case Msg.WHAT_END_CHARGING: //结束充电
                if (mIsWaitToLeaveCharger) {
                    mRetryLeaveChargerCount++;
                    ULog.d(TAG, "关闭充电 次数：" + mRetryLeaveChargerCount);

                    if (mRetryLeaveChargerCount >= 5) {
                        ULog.d(TAG, "关闭充电失败，延迟离开");

                        //实际发送一次 + 重试三次 ,视为关闭充电失败，直接延迟离开。
                        RxBus.getInstance().post(new RobotChargeEvent(RobotEventConstants.EVENT_CLOSE_CHARGER_SUCCESS));
                    }
                }

                if (mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
                    mHandler.removeMessages(Msg.WHAT_START_CHARGING);
                }
                if (MODE == MODE_AGING_TEST && !TextUtils.isEmpty(agingTestChargerId)) {
                    if (MqttManager.getInstance().isConnected()) {
                        MqttCommand startCharging = new MqttCommand();
                        startCharging.setSource(getRobot().getId());
                        startCharging.setTarget(agingTestChargerId);
                        startCharging.setType(MqttCommand.ROBOT_MANAGER_CHARGER_STATE_INDEX);
                        startCharging.setAction(MqttCommand.ROBOT_MANAGER_CLOSE_CHARGE_ACTION);
                        mMqttManager.publishMessage(startCharging);
                    }
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_END_CHARGING, 3000);
                    break;
                }
                sendMessageToCharger(msg.what);
                break;
            case Msg.WHAT_END_CHARGING_CHECK: {
                if (mCurrent >=0) {
                    ULog.d(TAG, "BMS_check 电池满放失败，直接进入满充阶段");
                    mHandler.removeMessages(Msg.WHAT_END_CHARGING);
                    MainApp.batteryCheckStatus = 2;
                    StorageCenter.getRobotStorage().putInteger(KeyConstant.Storage.BATTERY_CHECK_STATUS, 2);
                } else if (inCharger) {
                    ULog.d(TAG, "BMS_check 电池进入满放阶段成功，等待放电结束");
                }
            }
            break;
            case Msg.WHAT_GET_SEGMENT: {
                getSegmentInfo();

                if (!mHandler.hasMessages(Msg.WHAT_GET_SEGMENT)) {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_SEGMENT, UConstants.retryTime);
                }
            }
            break;
            case Msg.WHAT_UPLOAD_HIS_TIME:
                String hisTimeRecordStr = StorageCenter.getRobotStorage().getString("his_time_records", "");
                ULog.d(TAG, "Msg.WHAT_UPLOAD_HIS_TIME updateHistoryTime = " + hisTimeRecordStr);
                if (!TextUtils.isEmpty(hisTimeRecordStr)) {
                    HashMap<Long, HistoryTime> tmpMap = gson.fromJson(hisTimeRecordStr, new TypeToken<HashMap<Long,
                            HistoryTime>>() {
                    }.getType());
                    if (tmpMap != null && tmpMap.size() > 0) {
                        hisTimeRecords.clear();
                        hisTimeRecords.putAll(tmpMap);
                        for (Long key : hisTimeRecords.keySet()) {
                            updateHisTimeRequest(hisTimeRecords.get(key));
                        }
                    }
                }
                break;
            case Msg.WHAT_XM_INIT:
                if (!XMWebCamera.getInstance().isInit) {
                    XMWebCamera.getInstance().setDeviceManager(DeviceManager.getInstance());
                    if (XMWebCamera.getInstance().init()) {
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_XM_INIT, 5000);
                    } else {
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_XM_INIT, 2000);
                    }
                }
                break;
            case Msg.WHAT_SAVE_TEMPERATURE:
                isStopSave = true;
                try {
                    Thread.sleep(8000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                getExecutorService().execute(new SaveTemperatureThread());
                break;
            //            case Msg.WHAT_UPLOAD_EXCEPTION_STATE:
            //                uploadExceptionState();
            //                break;
            case Msg.WHAT_CHECK_NETWORK_STATE://检查当前网络模式wifi 4G
                checkNetworkState();
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_NETWORK_STATE, 10000);
                break;

            case Msg.WHAT_GET_ACCOUNTS:
                getAccounts();
                break;
            case Msg.WHAT_OPEN_HEATER:
            case Msg.WHAT_CLOSE_HEATER:
            case Msg.WHAT_OPEN_COOLER:
            case Msg.WHAT_CLOSE_COOLER:
            case Msg.WHAT_START_DUSTING:
                sendMessageToCharger(msg.what);
                break;
            case Msg.WHAT_END_DUSTING:
                if (MODE == MODE_DEVICE_CLEAN) {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_END_DUSTING, 3000);
                    break;
                }
                sendMessageToCharger(msg.what);
                break;
            case Msg.WHAT_QUIT_MOVE_HINDER_STATUS:
                ULog.d(TAG, "WHAT_QUIT_MOVE_HINDER_STATUS 退出运动阻碍状态");
                mBotInfoMgr.setRobotActionCode(robotDirection == MOVE_FRONT ? RobotActionCode.MOVE_FRONT :
                        RobotActionCode.MOVE_END);
                break;
            case Msg.WHAT_OPEN_DUSTING_TIMEOUT:
                ULog.d(TAG, "除尘超时 === needOpenDusting " + needOpenDusting + " inCharger " + inCharger());
                if (needOpenDusting && inCharger()) {
                    needOpenDusting = false;
                    mHandler.removeMessages(Msg.WHAT_START_DUSTING);
                    goChargerEndHandleNext();
                }
                break;
            case Msg.WHAT_MOVE_CHECK: {
                boolean motionHinderInvalid = (System.currentTimeMillis() - motionHinderTime > 5000);
                ULog.d(TAG,
                        MessageFormat.format(
                                "handleMessage: === 移动检测  isCameraDrop = {0} rgb {1} ir {2} isReconnect {3} MODE {4}  isStop {5} previous" +
                                        " {6} mDistance {7} motionHinderInvalid {8} ir_SmartPusher {9} rgb_SmartPusher {10}," +
                                        "waitRoomOpen={11}, waitRoomClose={12}, ActionCode={13}, ActionReason={14}，stopStatus={15} ,alarm ={16}",
                                isCameraDrop,
                                isRgbException,
                                isIrException,
                                isReConnect,
                                MODE,
                                robotIsStop(),
                                distanceCheck,
                                mDistance,
                                motionHinderInvalid,
                                SmartPusher.connectErrorNum,
                                SmartRtspToRtmp.connectErrorNum,
                                RobotStatus.getIsWaitRoomDoorOpen(),
                                RobotStatus.getIsWaitRoomDoorClose(),
                                mBotInfoMgr.getRobotActionCode(),
                                mBotInfoMgr.getRobotActionReason(),
                                CokeOvenInspectManager.stopStatus,
                                getIsAlarmReported(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_WITH_LOCATION)));

                long currentTime = System.currentTimeMillis();
                String stKey = sdfYMD.format(new Date(currentTime));
                if (!MainApp.mStInfoUpload.containsKey(stKey)) {
                    MainApp.mStInfo.setCurrentTime(currentTime);
                    MainApp.mStInfoUpload.put(stKey, MainApp.mStInfo);
                    String stJson = gson.toJson(MainApp.mStInfoUpload);
                    StorageCenter.getRobotStorage().putString(UConstants.PREFERENCES_ROBOT_UPLOAD_STATUS_VALUE_KEY, stJson);
                    ULog.d(TAG, "缓存需要上传的统计信息 = " + stJson);
                }
                if (!MainApp.mStInfoUpload.isEmpty()) {
                    uploadStInfoMap();
                }

                if (!mHandler.hasMessages(Msg.WHAT_CLEAN_PIC)) {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_PIC, 1800_000);
                }
                if (!robotIsStop() && UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_BMS_QUERY_SLOW, false)) {
                    UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_BMS_QUERY_SLOW, false);
                    BaseBmsCommunicator.getInstance().restartContinuousQuery();
                }
                /**堵转恢复，取消报警
                 * 条件：堵转报警超过5s,且已发送过堵转报警信息，且已开始移动
                 * */
                if (!robotIsStop() && getIsAlarmReported(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_WITH_LOCATION) && motionHinderInvalid) {
                    ULog.d(TAG, "运动阻碍恢复");
                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_WITH_LOCATION_RESUME));
                    setIsAlarmReported(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_WITH_LOCATION, false);
                    sendMqttAll(getRobot().getId(),
                            MqttCommand.ROBOT_SEND_ROBOT_INFO_INDEX,
                            MqttCommand.ROBOT_MOVEMENT_HINDRANCE_WITH_LOCATION_RESUME,
                            null);
                }
                fixErrorHisTime();
                StorageCenter.getRobotStorage().putString("his_time_records", gson.toJson(hisTimeRecords));
                StorageCenter.getRobotStorage().saveAsync();
                //检测取料机
                checkStartOrStopReclaimer();
                if (MODE == MODE_UN_KNOW) {
                    //开始上传
                    List<String> exceptionImg = new ArrayList<>(inspectManager.uploadPic);
                    if (exceptionImg.size() != 0) {
                        getExecutorService().execute(inspectManager.new UploadExceptImg(exceptionImg));
                    }
                    //                    File fileDirectory = new File(UConstants.ROLLER_FILE_DIR);
                    //                    if (fileDirectory.isDirectory()) {
                    //                        File[] childFiles = fileDirectory.listFiles();
                    //                        if (childFiles != null && childFiles.length != 0) {
                    //                            UExecutorService.getMainExecutors().submit(inspectManager.new UploadTaskNodeImg());
                    //                        }
                    //                    }
                }

                /**
                 * 堵转超过一分钟恢复
                 */
                //if (!isStop() && getIsAlarmReported(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_SUSTAINED_WITH_LOCATION) && motionHinderInvalid) {
                //    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_SUSTAINED_WITH_LOCATION_RESUME));
                //    setIsAlarmReported(AlarmTypeEnum.ROBOT_MOVEMENT_HINDRANCE_SUSTAINED_WITH_LOCATION, false);
                //}

                /**
                 * 离开充电桩时，把 inCharger 置为false
                 * 条件：当前在充电桩，且为巡检模式，且已开始移动
                 * 暂无必要，标志位修改时已设置保存
                 */
                //                if (!isStop() && MODE == MODE_INSPECTION && inCharger()) {
                //                   setInCharger(false,"移动检测");
                //                    UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
                //                }
                /**
                 * 相机（热成像、rgb）掉线恢复了，恢复移动
                 * 条件：相机掉线，现在已恢复，且没有处于断网重连中，且为停止移动状态，且点击堵转超过5s ,且不处于UNKNOW模式
                 * 如果在UNKNOW模式，可能导致不必要的移动，如已在充电中，相机恢复
                 */
                if (isCameraDrop && !isRgbException && !isIrException && !isReConnect && robotIsStop() && motionHinderInvalid && MODE != MODE_UN_KNOW) {
                    isCameraDrop = false;
                    stmExecute.executeTaskNonQueue(new StmTask().nonForceMotorDriveEnable());
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                }
                /**
                 * 恢复巡检
                 * 条件；巡检模式下，巡检停止（handleNodeInfo时停止移动，停止红外了录制并上传），RGB、Ir未掉线，停止移动状态，非断网重连，电机堵转超过5s
                 * */
                if (MODE == MODE_INSPECTION && !inspectionIsStop && !isRgbException && !isIrException && robotIsStop() && !isReConnect && motionHinderInvalid
                        && !RobotStatus.getIsWaitRoomDoorOpen() && (!CokeOvenInspectManager.stopStatus || (System.currentTimeMillis() - CokeOvenInspectManager.stopTime) > 10000)) {
                    stmExecute.executeTaskNonQueue(new StmTask().nonForceMotorDriveEnable());
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                    cleanMoveHinder(2);
                    if (inCharger()) {
                        setInCharger(false,"移动检测恢复巡检");
                        UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
                    }
                }
                //非巡检到指定位置
                if ((MODE == MODE_INSPECTION || MODE == MODE_CHECKING_STOP) && sensorStatusRecordMap.size() != 0 && InspectManager.targetInspectLocation == UConstants.UNKONW) {
                    for (String id : sensorStatusRecordMap.keySet()) {
                        //雨量超过阈值 & 1分钟内更新过数据
                        if (sensorStatusRecordMap.get(id).getType() == 9 && sensorStatusRecordMap.get(id)
                                .isException() && sensorStatusRecordMap.get(id)
                                .getUpdateTime()
                                .getTime() > (new Date().getTime() - 60_000)) {
                            ULog.d(TAG, "检测到下雨，中止巡检");
                            mMqttManager.broadcastShowInfo("检测到下雨，中止巡检");
                            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_DETECT_RAIN_STOP_INSPECT);
                            autoMoveManager.gotoChargerCheck("检测到下雨_回充");
                        }
                    }
                }
                /**
                 * 恢复回充移动，以重新找到位开关
                 * 条件；回充模式下，因某些原因停止移动，但到位开关越界次数小于等于10次，且电机堵转超过5s，且不再充电桩
                 *
                 */
                if (MODE == MODE_GOTO_CHARGER && robotIsStop() && gotoChargerCrossingNum < 11 && motionHinderInvalid && !inCharger()
                        && !RobotStatus.getIsWaitRoomDoorOpen()) {
                    stmExecute.executeTaskNonQueue(new StmTask().nonForceMotorDriveEnable());
                    if (mDistance < -0.2) {
                        setRobotDirection(MOVE_END, "移动检测-回充向后");
                    }
                    if (mDistance > autoMoveManager.maxRFIDDistance + 0.2) {
                        setRobotDirection(MOVE_FRONT, "移动检测-回充向前");
                    }
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                    cleanMoveHinder(3);
                }
                if (MODE == MODE_INSPECTION && getRobot().getSpeed() > 0.01 && !sensorEnableStatus && !mHandler.hasMessages(Msg.WHAT_SENSOR_ENABLE)) {
                    ULog.d(TAG, "巡检状态下检测到传感器关闭_sensor_control_true delay = " + getRobotConfigParams().getSensorRecoveryEnableTime());
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_ENABLE, getRobotConfigParams().getSensorRecoveryEnableTime() * 1000);
                }

                if (MODE == MODE_DEVICE_CLEAN && robotIsStop() && motionHinderInvalid) {
                    setSpeed(UConstants.DEFAULT_GOTO_CHARGER_SPEED, "Clean");
                    setRobotDirection(MOVE_END,"16");
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                }

                if (MODE == MODE_AGING_TEST && !agingTestGoTOCharger && robotIsStop() && motionHinderInvalid) {
                    stmExecute.executeTaskNonQueue(new StmTask().nonForceMotorDriveEnable());
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                }
                distanceCheck = mDistance;

                if (MODE == MODE_UN_KNOW && !inCharger()) {
                    int goChargerTimeout = getRobotConfigParams().getCountdownGoCharger();
                    if (goChargerTimeout != 0) {
                        float time1 = 0, time2 = 0;
                        if (modeUnknowTime != 0) {
                            time1 = (float) ((System.currentTimeMillis() - modeUnknowTime) / 1000.0 / 60.0);
                        }
                        if (userControlTime != 0) {
                            time2 = (float) ((System.currentTimeMillis() - userControlTime) / 1000.0 / 60.0);
                        }
                        float time3 = time1 == 0 ? time2 : time1;
                        time3 = time2 == 0 ? time1 : time2;
                        if (time1 != 0 && time2 != 0) {
                            time3 = Math.min(time1, time2);
                        }
                        if (time3 > goChargerTimeout) {
                            if (moveHinderNeedSleep && !moveHinderLowPower) {
                                ULog.w(TAG,"长时间无人操作/无任务 执行回充 但是运动阻碍，等待人为控制，不执行回充逻辑");
                            } else {
                                if (moveHinderNeedSleep) {
                                    moveHinderLowPower = false;
                                    UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_LOW_POWER_GO_CHARGER_KEY, false);
                                }
                                ULog.d(TAG, "长时间无人操作/无任务 执行回充 goChargerTimeout " + goChargerTimeout + " time3 " + time3);
                                modeUnknowTime = 0;
                                userControlTime = 0;
                                //回充
                                autoMoveManager.gotoChargerCheck("长时间无人操作/无任务_回充");
                            }
                        }
                    }
                }

                if (serverHeartNormal && (System.currentTimeMillis() - serverHeartNormalTime) < 30_000) {
                    //确认有网的情况下
                    if (SmartPusher.connectErrorNum > 10) {
                        ULog.d(TAG, "SmartPusher红外推流重连");
                        getIrPusher().resetIrUrl(getPushIrUrl());
                    }
                    if (SmartRtspToRtmp.connectErrorNum > 10) {
                        ULog.d(TAG, "SmartPusher RGB推流重连");
                        getWebCameraPusher().resetPushUrl(getPushWebUrl());
                    }
                }
                //rfid检测
//                if (rfidReadType == 0 || rfidReadType == 1) {
//                    RfidController.getInstance().readPower();
//                    rfidReadNum++;
//                    if (rfidReadNum > 5) {
//                        ULog.d(TAG, "rfid读取功率测试 read " + rfidReadNum + " receive " + RfidController.readReceivePowerNum);
//                        if (RfidController.readReceivePowerNum == 0) {
//                            resetRfidGpio();
//                        }
//                        rfidReadNum = 0;
//                        RfidController.readReceivePowerNum = 0;
//                    }
//                }
                //读功率时会停止寻签，改用5分钟没读取到则重启
                RfidInfo lastRfidInfo = RfidController.getInstance().getLastRfidInfo();
                if ((rfidReadType == 0 || rfidReadType == 1) && (System.currentTimeMillis() - lastResetRfidGpioTime > 300_000) && lastRfidInfo == null && SystemClock.elapsedRealtime() > 600_000) {
                    ULog.d(TAG, "开机超过十分钟，未读到过标签，重启模块");
                    resetRfidGpio(1);
                }
                if ((rfidReadType == 0 || rfidReadType == 1) && (System.currentTimeMillis() - lastResetRfidGpioTime > 300_000) && lastRfidInfo != null && System.currentTimeMillis() - lastRfidInfo.getTime() > 300_000) {
                    ULog.d(TAG, "5分钟未读到过标签，重启模块");
                    resetRfidGpio(1);
                }
                if (AutoMoveManager.mTargetChargerNodeW == null) {
                    AutoMoveManager.mTargetChargerNodeW = ChargerNodeManager.getInstance().computeNearestChargerNodeWrapper(mDistance,"5");
                }
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_MOVE_CHECK, 10_000);
            }
            break;
            case Msg.WHAT_SENSOR_ENABLE:
                ULog.d(TAG, "传感器延迟上电 执行sensor_control_true");
                stmExecute.executeTask(new StmTask().switchComponentEnable(true, StmTask.FuncPowerBit.BIT_SENSOR_POWER));
                break;
            case Msg.WHAT_START_INSPECTION:
                startInspection("HandlerMsg触发");
                break;
            case Msg.WHAT_IFCONFIG_EXCEPTION:
                ifconfigException("timeout_flag");
                break;
            case Msg.WHAT_UPDATE_RSSI:
                if (getRobot() != null) {
                    ULog.d(TAG, "handleMessage: === currentRssiLevel: " + currentRssiLevel + ",strongestRssiLevel: " + strongestRssiLevel);
                    ULog.e("Msg.WHAT_UPDATE_RSSI === 当前信号：" + currentRssiLevel + ",当前信号源：" + currentBssidName + ", 最强信号：" + strongestRssiLevel + ",最强信号源：" + strongestBssidName);
                    if (NetworkUtils.isConnected() || NetworkUtils.isWifiConnected()) {
                        getRobot().setCurrentRssi(currentRssiLevel);
                        getRobot().setStrongestRssi(strongestRssiLevel);
                        getRobot().setCurrentBssid(currentBssidName);
                        getRobot().setStrongestBssid(strongestBssidName);
                    } else {
                        getRobot().setCurrentRssi(0);
                        getRobot().setStrongestRssi(0);
                        getRobot().setCurrentBssid("");
                        getRobot().setStrongestBssid("");
                    }
                }
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_UPDATE_RSSI, 2000);
                break;
            case Msg.WHAT_RESET_ALERT:
                ULog.d(TAG, "reset alert  重置报警");
                //重置所有报警状态
                //                clearAllAlarmStatistics();

                mHandler.sendEmptyMessageDelayed(Msg.WHAT_RESET_ALERT, 30 * 60 * 1000);
                break;
            case Msg.WHAT_PUSH_RATE_CHECK:
                ULog.d(TAG, "alivc Msg.WHAT_PUSH_RATE_CHECK == " + pushAdjustBitRateNum);
                if (pushAdjustBitRateNum <= 1) {
                    reInitIr();
                    break;
                }
                pushAdjustBitRateNum = 0;
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_PUSH_RATE_CHECK, 30_000);
                break;
            case Msg.WHAT_GET_NETWORK_SPEED:
                double[] eth0Result = UNet.getEth0SpeedInfo();

//                double webCamSpeed = SmartRtspToRtmp.getNetRxCameraSpeed();
                double rx = UNet.getNetRxSpeedByte() - eth0Result[1];
                rx = rx < 0 ? 0 : rx;
                String netRxSpeed = UNet.formatSpeed(rx);
                double tx = UNet.getNetTxSpeedByte() - eth0Result[2];
                tx = tx < 0 ? 0 : tx;
                String netTxSpeed = UNet.formatSpeed(tx);
                ULog.d(TAG, "NetworkService_网络速度 = 下载:" + netRxSpeed + " 上传:" + netTxSpeed + " eht0下载:" + UNet.formatSpeed(eth0Result[1]) + " eht0上传:" + UNet.formatSpeed(eth0Result[2]) + " eht0耗时:" + eth0Result[0]);
//                ULog.e("== 信号强度 === curBssid ：" + getRobot().getCurrentBssid() + ", curRssi : " + getRobot().getCurrentRssi() + "; Bssid ：" + getRobot().getStrongestBssid() + ", Rssi : " + getRobot().getStrongestRssi());

                getRobot().setNetworkRxSpeed(netRxSpeed);
                getRobot().setNetworkTxSpeed(netTxSpeed);
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_NETWORK_SPEED, 2000);
                break;

            case Msg.WHAT_SET_NET_IP: {
                NetWorkUtils.migrateEth0ToSameNetwork(getRobot().getNetworkCameraIp());
            }
            break;

            case Msg.WHAT_CHECK_WEB_CAMERA: {
                checkRobotVersion();
                updatePusher(2);
                WebCamManager.getInstance().findWebCam().subscribe(new NextErrorObserver<String>() {
                    @Override
                    public void onNext(@NonNull String s) {
                        ULog.d(TAG, "网络摄像头 === onFindSuccess ===");

                        int webCamType = 0;
                        if (mSensorManager.cacheInfo().WEBCAM_INFO != null) {
                            if (mSensorManager.cacheInfo().WEBCAM_INFO.getType().equals("3")) {
                                webCamType = 3;
                            }

                            FillLightController.getInstance().init(mSensorManager.cacheInfo().WEBCAM_INFO.getNightVisionChangeThreshold(),
                                    mSensorManager.cacheInfo().WEBCAM_INFO.getNightVisionFloatRange());
                        }
                        //cicada 找到摄像头之后 中恒视通设置为保持聚焦  视辉设置为手动聚焦
                        if (mBotInfoMgr.getRobotMainType() == RobotMainType.CICADA) {
                            WebCamManager.getInstance().setFocusMode(webCamType == 3 ? 4 : 1);
                        }

                        if (webCamType == 3) {
                            WebCamManager.getInstance().changeConfigFile(0, 0, "").subscribe(ObserverFactory.createDefaultObserver());
                        }

                        //找到摄像头 开始推流
                        if (!mHandler.hasMessages(Msg.WHAT_WEB_CAMERA_PUSH)) {
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_WEB_CAMERA_PUSH, 1000);
                        }
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_WEB_CAMERA_CORRECT_TIME, 1000);

                        setAlarmCount(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION, 0);

                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION, false);
                        }
                    }

                    @Override
                    public void onError(@NonNull Throwable e) {
                        String eth0 = NetWorkUtils.getEtherNetIP();
                        if (!mHandler.hasMessages(Msg.WHAT_WEB_CAMERA_CORRECT_TIME))
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_WEB_CAMERA_CORRECT_TIME, 1000);
                        ULog.d(TAG, "网络摄像头 === onFindFailure ===111=== eth0:" + eth0);
                        NetWorkUtils.migrateEth0ToSameNetwork(getRobot().getNetworkCameraIp());
                        boolean isRet = checkWebCameraIsOnLine(e.getMessage(), () -> {
                            if (!mHandler.hasMessages(Msg.WHAT_CHECK_WEB_CAMERA)) {
                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_WEB_CAMERA, 1000);
                            }
                        });
                        if (!isRet) {
                            eth0 = UNet.getIpAddress("eth0");
                            ULog.d(TAG, "网络摄像头 === onFindFailure ===222=== eth0:" + eth0);
                            if (!mHandler.hasMessages(Msg.WHAT_CHECK_WEB_CAMERA)) {
                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_WEB_CAMERA, 5 * 1000);
                            }
                        }
                    }
                });
            }
            break;
            case Msg.WHAT_WEB_CAMERA_CORRECT_TIME:
//                WebCamManager.getInstance().setSystemTime(System.currentTimeMillis()).subscribe(ObserverFactory.createDefaultObserver());
                WebCamManager.getInstance().setSystemTime(System.currentTimeMillis()).subscribe(new Observer<String>() {
                    @Override
                    public void onSubscribe(@NonNull Disposable d) {

                    }

                    @Override
                    public void onNext(@NonNull String s) {

                    }

                    @Override
                    public void onError(@NonNull Throwable e) {

                    }

                    @Override
                    public void onComplete() {
                        setAlarmCount(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION, 0);

                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_WEB_CAMERA_FIND_ERROR_EXCEPTION, false);
                        }
                    }
                });
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_WEB_CAMERA_CORRECT_TIME, 30000);
                break;
            case Msg.WHAT_WEB_CAMERA_PUSH:
                Observable.just(1)
                        .observeOn(Schedulers.io())
                        .subscribe(t -> {
                            //对ip进行拼包，耗时操作
                            if (!UNet.ping() && !UrlManager.notPublicServer()) {
                                ULog.d(TAG, "网络摄像头 === 网络有问题，无法推流 ===");
                                if (!mHandler.hasMessages(Msg.WHAT_CHECK_WEB_CAMERA)) {
                                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_WEB_CAMERA, 10 * 1000);
                                }
                                return;
                            }
                            updatePusher(3);
                        });
                break;
            //            case Msg.WHAT_CHECK_CAMERA_PUSH:
            //                //推流出错 直接返回检查掉线
            //                if (webCameraPushError) {
            //                    return;
            //                }
            //                //推流没问题 检查掉线
            //                ULog.d(TAG, "检查网络摄像头掉线 === currentProgressTime ： " + currentProgressTime + ", lastProgressTime : " + lastProgressTime);
            //                if (currentProgressTime != 0) {
            //                    if (currentProgressTime != lastProgressTime) {wwwww
            //                        ULog.d(TAG, "网络摄像头 === 没掉线 ===");
            //                        //认为没掉线
            //                        lastProgressTime = currentProgressTime;
            //                    } else {
            //                        ULog.d(TAG, "网络摄像头 === 掉线了 ===");
            //                        //认为掉线
            //                        if (webCameraPusher != null) {
            //                            ULog.d(TAG, "网络摄像头 === 停止并重新推流 ===");
            //                            webCameraPusher.stopPush();
            //                            //重置
            //                            lastProgressTime = 0;
            //                            if (!mHandler.hasMessages(Msg.WHAT_CHECK_WEB_CAMERA)) {
            //                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_WEB_CAMERA, 3 * 1000);
            //                            }
            //                        }
            //                    }
            //                }
            //                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_CAMERA_PUSH, 10 * 1000);
            //                break;
            case Msg.WHAT_GET_AUDIO_STREAM:
                getExecutorService().execute(new Runnable() {
                    @Override
                    public void run() {
                        Thread.currentThread().setName("audioPlay");
                        if (mBotInfoMgr.getRobotMainType() == RobotMainType.CICADA) {
                            String playAudioUrl = UrlManager.getPlayUrl("rtmp",
                                    getRobot().getId(),
                                    getRobot().getVersion(),
                                    getRobot().getPlayCameraDomain(),
                                    UrlManager.PUSH_SUFFIX_AUDIO);
                            if (getRobot().getPushStreamType() == PushManager.PUSH_LAN) {
                                if(getRobot().getPushLocalIp().contains("://")){
                                    playAudioUrl = StrUtil.format("{}/hls/{}{}",
                                            getRobot().getPushLocalIp(),
                                            getRobot().getId(),
                                            UrlManager.PUSH_SUFFIX_AUDIO);
                                }else{
                                    playAudioUrl = StrUtil.format("rtmp://{}:{}/hls/{}{}",
                                            getRobot().getPushLocalIp(),
                                            UrlManager.PUSH_STREAM_PORT_LOCAL,
                                            getRobot().getId(),
                                            UrlManager.PUSH_SUFFIX_AUDIO);
                                }
                                mLocalPushAudioUrl = playAudioUrl;
                            }
                            ULog.d(TAG, "initLib: audio播放地址 = " + playAudioUrl);
                            if (playAudio == null) {
                                playAudio = new SmartPlayer("playAudio");
                            }
                            boolean isPlay = playAudio.startPlay(playAudioUrl);
                            if (!isPlay) {
                                mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_AUDIO_STREAM, 2000);
                            }
                            ULog.d(TAG, "handleMessage:  == audio播放 " + isPlay);
                        }
                    }
                });
                break;
            case Msg.WHAT_TURN_BACK:
                if (robotDirection == StmTask.MOVE_END) {
                    setRobotDirection(StmTask.MOVE_FRONT,"17");
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                }
                break;
            case Msg.WHAT_UPLOAD_CUT_STREAM:
                Observable.just(1)
                        .observeOn(Schedulers.io())
                        .subscribe(event -> {
                            String filePath = UConstants.DIR_VIDEO_CUT;
                            //如果filePath不以文件分隔符结尾，自动添加文件分隔符
                            if (!filePath.endsWith(File.separator)) {
                                filePath = filePath + File.separator;
                            }
                            File dirFile = new File(filePath);
                            if (!dirFile.exists() || !dirFile.isDirectory()) {
                                return;
                            }
                            File[] files = dirFile.listFiles();

                            if (files == null || files.length == 0) {
                                return;
                            }

                            //当存储空间不足时，删除视频
                            if (UFileUtils.getInstance().getAvailableStoragePercent(Environment.getDataDirectory().getPath()) <= 0.20f) {
                                ULog.w(TAG,
                                        "剩余空间不足20%，删除最旧的5条视频 ：" + UFileUtils.getInstance()
                                                .getAvailableStoragePercent(Environment.getDataDirectory().getPath()));
                                ArrayList<File> fileList = new ArrayList<>();
                                for (File f : files) {
                                    if (f != null && f.exists() && !f.getName().endsWith("m3u8")) {
                                        fileList.add(f);
                                    }
                                }

                                fileList.sort(new Comparator<File>() {
                                    @Override
                                    public int compare(File o1, File o2) {
                                        int diff = o1.getName().compareTo(o2.getName());
                                        if (diff < 0) {
                                            return -1;
                                        } else if (diff == 0) {
                                            return 0;
                                        } else {
                                            return 1;
                                        }
                                    }
                                });

                                int listSize = fileList.size();
                                for (int i = 0; i < 5 && i < listSize; i++) {
                                    File tmpF = fileList.get(i);
                                    if (tmpF != null && tmpF.exists() && tmpF.isFile()) {
                                        ULog.d(TAG, "删除视频片段" + tmpF.getName());
                                        tmpF.delete();
                                    }
                                }
                            }

                            files = dirFile.listFiles();
                            //遍历上传文件夹下的所有文件 最后一个ts和m3u8不上传
                            for (int i = 0; i < (files != null ? files.length : 0) - 2; i++) {
                                if (files[i] != null && files[i].exists() && files[i].isFile()) {
                                    if (files[i].getName().endsWith("ts")) {
                                        File fileTemp = files[i];
                                        ULog.d(TAG, "minio局域网上传切片 fileName ：" + fileTemp.getName());
                                        String fileName = UConstant.MINIO_VIDEO_CUT_NAME + getRobot().getId() + "/" + fileTemp.getName();
                                        //上传子文件
                                        Minio.getInstance(getRobot().getMinioIp()).upload(fileTemp.getAbsolutePath(),
                                                fileName,
                                                new Minio.RequestCallBack() {
                                                    @Override
                                                    public void onSuccess() {
                                                        ULog.d(TAG, "uploadFile:  minio局域网上传切片" + fileName + " === 成功");
                                                        //                                sendMobileInfo(mRes.getString(fun.unifun.library.android.R.string.upload_end));
                                                        //上传成功删除
                                                        deleteFile(fileTemp.getAbsolutePath());
                                                    }

                                                    @Override
                                                    public void onFail() {
                                                        ULog.d(TAG, "uploadFile:  minio局域网上传切片" + fileName + " === 失败");
                                                        //                                    sendMobileInfo(mRes.getString(fun.unifun.library.android.R.string.upload_error));
                                                    }
                                                });
                                    }
                                }
                            }


                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_UPLOAD_CUT_STREAM, 60 * 1000);
                        });

                break;

            case Msg.WHAT_LAZY_INIT_ROBOT:
                lazyInitRobot();
                break;

            case Msg.WHAT_START_SCHEDULED_INSPECTION: {
                if (!inCharger()) {
                    ULog.d(TAG, "排班巡检无法触发，不在充电桩");
                    break;
                }
                if (getRobot().getPowerPercent() < getRobot().getInspectionPowerThreshold()) {
                    ULog.d(TAG, "排班巡检无法触发，电量低于巡检阈值");
                    break;
                }
                if (MainApp.arrangeInspectRelBelt && !isBeltConveyorStart) {
                    ULog.d(TAG, "排班巡检无法触发，皮带机未启动");
                    break;
                }
                if (!MainApp.isBmsCheckPass()) {
                    ULog.d(TAG, "排班巡检无法触发，电池处于满放满充阶段");
                    break;
                }
                Object[] keys = arrangeMap.keySet().toArray();
                Arrays.sort(keys);
                int expressDiff = getRobotConfigParams().getArrangeInspectDiff();
                long currentTime = System.currentTimeMillis();
                for (int i = 0; i < keys.length; i++) {
                    ULog.d(TAG, "startSleep222  arrangeMap == " + i + " time " + UTime.getStringFromDate(new Date((Long) keys[i])) + " == " + arrangeMap.get(keys[i]));
                    if (!arrangeMap.get(keys[i])) {
                        long timePoint = (Long) keys[i];
                        long limitFront = currentTime - ((expressDiff * 2 + 5) * 60_000);
                        long limitBack = currentTime + ((expressDiff * 2 + 5) * 60_000);
                        if (currentTime > limitFront && currentTime < limitBack) {
                            arrangeMap.put((Long) keys[i], true);
                            break;
                        } else {
                            ULog.d(TAG, "startSleep222 == 触发排班巡检，但是超出极限时间，所以不执行 taskPoint " + UTime.getStringFromDate(new Date(timePoint))
                                    + " expressDiff = " + expressDiff
                                    + " limitFront = " + UTime.getStringFromDate(new Date(limitFront))
                                    + " limitBack = " + UTime.getStringFromDate(new Date(limitBack))
                                    + " 当前时间 " + UTime.getStringFromDate(new Date(currentTime)));
                            return;
                        }
                    }
                }
                //重置休眠检测时间
                lastCheckSleepTime = System.currentTimeMillis();
                ULog.d(TAG, "排班巡检触发：MODE:" + MODE + " ,battery:" + getRobot().getPowerPercent()
                        + ",current:" + getRobot().getBatteryCurrent() + ",inCharger:" + inCharger()
                        + " 网络状态 " + serverHeartNormal + " 巡检电量阈值 " + getRobot().getInspectionPowerThreshold());
                if (MODE != MODE_INSPECTION && MODE != MODE_CHECKING_STOP && serverHeartNormal) {
                    MqttCommand startCommand = new MqttCommand();
                    startCommand.setSource("self_ctrl_schedule_inspection");
                    startCommand.setTarget(getRobot().getId());
                    startCommand.setType(MqttCommand.ROBOT_INSPECTION_INDEX_TYPE);
                    startCommand.setAction(MqttCommand.ROBOT_INSPECTION_FORCE_ACTION);
                    onMessageReceived(startCommand);
                }
            }
            break;


            case Msg.WHAT_BROADCAST_ROBOT_INFO: {
                UExecutorService.getSpecialTPBroadcastRobotInfo().execute(() -> {
                    MqttCommand infoCommand = new MqttCommand();
                    infoCommand.setSource(getRobot().getId());
                    infoCommand.setTarget(MqttCommand.TARGET_SUBSCRIBERS);
                    infoCommand.setType(MqttCommand.TYPE_BROADCAST_INFO);
                    infoCommand.setAction(MqttCommand.ACTION_BASE_INFO);

                    HashMap<String, String> dataMap = new HashMap<>();
                    dataMap.put("distance", String.valueOf(mDistance));
                    dataMap.put("speed", String.valueOf(Float.parseFloat(FormatUtils.keep3Decimals(getRealSpeed(mMotorSpeed)))));
                    dataMap.put("rfid_tag", getRobot().getRfidTagName());

                    dataMap.put("standbyValue", isSleep ? "true" : "false");
//                    dataMap.put("stopped", isSoftEmergencyStop ? "true" : "false");

                    if (inspectManager.mCheckTargetNode != null) {
                        dataMap.put("task_node_start_location",
                                String.valueOf(inspectManager.mCheckTargetNode.getStartLocation()));
                        dataMap.put("task_node_id", String.valueOf(inspectManager.mCheckTargetNode.getId()));
                        dataMap.put("task_node_name", inspectManager.mCheckTargetNode.getName());
                    } else if (inspectManager.mCurrentTaskNode != null) {
                        dataMap.put("task_node_start_location",
                                String.valueOf(inspectManager.mCurrentTaskNode.getStartLocation()));
                        dataMap.put("task_node_id", String.valueOf(inspectManager.mCurrentTaskNode.getId()));
                        dataMap.put("task_node_name", inspectManager.mCurrentTaskNode.getName());
                    }
                    dataMap.put("ir_front_temperatures", Arrays.toString(currentIRValue.toArray()));
                    dataMap.put("ir_back_temperatures", Arrays.toString(currentIRValueBack.toArray()));
                    dataMap.put("robot_direction", String.valueOf(robotDirection));
                    if (InspectManager.uploadNodeState && currentIRObjIds.size() != 0) {
                        InspectManager.uploadNodeState = false;
                        dataMap.put("ir_front_temperatures", Arrays.toString(currentIRValueBackup.toArray()));
                        dataMap.put("ir_back_temperatures", Arrays.toString(currentIRValueBackBackup.toArray()));
                        currentIRValueBackup.clear();
                        currentIRValueBackBackup.clear();
                        dataMap.put("task_obj", Arrays.toString(inspectManager.getTaskObjByIds(currentIRObjIds).toArray()));
                        dataMap.put("flag", "upload_node_success");
                    }

                    infoCommand.setValue(new Gson().toJson(dataMap));

                    mMqttManager.publishMessageToSubscribers(infoCommand);
                });
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_BROADCAST_ROBOT_INFO, 1000);

            }
            break;

            case Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD: {
                synchronized (this) {
                    if (mMotorBackDis != null && !mMotorBackDis.isDisposed()) {
                        mMotorBackDis.dispose();
                    }
                    if (inCharger()) {
                        ULog.d(TAG, "电机过流/运动阻碍，开始反向 在充电桩位置，中止本次1");
                        break;
                    }
                    mMotorBackDis = Observable.just(1)
                            .observeOn(Schedulers.io())
                            .subscribe(t -> {
                                setRobotActionCode(RobotActionCode.Hindrance.HINDRANCE_BACKWARD);
                                float moveDistance = 1;
                                if (mDistance - 1 < -0.2) moveDistance = mDistance - 0.2f;
                                if (mDistance + 1 > AutoMoveManager.maxRFIDDistance + 0.2) moveDistance = (AutoMoveManager.maxRFIDDistance + 0.2f) - mDistance;
                                if (moveDistance < 0.05) moveDistance = 0.05f;
                                long sleepT = (int)(moveDistance / lastSpeed * 1000) + 500;
                                if (rfidReadType == 0 || rfidReadType == 2) sleepT = (int)(moveDistance / lastSpeed * 1000);
                                ULog.d(TAG, "电机过流/运动阻碍，开始反向 ，方向：" + robotDirection + " moveDistance " + moveDistance + " mDistance " + mDistance + " maxDistance " + AutoMoveManager.maxRFIDDistance + " lastSpeed " + lastSpeed + " sleepT " + sleepT);
                                stmExecute.executeTaskNonQueue(new StmTask().move(robotDirection, defaultRotate, moveDistance));

                                try {
                                    Thread.sleep(sleepT);
                                    if (inCharger()) {
                                        ULog.d(TAG, "电机过流/运动阻碍，开始反向 在充电桩位置，中止本次");
                                        return;
                                    }
                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("电机过流/运动阻碍，开始反向 49"));
                                    motorBackwardResumeMove();
                                } catch (InterruptedException e) {
                                    //                                    e.printStackTrace();
                                }
                            });
                }
            }
            break;

            case Msg.WHAT_RETRY_MOVE_AFTER_STALLING: {
                ULog.d(TAG, mBotInfoMgr.getRobotConfigParams().getHindranceRetryDelayMinute() + "分钟运动阻碍计时结束，重试移动， mode:" + msg.arg1);
                //重新设置MODE，靠Msg.WHAT_MOVE_CHECK来触发移动
                if (!inCharger()) {
                    setMode(msg.arg1, "recover_mode-电机堵转后过了一定时间,恢复之前模式");
                }
            }
            break;

            case Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE: {
                if (moveHinderNeedSleep && !isRecordSleepTime) {
                    isRecordSleepTime = true;
                    ULog.d(TAG, "startSleep 记录休眠时间 " + sleepTimeMoveHinder);
                    UPreferences.putInt(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_SLEEP_TIME_KEY, sleepTimeMoveHinder);
                }
                if (mCurrent >= 0) {
                    ULog.d(TAG, "startSleep 当前可能在充电，禁止进入休眠");
                    if (!isSleepTip) {
                        isSleepTip = true;
                        mMqttManager.broadcastShowInfo("正在充电，无法进入休眠状态");
                        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_IS_CHARGING_NOW_CANNOT_SLEEP);
                    }
                    break;
                }
                if (mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
                    ULog.d(TAG, "startSleep 正常检测充电，无法休眠");
                    if (!isSleepTip) {
                        isSleepTip = true;
                        mMqttManager.broadcastShowInfo("正常检测充电，无法休眠");
                        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_DETECTING_CHARGING_STATUS_NOW_CANNOT_SLEEP);
                    }
                    break;
                }
                if (!moveHinderNeedSleep && sleepTime <= 0) {
                    ULog.d(TAG, "startSleep 休眠时间为0，无法休眠");
                    if (!isSleepTip) {
                        isSleepTip = true;
                        mMqttManager.broadcastShowInfo("休眠时间为0，无法休眠");
                        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_SLEEP_INTERVAL_ZERO_CANNOT_SLEEP);
                    }
                    break;
                }
                if (!moveHinderNeedSleep && MODE != MODE_UN_KNOW) {
                    ULog.d(TAG, "startSleep 工作状态，禁止进入休眠 mode = " + MODE);
                    if (!isSleepTip) {
                        isSleepTip = true;
                        mMqttManager.broadcastShowInfo("设置成功，回充后可进休眠，");
                        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_SLEEP_SETUP_SUCCESS_AVAILABLE_AFTER_GO_BACK_TO_CHARGER);
                    }
                    break;
                }
                //                int interval = 30;
                //                if (getRobot() != null && getRobot().getSleepWakeupInterval() != null) {
                //                    interval = getRobot().getSleepWakeupInterval();
                //                }
                long tempTime = sleepTime;
                if (moveHinderNeedSleep) {
                    tempTime = sleepTimeMoveHinder;
                }
                stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_POWER_CONTROL,
                        UConstants.VALUE_SWITCH_STATUS_OFF));
                stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_SLEEP_WAKEUP_INTERVAL,
                        (int) tempTime));

                mHandler.sendEmptyMessageDelayed(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE, 1000);
            }

            break;

            case Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE:
                if (StmTaskExecute.isUpgrade) {
                    ULog.d(TAG, "upgrade startSleep 下位机正在升级，退出休眠没意义");
                    break;
                }
                //复位下位机以退出低功耗模式
                UPreferences.putBoolean(getContext(), UConstants.KEY_IS_IN_SLEEP_MODE, false);
                RxBus.getInstance().post(new Stm32Event(Stm32Event.STM_REBOOT, Stm32RebootReason.QUIT_POWER_SAVE));
                reset(1);
                //                stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_POWER_CONTROL,
                //                        UConstants.VALUE_SWITCH_STATUS_ON));

                //                mHandler.sendEmptyMessageDelayed(Msg.WHAT_NOTIFY_STM_QUIT_POWER_SAVE_MODE, 1000);
                break;
            case Msg.WHAT_SELF_CYCLE_CLEAN_END_HANDLE: {
                int typeFlag = (int) msg.obj;
                ULog.d(TAG, "自循环除尘结束，准备回充 ===" + MODE + " sensorEnableStatus " + sensorEnableStatus + " typeFlag:"+typeFlag);

                //在这里认为除尘完成了
                ULog.d(TAG,"RgbSharpnessChecker inCharger:"+inCharger()+" backwardDistanceIsZero:"+backwardDistanceIsZero+" CheckRounds:"+RgbSharpnessChecker.getInstance().getCheckRounds());
                //除尘结束如果机器人还处于充电桩  且除尘移动距离为0 检测轮次还在不到3次就检测 则开始检测画面清晰度
                if(typeFlag == 1 && inCharger() && backwardDistanceIsZero && RgbSharpnessChecker.getInstance().getCheckRounds() <= 3) {
                    RgbSharpnessChecker.getInstance().start(/*RobotFragment.this,*/ "除尘结束开始检测画面清晰度", new RgbSharpnessChecker.OnCheckDoneListener() {
                        @Override
                        public void onError(Throwable e) {
                            ULog.w(TAG, "endDustingSuccess RgbSharpnessChecker onError e:" + e.getMessage());
                            e.printStackTrace();
                            RgbSharpnessChecker.getInstance().stop(true, "检测清晰度报错停止检测等待下次");
                        }

                        @Override
                        public void onComplete(List<Double> results) {
                            int checkRounds = RgbSharpnessChecker.getInstance().getCheckRounds();
                            ULog.d("endDustingSuccess RgbSharpnessChecker onComplete results:" + UGson.getGson().toJson(results) + " checkRounds:" + checkRounds);
                            //判断返回的检测结果 判断是否在有次数内
                            List<Double> filterList = new ArrayList<>();
                            for (int i = 0; i < results.size(); i++) {
                                Double aDouble = results.get(i);
                                if (aDouble != null && !aDouble.isNaN()) {
                                    filterList.add(aDouble);
                                }
                            }

                            if (filterList.size() < RgbSharpnessChecker.minValidCount) {
                                // 检测有效次数大于最小有效检测次数
                                ULog.w(TAG, "endDustingSuccess RgbSharpnessChecker 小于最小有效次数忽略本次  本次:"+filterList.size()+" 至少:"+RgbSharpnessChecker.minValidCount);
                            } else {
                                //检查是否干净 计算平均值
                                double sum = 0.0f;
                                for (Double number : filterList) {
                                    sum += number;
                                }
                                double average = sum / filterList.size();
                                boolean rgbDirty = (average < getRobotConfigParams().getRgbLensDirtyThreshold());//在这里判断镜头是否污损
                                ULog.d("endDustingSuccess RgbSharpnessChecker 平均值：" + average+" 镜头是否污损:"+rgbDirty+" 污损阈值:"+getRobotConfigParams().getRgbLensDirtyThreshold());
                                if (rgbDirty) {
                                    if (RgbSharpnessChecker.getInstance().getCheckRounds() >= 3) {
                                        RgbSharpnessChecker.getInstance().stop(true, "检测轮次到上限主动停止");
                                        WebCamManager.getInstance().takePhoto().timeout(5, TimeUnit.SECONDS).subscribeOn(Schedulers.io()).subscribe(new NextErrorObserver<ResponseBody>() {
                                            @Override
                                            public void onNext(@NonNull ResponseBody responseBody) {
                                                //上传rgb的照片先
                                                //普通拍照 上传rgb及ir图像
                                                byte[] finalBytes = new byte[0];
                                                try {
                                                    finalBytes = responseBody.bytes().clone();
                                                } catch (IOException e) {
                                                    ULog.d("endDustingSuccess RgbSharpnessChecker takePhoto 拍照失败1e:" + e.getMessage());
                                                    e.printStackTrace();
                                                    sendAlarmByRgbLensDirty(true,null,"检测到污损但是拍照失败1,只报警不带图片");
                                                    return;
                                                }

                                                //获取系统的日期
                                                Calendar calendar = Calendar.getInstance();
                                                String dayStr = calendar.get(Calendar.YEAR) + "_" + (calendar.get(Calendar.MONTH) + 1) + "_" + calendar.get(Calendar.DAY_OF_MONTH);
                                                byte[] finalBytes1 = finalBytes;
                                                String serverFileName = UConstants.TAKE_PHOTO_EXCEPTION_DIR + robotId + "/" + dayStr + "/" + dateFormat.format(new Date(System.currentTimeMillis())) + ".jpg";
                                                if (MainApp.uploadFileType == 0) {
                                                    int code = UOss.getInstance(mActivity).upLoadByteArr(serverFileName, finalBytes1);
                                                    ULog.d(TAG, "endDustingSuccess RgbSharpnessChecker takePhoto RGB图片上传至minio失败");
                                                    sendAlarmByRgbLensDirty(true,serverFileName,(code == 200 ? "图片文上传至oss成功":"图片文上传至oss失败"+code));
                                                } else {
                                                    HashMap<String, String> headerMap = new HashMap<>();
                                                    headerMap.put("contentType", "image/png");
                                                    Minio.getInstance(getRobot().getMinioIp()).upload2(serverFileName, finalBytes1, headerMap, new Minio.RequestCallBack() {
                                                        @Override
                                                        public void onSuccess() {
                                                            sendAlarmByRgbLensDirty(true,serverFileName,"RGB图片上传至minio成功");
                                                        }

                                                        @Override
                                                        public void onFail() {
                                                            sendAlarmByRgbLensDirty(true,serverFileName,"RGB图片上传至minio失败");
                                                        }
                                                    });
                                                }
                                            }

                                            @Override
                                            public void onError(@NonNull Throwable e) {
                                                ULog.d("endDustingSuccess RgbSharpnessChecker takePhoto 拍照失败2e:" + e.getMessage());
                                                sendAlarmByRgbLensDirty(true,null,"检测到污损但是拍照失败2,只报警不带图片");
                                            }
                                        });
                                    }else{
                                        ULog.d(TAG,"endDustingSuccess RgbSharpnessChecker 继续除尘");
                                        needDustingFirst();
                                    }

                                } else {
                                    RgbSharpnessChecker.getInstance().stop(true, "没检测到污损停止检测");
                                    sendAlarmByRgbLensDirty(false,null,"没检测到污损,正常");
                                }
                            }
                        }
                    });
                }

                if (!sensorEnableStatus && !mHandler.hasMessages(Msg.WHAT_SENSOR_ENABLE)) {
                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_ENABLE, getRobotConfigParams().getSensorRecoveryEnableTime() * 1000);
                }
                if (MODE != MODE_DEVICE_CLEAN) {
                    return;
                }
                ULog.d(TAG, "自循环除尘结束，准备回充===xxx");
                stmExecute.executeTaskNonQueue(new StmTask().stopMove("自循环除尘结束，准备回充 50"));
                autoMoveManager.gotoChargerCheck("自循环除尘结束_回充");
            }
            break;

            case Msg.WHAT_PRINT_SENSOR_DATA: {
                printRobotSensorData();

                mHandler.sendEmptyMessageDelayed(Msg.WHAT_PRINT_SENSOR_DATA, 2500);
            }
            break;

            case Msg.WHAT_WEB_CAMERA_IS_ELECTRIFY: {
                if (msg.obj != null) {
                    checkWebCameraIsOnLine(msg.obj.toString(),
                            () -> WebCamManager.getInstance()
                                    .setSystemTime(System.currentTimeMillis())
                                    .subscribe(ObserverFactory.createDefaultObserver()));
                }
            }
            break;

            case Msg.WHAT_CHECK_ROOM_AND_CONTINUE:
                if (CicadaRoomController.getInstance().getCurDorState() == CicadaRoomDoorState.OPEN) {
                    onMessageReceived((MqttCommand) msg.obj);
                } else {
                    Message repeatMsg = mHandler.obtainMessage();
                    repeatMsg.what = msg.what;
                    repeatMsg.obj = msg.obj;

                    mHandler.sendMessageDelayed(repeatMsg, 3000);
                }
                break;

            case Msg.WHAT_SERVER_HEART_STOP_TIMEOUT: {
                ULog.w(TAG, "服务器心跳长时间未恢复正常 判定断网， isReConnect=" + isReConnect + " mSegment " + (mSegment == null ? "null" : mSegment.getId()));
                if (mSegment == null) {
                    getSegmentFromCache();
                    break;
                }
                if (isOfflineLocation(mDistance)) {

                } else {
                    if (!isReConnect) {
                        //如果AP重连不累加到结果
                        serverHeartStopHandle();
                    }
                }
            }
            break;

            case Msg.WHAT_SHUTTER_ALL_IR_WHEN_LEAVE_BY: {
                Observable.just(1)
                        .observeOn(Schedulers.io())
                        .subscribe(t -> {
                            if (irService != null) {
                                ULog.w(TAG, "handleMessage == 所有热成像快门校正 == start");
                                irService.shutterAll();
                                Thread.sleep(5000);
                                irService.shutterAll();
                                Thread.sleep(5000);
                                irService.shutterAll();
                                ULog.w(TAG, "handleMessage == 所有热成像快门校正  == finished");
                            }
                        });
            }
            break;

            case Msg.WHAT_CHECK_WHEN_STM_RESET: {
                checkWhenStmReset();
            }
            break;

            case Msg.WHAT_CHECK_STM_MAP_CONFIG_RESULT:
                checkStmMapConfigResult();
                break;

	        case Msg.WHAT_CHECK_AND_CHANGE_ROOM_TO_MANUAL_CONTROL:
				if (msg.obj != null) {
					checkAndChangeRoomToManualControl((MqttCommand) msg.obj);
				}
		        break;

	        case Msg.WHAT_CHECK_AND_CHANGE_ROOM_TO_ROBOT_CONTROL:
				if (msg.obj != null) {
					checkAndChangeRoomToRobotControl((MqttCommand) msg.obj);
				}
				break;
            case Msg.WHAT_FORWARD_FIND_ALL_ALARM_TYPE:
                if(getAlarmManager() != null){
                    getAlarmManager().getAllAlarmTypes();
                }
                break;
            default:
                break;
        }
    }

    private void uploadStInfoMap() {
        ULog.d(TAG, "uploadStInfoMap == " + gson.toJson(MainApp.mStInfoUpload.keySet()));
        fun.unifun.library.cloud.client.inparam.robotStatisticsData.Create request = new fun.unifun.library.cloud.client.inparam.robotStatisticsData.Create();
        ArrayList<StatisticInfo> stUploads = new ArrayList<>();
        for(StatisticInfo st : MainApp.mStInfoUpload.values()) {
            stUploads.add(st);
        }
        stUploads.removeIf((a) -> a.isUpload());
        stUploads.sort((t1, t2) -> {
            if (t1.getCurrentTime() < t2.getCurrentTime()) {
                return -1;
            } else if (t1.getCurrentTime() > t2.getCurrentTime()) {
                return 1;
            } else {
                return 0;
            }
        });
        List<RobotStatisticsDataPara> list = new ArrayList<>();
        for(StatisticInfo st : stUploads) {
            RobotStatisticsDataPara temp = new RobotStatisticsDataPara();
            temp.setCurrentTime(st.getCurrentTime());
            temp.setChargingTotalTime(st.getChargingTotalTime());
            temp.setOnlineTotalTime(st.getOnlineTotalTime());
            temp.setInspectionTotalTime(st.getInspectionTotalTime());
            temp.setInspectionTotalMileage(BigDecimal.valueOf(st.getInspectionTotalMileage()));
            temp.setInspectionTotalNum(st.getInspectionTotalNum());
            list.add(temp);
        }

        request.setRobotId(getRobot().getId());
        request.setList(list);
        UOKHttp.post(UrlManager.getBaseUrl(),
                request,
                new UOKHttp.RequestCallBack<fun.unifun.library.cloud.client.inparam.robotStatisticsData.Create>(fun.unifun.library.cloud.client.inparam.robotStatisticsData.Create.class) {
                    @Override
                    public void onFailure(Call call, IOException e) {
                        ULog.d(TAG, "onFailure:  == uploadStInfoMap");
                    }

                    @Override
                    public void onResponseOk(Call call, fun.unifun.library.cloud.client.inparam.robotStatisticsData.Create uploadStRequest) {
                        ULog.d(TAG, "onResponseOk:  == uploadStInfoMap");
                        String tKey = "";
                        for (int i = 0; i < stUploads.size(); i++) {
                            tKey = sdfYMD.format(new Date(stUploads.get(i).getCurrentTime()));
                            MainApp.mStInfoUpload.get(tKey).setUpload(true);
                            if (i > 0 && i < stUploads.size() - 1) { //将已上传的中间的数据移除
                                MainApp.mStInfoUpload.remove(tKey);
                            }
                        }
                        String stJson = gson.toJson(MainApp.mStInfoUpload);
                        StorageCenter.getRobotStorage().putString(UConstants.PREFERENCES_ROBOT_UPLOAD_STATUS_VALUE_KEY, stJson);
                        ULog.d(TAG, "更新需要上传的统计信息 = " + stJson);
                    }

                    @Override
                    public void onResponseError(Call call, int i, String s) {
                        ULog.d(TAG, "onResponseError:  == uploadStInfoMap " + s);
                    }
                });
    }

    private int getSleepTimeMoveHinder() {
        String LAST_REBOOT_REASON = StorageCenter.getRobotStorage().getString(KeyConstant.Storage.LAST_REBOOT_REASON, "UNKNOWN");
        int temp = -1;
        if (!TextUtils.isEmpty(LAST_REBOOT_REASON) && LAST_REBOOT_REASON.contains("ove_hinder_BMS")) {
            try {
                temp = Integer.parseInt(LAST_REBOOT_REASON.substring(LAST_REBOOT_REASON.lastIndexOf("_") + 1));
            } catch (NumberFormatException e) {
                e.printStackTrace();
            }
        }
        ULog.d(TAG, "getSleepTimeMoveHinder 运动阻碍休眠时间 = " + temp);
        if (temp == -1) {
            temp =  UPreferences.getInt(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_SLEEP_TIME_KEY, 0);
            ULog.d(TAG, "getSleepTimeMoveHinder 运动阻碍休眠时间1 = " + temp);
            return temp;
        } else {
            ULog.d(TAG, "getSleepTimeMoveHinder 运动阻碍休眠时间2 = " + temp);
            return temp;
        }
    }
	/**
	 * 检查机器人并切换到手动控制模式
	 * @param sourceCommand
	 */
	private void checkAndChangeRoomToManualControl(MqttCommand sourceCommand) {
		if (inCharger() || mDistance > 0.0f) {
			setMode(MODE_UN_KNOW,"正常模式-checkAndChangeRoomToManualControl");
			stmExecute.executeTaskNonQueue(new StmTask().stopMove("checkAndChangeRoomToManualControl 51"));

			CicadaRoomController.getInstance().changeControlSourceTo(RoomControlSource.MANUAL)
					.subscribe(new NextErrorObserver<Boolean>() {
						@Override
						public void onNext(@NonNull Boolean aBoolean) {
							mMqttManager.sendMqttResultSuccess(sourceCommand);
							RobotStatus.setIsChangingRoomControl(false);
						}

						@Override
						public void onError(@NonNull Throwable e) {
							mMqttManager.sendMqttResultFail(sourceCommand);
							RobotStatus.setIsChangingRoomControl(false);
						}
					});
		} else {
			RobotStatus.setIsChangingRoomControl(false);
			mMqttManager.sendMqttResultFail(sourceCommand);
			mMqttManager.broadcastShowInfo(getString(R.string.robot_in_room_area_cannot_change_to_manual_control));
			mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_IN_ROOM_AREA_CANNOT_CHANGE_TO_MANUAL_CONTROL);
		}
	}
    Type sensorType = new TypeToken<HashMap<String, ArrayList<Sensor>>>() {}.getType();
    //除尘是否喷水 喷水关闭传感器
    public void checkDustingSprayWater() {
        if (getRobotConfigParams().getSensorRecoveryEnableTime() == 0) return;
            if (AutoMoveManager.mTargetChargerNodeW != null && AutoMoveManager.mTargetChargerNodeW.getCharger() != null) {
            if (!TextUtils.isEmpty(AutoMoveManager.mTargetChargerNodeW.getCharger().getSensorConfig())) {
                HashMap<String, ArrayList<Sensor>> sensorMap = new Gson().fromJson(AutoMoveManager.mTargetChargerNodeW.getCharger().getSensorConfig(), sensorType);
                ArrayList<Sensor> list = sensorMap.get(SensorType.CLEAN_DEVICE);
                if (list != null && list.size() != 0) {
                    Sensor cleanDevice = list.get(0);
                    int cleanTimes = 0, SprayWaterDuration = 0;//, SprayWaterTimesEveryCycle = 0;
                    String cleanTimesStr = cleanDevice.getValueMap().get("clean_times");
                    String SprayWaterDurationStr = cleanDevice.getValueMap().get("spray_water_duration");
//                    String SprayWaterTimesEveryCycleStr = cleanDevice.getValueMap().get("spray_water_times_every_cycle");
                    if (!TextUtils.isEmpty(cleanTimesStr)) cleanTimes = Integer.parseInt(cleanTimesStr);
                    if (!TextUtils.isEmpty(SprayWaterDurationStr)) SprayWaterDuration = Integer.parseInt(SprayWaterDurationStr);
//                    if (!TextUtils.isEmpty(SprayWaterTimesEveryCycleStr)) SprayWaterTimesEveryCycle = Integer.parseInt(SprayWaterTimesEveryCycleStr);
                    ULog.d(TAG, "开始除尘_喷水参数 chargerId=" + AutoMoveManager.mTargetChargerNodeW.getCharger().getId() + " getCleanTimes=" + cleanTimes + " getSprayWaterDuration=" + SprayWaterDuration);
                    if (cleanTimes > 0 && SprayWaterDuration > 0) {
                        ULog.d(TAG, "开始除尘_会喷水_关闭传感器_sensor_control_false");
                        if (mHandler.hasMessages(Msg.WHAT_SENSOR_ENABLE)) mHandler.removeMessages(Msg.WHAT_SENSOR_ENABLE);
                        stmExecute.executeTask(new StmTask().switchComponentEnable(false, StmTask.FuncPowerBit.BIT_SENSOR_POWER));
                    }
                }
            }
        }
    }
	/**
	 * 检查Room并切换到机器人控制
	 * @param sourceCommand
	 */
	private void checkAndChangeRoomToRobotControl(MqttCommand sourceCommand) {
		CicadaRoomController.getInstance().changeControlSourceTo(RoomControlSource.ROBOT)
				.subscribe(new NextErrorObserver<Boolean>() {
					@Override
					public void onNext(@NonNull Boolean aBoolean) {
						mMqttManager.sendMqttResultSuccess(sourceCommand);
					}

					@Override
					public void onError(@NonNull Throwable e) {
						mMqttManager.sendMqttResultFail(sourceCommand);
					}
				});
	}

    private void checkStmMapConfigResult() {
        if (mNeedUpdateStmMap) {
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_STM_RFID, 3000);
        }
    }

    /**
     * 检测并更新版本
     */
    private void checkRobotVersion() {
        String curVersion = "";
        try {
            curVersion = USystemProperties.get(mActivity, UConstants.VERSION);
        } catch (Exception e) {
            curVersion = AppUtils.getAppVersionName();
        }
        if (AppUtil.isVersionGt(getRobot().getVersion(), curVersion)) {
            getRobot().setVersion(curVersion);
        }
    }

    /**
     * 检查充电桩是否在线(同步访问)
     *
     * @param startMgId 充电桩id
     * @param type
            private final static int Msg.WHAT_START_CHARGING = 56; //开始充电
            private final static int Msg.WHAT_END_CHARGING = 57; //结束充电
            private final static int Msg.WHAT_START_DUSTING = 75;//开始除尘
            private final static int Msg.WHAT_END_DUSTING = 76;//结束除尘
            private final static int Msg.WHAT_OPEN_HEATER = 101;//开始加热
            private final static int Msg.WHAT_CLOSE_HEATER = 102;//关闭加热
            private final static int Msg.WHAT_OPEN_COOLER = 103;//打开制冷
            private final static int Msg.WHAT_CLOSE_COOLER = 104;//关闭制冷
     */
    private void checkChargerOnline(String startMgId, int type) {
        fun.unifun.library.cloud.client.inparam.charger.FindById findById = new fun.unifun.library.cloud.client.inparam.charger.FindById();
        findById.setId(startMgId);

        UOKHttp.post(UrlManager.getBaseUrl(),
                findById,
                new UOKHttp.RequestCallBack<fun.unifun.library.cloud.client.inparam.charger.FindById>(fun.unifun.library.cloud.client.inparam.charger.FindById.class) {
                    Message msg = Message.obtain();

                    @Override
                    public void onFailure(Call call, IOException e) {
                        ULog.d(TAG, "checkChargerOnline == onFailure：" + e.getMessage());
                        msg.arg1 = type;
                        msg.what = Msg.WHAT_SEND_CHARGER_MESSAGE;
                        mHandler.sendMessage(msg);
                    }

                    @Override
                    public void onResponseOk(Call call, fun.unifun.library.cloud.client.inparam.charger.FindById findById) {
                        ULog.d(TAG, "checkChargerOnline == onResponseOk：" + findById);
                        if (findById != null && findById.getCharger() != null) {
                            isChargerOnline = "online".equals(findById.getCharger().getStatus());
                            ULog.d(TAG, "checkChargerOnline == onResponseOk： isChargerOnline = " + isChargerOnline);
                        }
                        msg.arg1 = type;
                        msg.what = Msg.WHAT_SEND_CHARGER_MESSAGE;
                        mHandler.sendMessage(msg);
                    }

                    @Override
                    public void onResponseError(Call call, int i, String s) {
                        ULog.d(TAG, "checkChargerOnline == onResponseError：" + s);
                        msg.arg1 = type;
                        msg.what = Msg.WHAT_SEND_CHARGER_MESSAGE;
                        mHandler.sendMessage(msg);
                    }
                });
    }

    public static boolean robotIsStop() {
        return saveDistanceFlag && (Math.abs(mDistance - distanceCheck) < 0.002) && Math.abs(MainApp.mRobotSpeed) < 0.01;
    }


    /**
     * 检查网络模式
     */
    private void checkNetworkState() {
        int networkState = NetWorkUtils.getNetworkState(mActivity);
        ULog.d(TAG, "checkNetworkState:  == networkState:" + networkState);
        getRobot().setNetworkState(networkState);
    }

    private void getAccounts() {
        fun.unifun.library.cloud.client.inparam.account.FindByRobotId request = new fun.unifun.library.cloud.client.inparam.account.FindByRobotId();
        request.setRobotId(getRobot().getId());
        UOKHttp.post(UrlManager.getBaseUrl(),
                request,
                new UOKHttp.RequestCallBack<fun.unifun.library.cloud.client.inparam.account.FindByRobotId>(fun.unifun.library.cloud.client.inparam.account.FindByRobotId.class) {
                    @Override
                    public void onFailure(Call call, IOException e) {
                        ULog.d(TAG, "onFailure:  == getAccounts");
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_ACCOUNTS, 2000);
                    }

                    @Override
                    public void onResponseOk(Call call, fun.unifun.library.cloud.client.inparam.account.FindByRobotId findByRobotId) {
                        ULog.d(TAG, "onResponseOk:  == getAccounts");
                        if (findByRobotId != null) {
                            ULog.d(TAG,
                                    "onResponseOk:  == getAccounts = isSuccess:" + findByRobotId.isSuccess() + ",getAccounts:" + findByRobotId.getAccounts());
                        }
                        if (findByRobotId.isSuccess() && findByRobotId.getAccounts() != null && findByRobotId.getAccounts().size() != 0) {
                            accounts = findByRobotId.getAccounts();

                            StringBuilder sb = new StringBuilder("");
                            for (String account : accounts) {
                                sb.append(account).append("_");
                            }
                            ULog.d(TAG, "onResponseOk:  == account == " + sb.toString());
                            //解析运营平台mqtt的clentid
                            if (accounts_Y.size() == 0) {
                                for (String account : accounts) {
                                    String head = "Y";
                                    if (account.startsWith("U")) {
                                        head += account.substring(1);
                                        accounts_Y.add(head);
                                    }
                                }
                                if (accounts_Y.size() != 0) {
                                    StringBuilder sby = new StringBuilder("");
                                    for (String account : accounts_Y) {
                                        sby.append(account).append("_");
                                    }
                                    ULog.d(TAG, "onResponseOk:  == account_Y == " + sby.toString());
                                }
                            }
                            if (rgbServiceIsAlive()) {
                                rgbService.setAccounts(accounts);
                            }

                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_ACCOUNTS, 60_000);
                        } else {
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_ACCOUNTS, 2000);
                        }
                    }

                    @Override
                    public void onResponseError(Call call, int i, String s) {
                        ULog.d(TAG, "onResponseError:  == getAccounts " + s);
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_ACCOUNTS, 2000);
                    }
                });
    }

    private void getSegmentInfo() {
        mFindSegmentCount++;
        ULog.d(TAG, "getSegmentInfo === ,count:" + mFindSegmentCount);
        if (mFindSegmentCount >= 10) {
            getSegmentFromCache();
            mFindSegmentCount = Integer.MIN_VALUE;
        } else {
            FindSegmentAndChargeByRobotId segmentRequest = new FindSegmentAndChargeByRobotId();
            segmentRequest.setRobotId(getRobot().getId());
            UOKHttp.post(UrlManager.getBaseUrl(),
                    segmentRequest,
                    new UOKHttp.RequestCallBack<FindSegmentAndChargeByRobotId>(FindSegmentAndChargeByRobotId.class) {
                        @Override
                        public void onFailure(Call call, IOException e) {
                            ULog.d(TAG, "onFailure:  == getSegmentInfo");
                        }

                        @Override
                        public void onResponseOk(Call call, FindSegmentAndChargeByRobotId findResult) {
                            ULog.d(TAG, "getSegmentInfo onResponseOk");
                            if (findResult.isSuccess()) {
                                if (findResult.getSegment() != null) {
                                    mSegment = findResult.getSegment();
                                    UPreferences.putString(mActivity, UConstants.PREFERENCES_SEGMENT_KEY, gson.toJson(mSegment));
                                    //从 缓存拿一次即可
                                    mFindSegmentCount = Integer.MIN_VALUE;
                                    parseSegment();
                                } else {
                                    //没有绑定线段
                                    mSequenceInitializer.unregisterInitKey("FIND_CHARGERS");
                                    mSequenceInitializer.unregisterInitKey("CONFIG_CHARGER_SENSOR_FINISH");
                                    RxBus.getInstance().post(new SegmentEvent(SegmentEvent.ACTION_NO_BIND_SEGMENT));
                                }
                            }
                        }

                        @Override
                        public void onResponseError(Call call, int i, String s) {
                            ULog.d(TAG, "onResponseError: == getSegmentInfo");
                        }
                    });
        }

    }


    private int beltCheckType = -1; //1继电器 2自研传感器 3振迪 4充电桩
    private BeltConfig beltConfig = new BeltConfig();

    /**
     * 解析线段信息
     */
    private void parseSegment() {
        if (mSegment == null) {
            return;
        }

        ULog.i(TAG, "parseSegment == " + JsonHelper.toJson(mSegment));

        parseBeltStatus();

        Optional.ofNullable(JsonHelper.parseJson(mSegment.getOfflineLocation(), new TypeReference<List<OfflineLocation>>(){}))
                .ifPresent(locations -> offlineLocations = locations);
        Optional.ofNullable(JsonHelper.parseJson(mSegment.getFireAlarmConfig(), new TypeReference<List<FireAlarmConfig>>(){}))
                .ifPresent(config -> fireAlarmConfigs = config);

        mBotInfoMgr.setSegment(mSegment);
        if (mSegment.getMapId() != null)
            mBotInfoMgr.setMapId(mSegment.getMapId());

        SegmentEvent segmentEvent = new SegmentEvent(SegmentEvent.EVENT_FIND_SEGMENT_SUCCESS);
        segmentEvent.setSegment(mSegment);
        RxBus.getInstance().post(segmentEvent);
    }

    /**
     * 解析更新皮带机状态
     */
    private void parseBeltStatus() {
        ArrayList<BeltConfigSub.BeltBindInfo> beltResults = new ArrayList<>();

        if (!TextUtils.isEmpty(mSegment.getBeltConfig())) {
            beltConfig = JSON.parseObject(mSegment.getBeltConfig(), BeltConfig.class);
            if (beltConfig.getJDQ() != null && !CollectionUtils.isEmpty(beltConfig.getJDQ().getBelt())) {
                beltCheckType = 1;
            }
            if (beltCheckType == 1) {
                configJDQ(beltConfig.getJDQ());
            } else {
                if (beltConfig.getZY() != null && beltConfig.getZY().getBelt() != null) {
                    beltResults.addAll(beltConfig.getZY().getBelt());
                }
                if (beltConfig.getZD() != null && beltConfig.getZD().getBelt() != null) {
                    beltResults.addAll(beltConfig.getZD().getBelt());
                }
                if (beltConfig.getCharger() != null && beltConfig.getCharger().getBelt() != null) {
                    beltResults.addAll(beltConfig.getCharger().getBelt());
                }
            }
        }

        boolean oldBeltStartStatus = isBeltConveyorStart;
        int oldInspectDirection = inspectManager.inspectDirection;
        List<BeltRunStatus> newBeltResults = JsonHelper.parseJson(mSegment.getBeltResult(), new TypeReference<List<BeltRunStatus>>(){});
        if (newBeltResults != null && newBeltResults.size() > 0)
            newBeltResults = newBeltResults.stream().filter(t -> (System.currentTimeMillis() - t.getUpdateTime().getTime()) < 600_000).collect(Collectors.toList());
        if (CollectionUtils.isEmpty(newBeltResults)) {
            if (isBeltConveyorStart) {
                isBeltConveyorStart = false;
                UPreferences.putInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 0);
            }
        } else {
            boolean allBeltClosed = newBeltResults.stream().noneMatch(BeltRunStatus::getResult);

            if (allBeltClosed) {
                isBeltConveyorStart = false;
            } else {
                for (int i = 0; i < newBeltResults.size(); i++) {
                    BeltRunStatus beltRunStatus = newBeltResults.get(i);
                    beltResults.stream().filter(beltBindInfo -> NumberUtil.notNullAndEqual(beltRunStatus.getBeltID(),
                                    beltBindInfo.getBeltID()))
                            .findFirst()
                            .ifPresent(beltBindInfo -> {
                                beltBindInfo.setResult(beltRunStatus.getResult());
                                ULog.d(TAG,
                                        "parseBeltStatus == belt id:" + beltBindInfo.getBeltID() + ", dir=" + beltBindInfo.getDirection() +  ", started=" + beltBindInfo.isResult());
                                if (!isBeltConveyorStart && beltRunStatus.getResult()) {
                                    isBeltConveyorStart = true;
                                }
                            });
                }

                if (isBeltConveyorStart) {
                    //都是正向算正向 都是反向算反向 否则算双向
                    AtomicInteger toFrontNum = new AtomicInteger();
                    AtomicInteger toEndNum = new AtomicInteger();
                    AtomicInteger openNum = new AtomicInteger();
                    beltResults.stream().filter(beltBindInfo -> beltBindInfo.isResult())
                            .forEach(beltBindInfo -> {
                                if (beltBindInfo.getDirection() == 1) {
                                    toFrontNum.getAndIncrement();
                                } else if (beltBindInfo.getDirection() == 2) {
                                    toEndNum.getAndIncrement();
                                }
                                openNum.getAndIncrement();
                            });

                    if (toFrontNum.get() == openNum.get()) {
                        inspectManager.inspectDirection = MOVE_FRONT;
                        inspectManager.inspectDirectionIsUpdate = true;
                    } else if (toEndNum.get() == openNum.get()) {
                        inspectManager.inspectDirection = MOVE_END;
                        inspectManager.inspectDirectionIsUpdate = true;
                    } else {
                        inspectManager.inspectDirection = 3;
                    }
                } else {
                    inspectManager.inspectDirection = 3;
                }
                if (oldInspectDirection != inspectManager.inspectDirection) {
                    ULog.i(TAG,
                            "parseBeltStatus == inspection direction change from " + oldInspectDirection + " -> " + inspectManager.inspectDirection + ", " +
                            "inspectDirectionBackup " + inspectManager.inspectDirectionBackup);
                    UPreferences.putInt(mActivity,
                            UConstants.PREFERENCES_INSPECTION_USE_ANGLE_TYPE_KEY,
                            inspectManager.inspectDirection);
                }
            }

            newBeltResults.forEach(item -> item.setLocalUpdateTime(new Date()));
            beltRunStatuses = newBeltResults;
        }

        if (oldBeltStartStatus != isBeltConveyorStart) {
            //发生变化
            if (isBeltConveyorStart) {
                UPreferences.putInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 1);
                UPreferences.putLong(mActivity,
                        UConstants.PREFERENCES_BELT_CONVEYOR_START_DATE_KEY,
                        System.currentTimeMillis());
                isBeltConveyorStart = true;
                ULog.d(TAG,
                        "parseBeltStatus ==== 皮带机开始运转 = " + (mInspectionEnableThread == null ? "null" : mInspectionEnableThread.isAlive()));
                if (getInspectEnableThreadNeedExec()) {
                    mInspectionEnableThread.start();
                }
            } else {
                UPreferences.putInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 0);
                ULog.d(TAG, "parseBeltStatus ==== 皮带机停止运转");
                if (MODE != MODE_GOTO_CHARGER) {
                    autoMoveManager.gotoChargerCheck("皮带机停止1_回充");
                }
            }
        }

    }

    private long lastUpdateBeltConfigTime;
    //皮带id对应的结果解析位
    Map<String, String> beltMap = new HashMap<>();

    private void configJDQ(BeltConfigSub jdqConfig) {
        //TODO 伊泰京粤-酸刺沟 主斜井 机器人
        List<BeltConfigSub.BeltBindInfo> beltInfos = jdqConfig.getBelt();
        String ip = null;
        if (beltInfos != null && beltInfos.size() != 0) {
            for (int i = 0; i < beltInfos.size(); i++) {
                String id = beltInfos.get(i).getID();
                String[] params = id.split(",");
                if (params != null && params.length == 2) {
                    if (i == 0) {
                        ip = params[0];
                    }
                    beltMap.put(String.valueOf(beltInfos.get(i).getBeltID()), String.valueOf(params[1]));
                }
            }
        }
        for (String key : beltMap.keySet()) {
            ULog.d(TAG, "jdq 继电器配置 皮带ID:" + key + " 解析位:" + beltMap.get(key) + " ip:" + ip);
        }
        //        ULog.d(TAG, "handleMessage:jdq 酸刺沟-主斜井- 皮带启停 创建继电器连接...");
        if (beltConveyorStatus == null && !TextUtils.isEmpty(ip)) {
            beltConveyorStatus = ModBusManager.getInstance();
            ModBusTask.DEVICE_ADDRESS = 33;//485地址
            //                    SLog.setIsDebug(true);
            beltConveyorStatus.initSocket(ip, 8899);
            beltConveyorStatus.setOnSocketListener(new ModBusManager.onModBusSocketListener() {
                @Override
                public void onSocketReadResponse(ConnectionInfo connectionInfo, String s, OriginalData originalData) {
                    byte[] respData = ArrayUtils.addAll(originalData.getHeadBytes(), originalData.getBodyBytes());
                    byte[] headData = originalData.getHeadBytes();
                    ULog.d(TAG, "jdq onSocketReadResponse: headData = " + UByte.print(headData, headData.length));

                    jdqParseResult(respData);
                }

                @Override
                public void onSocketDisconnection(ConnectionInfo connectionInfo, String s, Exception e) {
                    ULog.i("onSocketDisconnection" + s + " |" + e.getMessage());

                }

                @Override
                public void onSocketConnectionFailed(ConnectionInfo connectionInfo, String s, Exception e) {
                    ULog.i("onSocketConnectionFailed" + s + " |" + e.getMessage());

                }

                @Override
                public void onSocketConnectionSuccess(ConnectionInfo connectionInfo, String s) {
                    if (mHandler.hasMessages(Msg.WHAT_BELT_CONVEYOR_STATUS)) {
                        mHandler.removeMessages(Msg.WHAT_BELT_CONVEYOR_STATUS);
                    }
                    mHandler.sendEmptyMessage(Msg.WHAT_BELT_CONVEYOR_STATUS);
                }
            });
        }
    }

    private void jdqParseResult(byte[] respData) {
        try {
            ULog.d(TAG,
                    "jdq onSocketReadResponse: respData = " + UByte.print(respData,
                            respData.length) + "byte = " + respData[0] + "address = " + ModBusTask.DEVICE_ADDRESS);
            //21 02 01 00 AA 48
            //21模块地址  02功能码  01寄存器地址 00八路输入状态——X07-X00
            if (ModBusTask.DEVICE_ADDRESS == respData[0]) {
                if (respData[1] == ModBusTask.READ_INPUT_STATUS) {
                    boolean[] results = new boolean[8];//8个位置的结果 X00-X07
                    for (int i = 0; i < 8; i++) {
                        results[i] = (respData[3] & (0b1 << i)) == (0b1 << i);
                    }
                    String inputStatus = UByte.hex2binary(UByte.toHexString(new byte[]{respData[3]}));
                    ULog.d(TAG, "onSocketReadResponse: jdq继电器电器状态 inputStatus = " + inputStatus + "模式: " + MODE);
                    //                                isBeltConveyorStart = UPreferences.getInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 0) == 1;
                    String finalResult = "[{";
                    boolean beltResult = false;
                    for (String belt : beltMap.keySet()) {
                        String positionStr = beltMap.get(belt);
                        int position = -1;
                        if (!TextUtils.isEmpty(positionStr)) {
                            position = Integer.parseInt(positionStr);
                        }
                        if (position >= 0 && position < 8) {
                            if (results[position]) {
                                beltResult = true;
                            }
                            if (!finalResult.equals("[{")) {
                                finalResult += ",{";
                            }
                            finalResult += ("\"result\":" + results[position] + ",\"beltId\":" + belt + ",\"from\":\"JDQ\",\"updateTime\":" + System.currentTimeMillis() + "}");
                        }
                    }
                    if (!finalResult.equals("[{")) {
                        finalResult += "]";
                    } else {
                        finalResult += "}]";
                    }
                    ULog.d(TAG, "jdq finalResult " + finalResult);
                    Message msg = mHandler.obtainMessage();
                    msg.what = Msg.WHAT_UPDATE_BELT_STATUS;
                    msg.obj = finalResult;
                    mHandler.sendMessage(msg);
                    if ((isBeltConveyorStart && !beltResult) || (!isBeltConveyorStart && beltResult)) {
                        updateHistoryTime(beltResult ? TimeType.BELT_START_TIME : TimeType.BELT_STOP_TIME, "10");
                    }
                    //                                if ("1".equals(inputStatus.substring(7)) && !isBeltConveyorStart) {
                    //                                    //皮带机开启
                    //                                    beltConveyorStart();
                    //                                } else if ("0".equals(inputStatus.substring(7)) && isBeltConveyorStart) {
                    //                                    //皮带机关闭
                    //                                    beltConveyorStop();
                    //                                }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private boolean isMove;

    private void serverHeartStopHandle() {
        isMove = getRealSpeed(Math.abs(mMotorSpeed)) > UConstants.MIN_SPEED;
        ULog.d(TAG,
                "serverHeartStatus:" + serverHeartNormal + ",isMove:" + isMove + ",MODE:" + MODE);
        serverHeartNormal = false;
        //机器人处于自动建图模式如果出现断网重连失败不能影响自动建图
        if (MODE != MODE_AUTO_BUILD_MAP && MODE != MODE_GOTO_CHARGER) {
            if (RobotBluetoothManager.getInstance().isConnect()) {
                //蓝牙控制时不断网回充
                ULog.w(TAG, "bluetooth 蓝牙连接中，不断网回充");
                return;
            } else if (MODE == MODE_DEVICE_CLEAN) {
                ULog.w(TAG, "正在除尘，不断网回充");
                return;
            }
            if (!moveHinderNeedSleep) {
                moveHinderNeedSleep = UPreferences.getBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NEED_SLEEP_KEY, false);
                moveHinderLowPower = UPreferences.getBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_LOW_POWER_GO_CHARGER_KEY, false);
                moveHinderNetDisconnect = UPreferences.getBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NET_DISCONNECT_GO_CHARGER_KEY, false);
                sleepTimeMoveHinder = getSleepTimeMoveHinder();

                ULog.w(TAG,"断网回充 == 运动阻碍休眠状态 moveHinderNeedSleep = " + moveHinderNeedSleep + " moveHinderLowPower " + moveHinderLowPower + " moveHinderNetDisconnect " + moveHinderNetDisconnect + " sleepTimeMoveHinder " + sleepTimeMoveHinder);
            }

            if (moveHinderNeedSleep && !moveHinderNetDisconnect) {
                ULog.w(TAG,"断网回充 == 运动阻碍，等待人为控制，不执行断网回充逻辑==");
                return;
            } else {
                if (moveHinderNeedSleep) {
                    moveHinderNetDisconnect = false;
                    UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NET_DISCONNECT_GO_CHARGER_KEY, false);
                }
            }

            stmExecute.executeTaskNonQueue(new StmTask().stopMove("断网回充 52"));
            //                MainApp.from(mActivity).pushLog("断网回充，MODE_" + MODE);
            ULog.d(TAG, "serverHeartStopHandle: 断网回充，MODE_" + MODE);
            autoMoveManager.gotoChargerCheck("断网_回充");
        }

    }


    public void refreshRobotType() {
        if (mRobotType != null) {
            if (mRobotType.getMainType() == RobotMainType.CICADA) {
                //老版cicada
                //                    UConstants.DISTANCE_TWO_ROUND = 0.18849;
                //                    UConstants.ONE_ROUND_STEP = 80000;
                //                    defaultRotate = (int) ((20 / UConstants.DISTANCE_TWO_ROUND) * 2);
                //                    UConstants.MAX_MOTOR_ROTATION_RATE = 3000;
                //                    UConstants.MOTOR_REDUCTION_RATIO = 8;

                //带云台cicada
                //                    UConstants.DISTANCE_TWO_ROUND = 0.21363;
                ////                    UConstants.ONE_ROUND_STEP = 79872;
                ////                    defaultRotate = (int) ((20 / UConstants.DISTANCE_TWO_ROUND) * 2);
                ////                    UConstants.MAX_MOTOR_ROTATION_RATE = 1000;
                ////                    UConstants.MOTOR_REDUCTION_RATIO = 4;
                if (mRobotType.getSubType() == RobotSubType.MA || mRobotType.getSubType() == RobotSubType.FB) {
                    //煤安板
                    UConstants.DISTANCE_TWO_ROUND = 0.18849;
                    UConstants.ONE_ROUND_STEP = 8000;
                    UConstants.MAX_MOTOR_ROTATION_RATE = 1000;
                    UConstants.MOTOR_REDUCTION_RATIO = 1;//TODO 临时修改0.67
                    defaultRotate = (int) ((20 / UConstants.DISTANCE_TWO_ROUND) * 2);
                } else {
                    UConstants.DISTANCE_TWO_ROUND = 0.18849;
                    UConstants.ONE_ROUND_STEP = 52429;
                    UConstants.MAX_MOTOR_ROTATION_RATE = 1000;
                    UConstants.MOTOR_REDUCTION_RATIO = 1.6;
                    defaultRotate = (int) ((20 / UConstants.DISTANCE_TWO_ROUND) * 2);
                }
            } else if (mRobotType.getMainType() == RobotMainType.LADYBUG) {
                UConstants.DISTANCE_TWO_ROUND = 0.18849;
                UConstants.ONE_ROUND_STEP = 52429;
                UConstants.MAX_MOTOR_ROTATION_RATE = 1000;
                UConstants.MOTOR_REDUCTION_RATIO = 1.6;
                defaultRotate = (int) ((20 / UConstants.DISTANCE_TWO_ROUND) * 2);
            }
            UConstants.MAX_SPEED = UConstants.MAX_MOTOR_ROTATION_RATE / UConstants.MOTOR_REDUCTION_RATIO * UConstants.DISTANCE_TWO_ROUND / 2.0 / 60.0;
        }
    }

    /**
     * 解析机器人配置信息，如果失败，再次请求获取机器人信息
     *
     * @param robot
     */
    private void parseRobotInfo(Robot robot) {
        if (robot == null) {
            return;
        }
        try {
            ULog.d(TAG, "parseRobotInfo: 开始解析机器人配置：" + robot.getId());


            //                ULog.d(TAG, "注册完成   old  " + (getRobot() == null ? "null" : getRobot().getId()) + " new " + robot.getId());
            MainApp.setRobot(robot);
            //设置userid方便追踪异常
            CrashReport.setUserId(robot.getId());

            //BMS
            if (!getRobot().getActive()) {
                ULog.d(TAG, "parseRobotInfo:  == 机器人不可用");
                return;
            }

            mBotInfoMgr.initRobot(robot);
            mRobotType = mBotInfoMgr.getRobotType();

            if (mRobotType == null && TextUtils.isEmpty(robot.getType())) {
                ULog.e(TAG, "机器人类型为空");
                RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_FETCH_ROBOT_INFO));
                return;
            }

            if (mSensorManager.cacheInfo().BMS_INFO != null) {
                BaseBmsCommunicator.getInstance().init(mSensorManager.cacheInfo().BMS_INFO);
                BaseBmsCommunicator.getInstance().registerDataEventListener(this);
                BaseBmsCommunicator.getInstance().continuousQuery();
            }

            RfidController.getInstance().init(mBotInfoMgr.getRobotConfigParams().getRfidType());
            RfidController.getInstance().readHardwareVersion();
            RfidController.getInstance().readFirmwareVersion();
            RfidController.getInstance().readPower();
            RfidController.getInstance().continuousQueryTag();

            if (mBotInfoMgr.getRobotConfigParams().getRfidType() == 0 &&
                    (getRobot().getRfidReadPower() >= 5 || getRobot().getRfidReadPower() <= 25) &&
                    (getRobot().getRfidWritePower() >= 5 || getRobot().getRfidWritePower() <= 25)) {
                ULog.d(TAG, "setPower 设置rfid功率 = read " + getRobot().getRfidReadPower() + " write " + getRobot().getRfidWritePower());
                RfidController.getInstance().setPower(getRobot().getRfidReadPower(), getRobot().getRfidWritePower(), true);
            }

            if (mRobotType.getSubType() == RobotSubType.FB || mRobotType.getSubType() == RobotSubType.MA && !mSequenceInitializer.getInitResult("ROOM_CONFIG")) {
                mSequenceInitializer.registerEventInitRet("ROOM_CONFIG", RobotEvent.class, RobotEvent.ACTION_CICADA_ROOM_CONFIG_FINISHED);
                CicadaRoomController.getInstance().registerDoorStateListener(mDoorStateChangeListener);
                CicadaRoomController.getInstance().init();
            }

            if (mSensorManager.isHaveSensorAndEnabled(SensorType.SENSOR_TYPE_WEB_CAMERA)) {
                WebCameraSensorInfo webcamInfo = (WebCameraSensorInfo) mSensorManager.findConfigedAndEnabledSensors(SensorType.SENSOR_TYPE_WEB_CAMERA)
                        .get(0);
                ULog.e(TAG, "WebCamManager.init==webcamInfo>>" + JSON.toJSONString(webcamInfo));
                WebCamManager.getInstance().init(mActivity, webcamInfo);
                if (WebCamManager.getInstance().getCameraType() == 4) {
                    if (!XMWebCamera.isInit) {
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_XM_INIT, 5000);
                    }
                }

                if (!TextUtils.isEmpty(getRobot().getNetworkCameraIp()) && FormatUtils.isLegalIP(getRobot().getNetworkCameraIp())) {
                    WebCameraPusher.webCameraIp = getRobot().getNetworkCameraIp();
                    WebCamManager.getInstance().setWebCamIpAddress(getRobot().getNetworkCameraIp());
                    updatePusher(4);
                }
            } else {
                ULog.e("======>>网络摄像头没有设置（在传感器中没有设置）");
            }

            if (mBotInfoMgr.isHaveSteer()) {
                SteerController.getInstance().setDefaultDustingAngle(mBotInfoMgr.getRobotConfigParams().getDustHorizontalAngle(),
                        mBotInfoMgr.getRobotConfigParams().getDustVerticalAngle());

                Float min = mBotInfoMgr.getRobotConfigParams().getMinAngleH();
                Float max = mBotInfoMgr.getRobotConfigParams().getMaxAngleH();
                if (mBotInfoMgr.getRobotSubType() == RobotSubType.MA) {
                    SteerController.getInstance().setHorizontalAngleRange(min == null ? 25 : min, max == null ? 355 : max);
                } else {
                    SteerController.getInstance().setHorizontalAngleRange(min == null ? 15 : min, max == null ? 345 : max);
                }
            }

            if ((MainApp.mAngleH == null || MainApp.mAngleV == null) && MainApp.mRobot.getCurrentCameraAngle() != null) {
                String currentCameraAngle = MainApp.mRobot.getCurrentCameraAngle();
                CurrentCameraAngle currentCameraAngle1 = UGson.getGson().fromJson(currentCameraAngle, CurrentCameraAngle.class);

                MainApp.mAngleH = currentCameraAngle1.getH();
                MainApp.mAngleV = currentCameraAngle1.getV();
            }
            WebCamManager.isCamWhiteLight = getRobotConfigParams().getCamWhiteLight();
            MainApp.isShowIrTime = getRobotConfigParams().getShowIrTime();
            MainApp.irDetectMode = getRobotConfigParams().getIrDetectMode();
            MainApp.controlMode = getRobotConfigParams().getControlMode();
            MainApp.checkBMSStatus = getRobotConfigParams().getCheckBMSStatus();
            MainApp.BMS_HEAT_OPEN = getRobotConfigParams().getBmsHeatLowThreshold();
            MainApp.BMS_HEAT_CLOSE = getRobotConfigParams().getBmsHeatHighThreshold();
            FillLightController.MAX_BRIGHTNESS = getRobotConfigParams().getMaximumCurrentThresholdFillLight();
            ULog.d(TAG, "补光灯最大亮度 " + FillLightController.MAX_BRIGHTNESS);
            if (getRobot().getNetworkCameraResolution() != null) {
                if (getRobot().getNetworkCameraResolution() == 1) {
                    //                    WebCameraPusher.bitRate = "1";
                    WebCamManager.getInstance().setStreamType(1);
                } else if (getRobot().getNetworkCameraResolution() == 2) {
                    //                    WebCameraPusher.bitRate = "0";
                    WebCamManager.getInstance().setStreamType(0);
                }
            }

            mHandler.sendEmptyMessage(Msg.WHAT_SET_NET_IP);

            //设置报警处理开关
            mAlarmManager.initialize(robot.getId(), robot.getType());

            if (robot.getAlarmStop() != null) {
                ULog.d(TAG, "报警处理开关状态：" + robot.getAlarmStop());
                mAlarmManager.setIsNeedToWaitAlarmProcessed(robot.getAlarmStop() == UConstants.VALUE_SWITCH_STATUS_ON);
            }

            //            mDistance = getRobot().getRealMileage() != null ? getRobot().getRealMileage() : 0;
            float savedDistance = StorageCenter.getRobotStorage().getFloat("motor_distance", -1f);
            if (savedDistance != -1) {
                mDistance = savedDistance;
            } else if (getRobot().getRealMileage() != null) {
                mDistance = getRobot().getRealMileage();
            }

            String statusUploadValue = StorageCenter.getRobotStorage().getString(UConstants.PREFERENCES_ROBOT_UPLOAD_STATUS_VALUE_KEY, "");
            ULog.d(TAG, "读取需要上传的统计信息 = " + statusUploadValue);
            if (!TextUtils.isEmpty(statusUploadValue) && !"[]".equalsIgnoreCase(statusUploadValue)) {
                ConcurrentHashMap<String, StatisticInfo> stInfoUploadTemp = gson.fromJson(statusUploadValue, new TypeToken<ConcurrentHashMap<String, StatisticInfo>>() {}.getType());
                if (!stInfoUploadTemp.isEmpty()) {
                    MainApp.mStInfoUpload = stInfoUploadTemp;
                }
            }


            String statusValue = getRobot().getStatusValue();
            StatisticInfo stInfo = null;
            if (!TextUtils.isEmpty(statusValue)) {
                stInfo = gson.fromJson(statusValue, StatisticInfo.class);
            }
            float tempDrivingMileage = StorageCenter.getRobotStorage().getFloat(UConstants.PREFERENCES_DRIVING_MILEAGE_KEY, -1f);
            if (MainApp.mDrivingMileage == UConstants.UNKONW) {
                if (tempDrivingMileage > 0) {
                    MainApp.mDrivingMileage = tempDrivingMileage;
                } else if (getRobot().getDrivingMileage() != null) {
                    MainApp.mDrivingMileage = getRobot().getDrivingMileage();
                }
            }
            float tempInspectionTotalMileage = StorageCenter.getRobotStorage().getFloat(UConstants.PREFERENCES_INSPECTION_TOTAL_MILEAGE_KEY, -1f);
            if (MainApp.mStInfo.getInspectionTotalMileage() == UConstants.UNKONW) {
                if (tempInspectionTotalMileage > 0) {
                    MainApp.mStInfo.setInspectionTotalMileage(tempInspectionTotalMileage);
                } else if (stInfo != null && stInfo.getInspectionTotalMileage() != UConstants.UNKONW) {
                    MainApp.mStInfo.setInspectionTotalMileage(stInfo.getInspectionTotalMileage());
                }
            }

            long tempChargingTime = StorageCenter.getRobotStorage().getLong(UConstants.PREFERENCES_CHARGING_TOTAL_TIME_KEY, -1L);
            if (MainApp.mStInfo.getChargingTotalTime() == UConstants.UNKONW) {
                if (tempChargingTime > 0) {
                    MainApp.mStInfo.setChargingTotalTime(tempChargingTime);
                } else if (stInfo != null && stInfo.getChargingTotalTime() != UConstants.UNKONW) {
                    MainApp.mStInfo.setChargingTotalTime(stInfo.getChargingTotalTime());
                }
            }

            long tempInspectTime = StorageCenter.getRobotStorage().getLong(UConstants.PREFERENCES_INSPECTION_TOTAL_TIME_KEY, -1L);
            if (MainApp.mStInfo.getInspectionTotalTime() == UConstants.UNKONW) {
                if (tempInspectTime > 0) {
                    MainApp.mStInfo.setInspectionTotalTime(tempInspectTime);
                } else if (stInfo != null && stInfo.getInspectionTotalTime() != UConstants.UNKONW) {
                    MainApp.mStInfo.setInspectionTotalTime(stInfo.getInspectionTotalTime());
                }
            }

            Long saveServerTotalTime = UConstants.getRealTime(mActivity);
            if (saveServerTotalTime == null) {
                if (stInfo != null && stInfo.getOnlineTotalTime() != UConstants.UNKONW) {
                    UConstants.setRealTime(stInfo.getOnlineTotalTime());
                    ULog.d(TAG, "服务器统计的在线时长 " + stInfo.getOnlineTotalTime());
                } else {
                    ULog.d(TAG, "服务器无统计在线时长");
                    UConstants.setRealTime(0);
                }
            }
            int tempInspectNum = StorageCenter.getRobotStorage().getInteger(UConstants.PREFERENCES_INSPECTION_TOTAL_NUM_KEY, -1);
            if (MainApp.mStInfo.getInspectionTotalNum() == UConstants.UNKONW) {
                if (tempInspectNum > 0) {
                    MainApp.mStInfo.setInspectionTotalNum(tempInspectNum);
                } else if (stInfo != null && stInfo.getInspectionTotalNum() != UConstants.UNKONW) {
                    MainApp.mStInfo.setInspectionTotalNum(stInfo.getInspectionTotalNum());
                }
            }
            if (toMapEndNum == UConstants.UNKONW) {
                toMapEndNum = StorageCenter.getRobotStorage().getInteger(UConstants.PREFERENCES_INSPECTION_TO_END_NUM_KEY, -1);
            }
            if (toMapHeadNum == UConstants.UNKONW) {
                toMapHeadNum = StorageCenter.getRobotStorage().getInteger(UConstants.PREFERENCES_INSPECTION_TO_HEAD_NUM_KEY, -1);
            }
            ULog.d(TAG, "readCache toMapHeadNum " + toMapHeadNum + " toMapEndNum " + toMapEndNum);
            //在By范围内则关闭避障，否则开启避障
            if (mDistance != UConstants.UNKONW)
                ObstacleController.getInstance().setObstacleOn(!isInCleanDeviceArea(mDistance),"18");

            isGrayUpgrade = robot.getGrayUpgrade() != null && robot.getGrayUpgrade();
            /**
             * 保存机器人配置数据到本地，以备使用
             * @see #findRobot
             */
            RobotPreferences.getInstance(getContext()).setRobot(getContext(), robot);

            ULog.d(TAG, "获取完成  " + robot.getId());
            //            MainApp.from(mActivity).aLiLog = ALiYunLog.getInstance(mActivity.getApplicationContext(), MainApp.APP_NAME, ALiYunLog.TYPE_ROBOT);

            irPusher = getIrPusher();
            irPusher.registerAuthentication(this);

            //                if (robot.getPushLog() != null && robot.getPushLog() == 1 && !TextUtils.isEmpty(robot.getLogstashAddress()))
            //                    mActivity.readLogcatToFile(robot.getLogstashAddress());
            refreshRobotType();

            webCameraNum = mSensorManager.cacheInfo().WEBCAM_INFO == null ? 0 : 1;
            ULog.d(TAG,
                    "parseRobotInfo:  == getRobot():" + getRobot() + ",getRobot().getWebCameraNum():" + webCameraNum);
            if (webCameraNum > 0) {
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_CHECK_WEB_CAMERA, 10 * 1000);
            }

            if (!mHandler.hasMessages(Msg.WHAT_STM_NORMAL_CHECK)) {
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_STM_NORMAL_CHECK, 60_000);
            }
            //            if (getRobot().getDetectionFrameNum() != null) {
            //                detectionFrameNum = getRobot().getDetectionFrameNum();
            //            }
            if (getRobot().getRecordLocalSwitch() != null) {
                recordLocalSwitch = getRobot().getRecordLocalSwitch();
            }
            if (getRobot().getBatteryPowerOffThreshold() != null) {
                batteryPowerOff = getRobot().getBatteryPowerOffThreshold();
            }
            if (getRobot().getBatteryPowerOnThreshold() != null) {
                batteryPowerOn = getRobot().getBatteryPowerOnThreshold();
            }
            if (getRobot().getHeatingThresholdOpen() != null) {
                heatOpenThreshold = getRobot().getHeatingThresholdOpen();
            }
            if (getRobot().getHeatingThresholdClose() != null) {
                heatCloseThreshold = getRobot().getHeatingThresholdClose();
            }
            if (mRobotType.getSubType() == RobotSubType.FB || mRobotType.getSubType() == RobotSubType.MA) {
                voltageLow = 3.5f;
            }
            if (getRobot().getVoltageLow() != null) {
                voltageLow = getRobot().getVoltageLow();
            }
            lowTempThreshold = getRobotConfigParams().getLowTempThreshold();
            RfidController.minRssi = getRobotConfigParams().getRfidMinRssi();
            SmartRtspToRtmp.recognitionMode = getRobotConfigParams().getCokeOvenRecognitionMode();
            MainApp.isLocalRecordVideo = getRobotConfigParams().getRecordVideo();
            MainApp.isRgbRecognition = getRobotConfigParams().getRgbRecognition();
            RecordIrData.recordIrRawDataTempThreshold = getRobotConfigParams().getRecordIrRawDataTempThreshold();
            MainApp.isRecordIrRawData = getRobotConfigParams().getRecordIRRawData();
            MainApp.arrangeInspectRelBelt = getRobotConfigParams().getArrangeInspectRelateBeltStatus();
            MainApp.networkIsMobile = getRobotConfigParams().getNetworkType() != 0;
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCE_IS_MOBILE_NETWORK_KEY, MainApp.networkIsMobile);
            MainApp.isReclaimer = getRobot().getChargeStrategy() != null && getRobot().getChargeStrategy() == ChargingStrategy.INSPECTION_MATERIAL_TAKING_MACHINE;
            String minioIp = null;
            if (!TextUtils.isEmpty(getRobotConfigParams().getMinioAddrOfLocalRecordVideo())) {
                minioIp = getRobotConfigParams().getMinioAddrOfLocalRecordVideo();
            } else if (!TextUtils.isEmpty(getRobot().getMinioIp())) {
                minioIp = getRobot().getMinioIp();
            }
            if (!UString.isEmpty(minioIp) && MainApp.mMinioVideo == null) {
                ULog.d(TAG, "MainApp.mMminioVideo ip " + minioIp);
                MainApp.mMinioVideo = Minio.getInstance(MainApp.MINIO_VIDEO_KEY, minioIp);
                MainApp.mMinioVideo.client.setTimeout(10_000, 60_000, 60_000);
            }
            boolean pmbp = getRobotConfigParams().getBatterySecondaryProtection();
            ULog.d(TAG, "parseRobotInfo 电池二级保护 pmbp = " + pmbp);
            ULog.d(TAG, "parseRobotInfo by 温控参数 OpenHeater " + getRobotConfigParams().getByTempControlOpenHeater() + " closeHeater " + getRobotConfigParams().getByTempControlCloseHeater() + " OpenCooler " + getRobotConfigParams().getByTempControlOpenCooler() + " CloserCooler " + getRobotConfigParams().getByTempControlCloserCooler());
            stmExecute.executeTask(new StmTask().switchComponentEnable(pmbp, StmTask.FuncPowerBit.POWER_MANAGER_BATTERY_PROTECTION));
            //            MainApp.from(mActivity).pushLog("设置加热温度 open=" + heatOpenThreshold + " close=" + heatCloseThreshold);
            //                stmExecute.executeTask(new StmTask().setHeatingThreshold(heatOpenThreshold, heatCloseThreshold));
            robotId = robot.getId();
            if (robot.getSendMessageMode() != null) {
                sendMessageMode = robot.getSendMessageMode();
            }
            if (robot.getSelfLoraAddress() != null && robot.getSelfLoraChannel() != null) {
                UPreferences.putInt(mActivity, UConstants.PREFERENCES_LORA_ADDRESS_KEY, robot.getSelfLoraAddress());
                UPreferences.putInt(mActivity, UConstants.PREFERENCES_LORA_CHANNEL_KEY, robot.getSelfLoraChannel());
                RxBus.getInstance().post(new LoraEvent(RobotEventConstants.EVENT_LORA_INFO_SETTINGS,
                        robot.getSelfLoraAddress(), robot.getSelfLoraChannel()));
            }
            //            autoMoveManager.setBoundDistance(getRobot().getFrontBoundsDistance(), getRobot().getEndBoundsDistance(), getRobot().getTargetBoundsDistance());
	        //todo 2022年8月25日 决定越界距离选择
	        autoMoveManager.setBoundDistance(robot.getTargetBoundsDistance());
/*	        if (MapManager.getInstance().getRfidMapType() == RfidMapType.CIRCLE) {
                autoMoveManager.setBoundDistance(4.0f);
            } else if (robot.getTargetBoundsDistance() != null) {
                autoMoveManager.setBoundDistance(robot.getTargetBoundsDistance());
            }*/

            if (robot.getUploadFileType() != null) {
                MainApp.uploadFileType = robot.getUploadFileType();
            }
            mHandler.sendEmptyMessage(Msg.WHAT_CHECK_NETWORK_STATE);
            if (robot.getSamplingInterval() != null && robot.getSamplingInterval() != 0) {
                deltT = robot.getSamplingInterval() * 1000;
            }
            if (robot.getSampleSize() != null && robot.getSampleSize() != 0) {
                meanLen = robot.getSampleSize();
            }
            if (robot.getSamplingTimeOut() != null && robot.getSamplingTimeOut() != 0) {
                maxRunTime = robot.getSamplingTimeOut();
            }
            if (robot.getSampleResultThreshold() != null && robot.getSampleResultThreshold() != 0) {
                thresh = robot.getSampleResultThreshold();
            }
            if (robot.getSampleResultRightNumThreshold() != null && robot.getSampleResultRightNumThreshold() != 0) {
                ctimesThresh = robot.getSampleResultRightNumThreshold();
            }

            if (!mHandler.hasMessages(Msg.WHAT_BIND_IR_SERVICE) && robot.getIrCameraNum() != null && robot.getIrCameraNum() != 0) {
                mHandler.sendEmptyMessage(Msg.WHAT_BIND_IR_SERVICE);
            }
            if (!mHandler.hasMessages(Msg.WHAT_BIND_RGB_SERVICE) && robot.getRgbCameraNum() != null && robot.getRgbCameraNum() != 0) {
                mHandler.sendEmptyMessage(Msg.WHAT_BIND_RGB_SERVICE);
            }
            //保存ssid ssidpwd
            mBotInfoMgr.getRobotConfigParams().getWifiConfigParams().setConfigSsid(robot.getSsid());
            mBotInfoMgr.getRobotConfigParams().getWifiConfigParams().setConfigPass(robot.getSsidPwd());
            UPreferences.putString(BaseApplication.getInstance(),
                    NetworkService.KEY_WIFI_PARAMS,
                    JsonHelper.toJson(mBotInfoMgr.getRobotConfigParams().getWifiConfigParams()));
            RxBus.getInstance().post(new NetworkEvent(NetworkEvent.ACTION_WIFI_CONFIG_PARAMS_UPDATED,
                    mBotInfoMgr.getRobotConfigParams().getWifiConfigParams()));

            setRfidReadType(getRobotConfigParams().getRfidType());
            if (rfidReadType == 2 || rfidReadType == 3) {
                defaultRotate = UConstants.UNKONW;
            }
            isUploadIrFrameTemp = getRobotConfigParams().getIsUploadIrFrame();
            lastIsUploadIrFrameTemp = isUploadIrFrameTemp;
            uploadIrFrameHost = getRobotConfigParams().getUploadIrFrameHost();

            ULog.isDebug(!getRobotConfigParams().getIsCloseDebugLog());

            if (getRobotConfigParams().getIsOpenCpuLog()) { //开始查询cpu信息
                PerformanceManager.mStop = false;
                PerformanceManager.getInstance().startChipTemperatureCheck();
            } else {
                PerformanceManager.mStop = true;
            }

            if (getRobotConfigParams().getCpuMaxFreq() != 0) {
                CpuUtils.setCpuMaxFreq(getRobotConfigParams().getCpuMaxFreq());
            }

            if (getRobotConfigParams().getTempDiffToShutter() > 0) {
                IrManager.tempDiffToShutter = getRobotConfigParams().getTempDiffToShutter();
            }

            UConstants.DEFAULT_ELEVATOR_NEAR_SPEED = getRobotConfigParams().getDefaultElevatorNearSpeed();

            if (getRobot().getDefaultSpeed() != null && getRobot().getDefaultSpeed() != 0) {
                float speed = (float) (getRobot().getDefaultSpeed() / 100.0);
                UConstants.DEFAULT_SPEED = speed > UConstants.MAX_SPEED ? (float) UConstants.MAX_SPEED : speed;
            }
            if (getRobot().getChargerSpeed() != null && getRobot().getChargerSpeed() != 0) {
                float speed = (float) (getRobot().getChargerSpeed() / 100.0);
                UConstants.DEFAULT_GOTO_CHARGER_SPEED = speed > UConstants.MAX_SPEED ? (float) UConstants.MAX_SPEED : speed;
            }

            //是否有mic  涉及到音频推流
            //                if (getRobot().getIsHaveMic() == 1) {
            //音频推流
            startAudioAnalysis();
            //                }
            //获取音频流播放
            if (mBotInfoMgr.getRobotMainType() == RobotMainType.CICADA) {
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_GET_AUDIO_STREAM, 10 * 1000);
            }

            if (mBotInfoMgr.getRobotMainType() == RobotMainType.LADYBUG) {
                if (getRobot().getRfidDirection() == 1) { //ladybug rfidDirection=1表示红外朝尾端方向，=0表示红外朝首端方向
                    startCheckPositionToHead = getRobot().getBackStartCheckPosition();
                    stopCheckPositionToHead = getRobot().getBackStopCheckPosition();
                    startCheckPositionToTail = getRobot().getBackStartCheckPositionToTail();
                    stopCheckPositionToTail = getRobot().getBackStopCheckPositionToTail();
                } else if (getRobot().getRfidDirection() == 0) {
                    startCheckPositionToHead = getRobot().getFrontStartCheckPosition();
                    stopCheckPositionToHead = getRobot().getFrontStopCheckPosition();
                    startCheckPositionToTail = getRobot().getFrontStartCheckPositionToTail();
                    stopCheckPositionToTail = getRobot().getFrontStopCheckPositionToTail();
                }
            } else {
                //其他型号待定
            }

            if(mBotInfoMgr.getRobotConfigParams().isHaveElevator()){
                //haveElevator 为true 时由ElevatorController查询电梯的配置
                ElevatorController.getInstance(RobotFragment.this).loadElevatorsConfig(robot.getId());
            }else{
                //haveElevator 为false 时直接发送查询电梯配置成功
                ElevatorEvent elevatorEvent = new ElevatorEvent(ElevatorEvent.EVENT_FIND_ELEVATOR_CONFIG_SUCCESS);
                elevatorEvent.setMessage(ElevatorEvent.MSG_NOT_HAVE_ELEVATE_CONFIG);
                RxBus.getInstance().post(elevatorEvent);
            }

            //启动传感器检测
            RobotSensorDetector.getInstance().initDetector();

            //设置Media音量为最大
            AudioUtil.adjustToMaxMediaVolume(BaseApplication.getInstance().getApplicationContext());

            //这个时候获取完地图配置了 机器人配置也解析完成了 检测固定值守点相关功能 需要开启且配置符合条件时 GuardModeManager自动开启
            boolean openSleepMode = getRobot().getSleepMode() == null ? false : getRobot().getSleepMode() == 1;
            if(!openSleepMode
                    && mBotInfoMgr.getRobotConfigParams().isOpenGuard()
                    && MainApp.isArrangeInspect(getRobot().getChargeStrategy())){
                if(GuardModeManager.getInstance().checkConfig()){
                    ULog.d("GuardModeManager","checkConfig通过准备开始相关任务");
                    GuardModeManager.getInstance().ready(getRobot().getCornExpress(),getRobotConfigParams().getArrangeInspectDiff());
                }else{
                    ULog.w("GuardModeManager","checkConfig未通过 请检查相关配置!");
                }
            }
            //V3.0.0 新下位机获取型号后初始化约需200ms, 后面无需等待时间。暂定给3s
            //煤安类型舵机校准正常约需6~7s，也可能会更长，校准期间响应角度调整，但在校准完成后，转到最后一次发送的角度
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_LAZY_INIT_ROBOT, 8_000);
            RxBus.getInstance().post(new RobotEvent(RobotEvent.ACTION_PARSE_ROBOT_SUCCESS));
            ULog.d(TAG,"机器人配置解析完成");
        } catch (Exception e) {
            e.printStackTrace();
            ULog.d(TAG, "parseRobotInfo: 解析异常", e);
            mActivity.runOnUiThread(() -> Toast.makeText(mActivity, "机器人数据解析异常!", Toast.LENGTH_LONG).show());
            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_FETCH_ROBOT_INFO));
        }
    }

    /**
     * 等下位机初始化再初始化串口通信相关任务
     */
    private void lazyInitRobot() {
        try {
            ULog.d(TAG, "lazy init robot tasks");
            getRobot().setMode(MODE_UN_KNOW);
            //修改速度
            setSpeed(UConstants.DEFAULT_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_25);
            isSleep = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_ROBOT_SLEEP_KEY, false);

            //设置休眠间隔
            if (getRobot().getSleepWakeupInterval() != null) {
                if (sleepTime == -1)
                    sleepTime = getRobot().getSleepWakeupInterval();
            }
            stmExecute.executeTask(new StmTask().writeSingleByte(StmTask.PowerManager.REG_SLEEP_WAKEUP_INTERVAL,
                    (int) sleepTime));

            int filterTime = 1;
            boolean isSetRfidFilterTime = UPreferences.getBoolean(getContext(), "has_set_rfid_filter_time", false);
            int rfidFilterTime = UPreferences.getInt(getContext(), "rfid_filter_time", 1);
            if (!isSetRfidFilterTime || rfidFilterTime != filterTime) {
                ULog.d(TAG, "开始设置RFID工作模式");
                RfidController.getInstance().setWorkMode(RFIDTask.WorkMode.MODE_CARD_READER,
                        RFIDTask.WorkMode.DATA_OUTPUT_MODE_SERIAL, filterTime);
                UPreferences.putBoolean(getContext(), "has_set_rfid_filter_time", true);
                UPreferences.putInt(getContext(), "rfid_filter_time", filterTime);
            } else {
                ULog.d(TAG, "RFID工作模式参数无变化");
            }

/*            RfidEvent recoveryPowerEvent = new RfidEvent(RfidEvent.ACTION_WRITE_RFID_POWER);
            recoveryPowerEvent.setWritePower(10);
            recoveryPowerEvent.setReadPower(10);
            RxBus.getInstance().post(recoveryPowerEvent);*/

            //            rfidExecute.executeTask(new RFIDTask().setQueryTagAndWaitTime(1,50,100));
            startHeart();

            //在获取到地图数据的时候 异步获取下取料机检测视角角度
            if(MainApp.isReclaimer){
                ReclaimerInspection.getInstance(RobotFragment.this).getReclaimerInfo(getRobot().getId());
            }
            checkStmConfig();
        } catch (Exception e) {
            ULog.e(TAG, "lazy init failed", e);
            e.printStackTrace();
            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_FETCH_ROBOT_INFO));
        }
    }


    /**************************register end*****************************/

    /**
     * 检查下位机配置
     */
    private void checkStmConfig() {
        HashMap<Integer, String> allConfigParams = new HashMap<>();
        Map<Integer, String> configedParams = getStmConfigedParams();

        //下位机在小于等于3.2.2版本时不支持此功能
        if (AppUtil.isVersionGt("3.2.2", getRobot().getStmVersion())) {
            //设置避障传感器测距距离
            RobotConfigParams configParams = getRobotConfigParams();
            Integer obstacleMinDistance = NumUtil.getVal(configParams.getObstacleMinDistance(), 100);
            Integer obstacleMaxDistance = NumUtil.getVal(configParams.getObstacleMaxDistance(), 500);
            if (!NumUtil.isRangeEe(obstacleMinDistance, 100, 2000)) {
                ULog.d(TAG, "避障传感器测距最小距离：" + obstacleMinDistance + "; 其值应该在100~2000之间，当前默认设置为100");
                obstacleMinDistance = 100;
            }
            if (!NumUtil.isRangeEe(obstacleMaxDistance, 100, 2000)) {
                ULog.d(TAG, "避障传感器测距最大距离：" + obstacleMaxDistance + "; 其值应该在100~2000之间，当前默认设置为500");
                obstacleMaxDistance = 500;
            }
            if (NumUtil.gt(obstacleMinDistance, obstacleMaxDistance)) {
                ULog.d(TAG, "避障传感器测距最小距离：" + obstacleMinDistance + "大于避障传感器测距最大距离：" + obstacleMaxDistance + "; 所以设置为默认值");
                obstacleMinDistance = 100;
                obstacleMaxDistance = 500;
            }

            allConfigParams.put(StmTask.StmConfig.REG_OBSTACLE_MIN_DISTANCE, String.valueOf(obstacleMinDistance));
            allConfigParams.put(StmTask.StmConfig.REG_OBSTACLE_MAX_DISTANCE, String.valueOf(obstacleMaxDistance));
        }
        if (getRobotConfigParams().getStmRfidPower() != null && getRobotConfigParams().getStmRfidPower() >= 0) {
            allConfigParams.put(StmTask.StmConfig.REG_RFID_POWER_VALUE, String.valueOf(getRobotConfigParams().getStmRfidPower()));
        }
        if (getRobotConfigParams().getStmRfidMinRssi() != null && getRobotConfigParams().getStmRfidMinRssi() >= 0) {
            allConfigParams.put(StmTask.StmConfig.REG_STM_RFID_MIN_RSSI_VALUE, String.valueOf(getRobotConfigParams().getStmRfidMinRssi()));
        }
        //急停开关
        List<Sensor> emeButtons = mSensorManager.getConfigedSensorByType(SensorType.EMERGENCY_STOP_BUTTON);
        if (emeButtons != null && emeButtons.size() > 0) {
            EmergencyStopButtonInfo emergencyStopButtonInfo = (EmergencyStopButtonInfo) emeButtons.get(0);
            allConfigParams.put(StmTask.StmConfig.REG_EMERGENCY_STOP_BUTTON_ENABLE, String.valueOf(emergencyStopButtonInfo.isEnabled() ?
                    1 : 0));
        }

        //电机配置
        if (mBotInfoMgr.getRobotSubType() == RobotSubType.FB || mBotInfoMgr.getRobotSubType() == RobotSubType.MA) {
            if (mSensorManager.isHaveSensorAndEnabled(SensorType.SENSOR_TYPE_MOTOR)) {
                MotorInfo motorInfo = (MotorInfo) mSensorManager.findConfigedAndEnabledSensors(SensorType.SENSOR_TYPE_MOTOR).get(0);
                allConfigParams.put(StmTask.StmConfig.REG_MOTOR_SPECIFIED_CURRENT, String.valueOf(motorInfo.getSpecifiedCurrent()));
                allConfigParams.put(StmTask.StmConfig.REG_MOTOR_PEAK_CURRENT, String.valueOf(motorInfo.getPeakCurrent()));
                allConfigParams.put(StmTask.StmConfig.REG_MOTOR_PROTECT_TIME, String.valueOf(motorInfo.getMotorProtectTime()));
                allConfigParams.put(StmTask.StmConfig.REG_MOTOR_STALL_PROTECT_SPEED_PERCENT, String.valueOf(motorInfo.getStallProtectSpeedPercent()));

                String reductionRatioStr = "95";
                if ("0".equals(motorInfo.getReductionRatio().trim())) {
                    reductionRatioStr = "50";
                } else if ("1".equals(motorInfo.getReductionRatio().trim())) {
                    reductionRatioStr = "74";
                } else if ("2".equals(motorInfo.getReductionRatio().trim())) {
                    reductionRatioStr = "95";
                } else {
                    reductionRatioStr = motorInfo.getReductionRatio();
                }
                allConfigParams.put(StmTask.StmConfig.REG_MOTOR_REDUCTION_RATIO, reductionRatioStr);

            }
        }

        //默认上电控制
        if (mBotInfoMgr.getRobotMainType() == RobotMainType.CICADA) {
            //初版BY才会配置位不允许控制，同时会配置下位机舵机默认不上电
            boolean steerDefEnable = true;
            if (!mBotInfoMgr.getRobotConfigParams().getEnableControlSteerInCleanDevice() && mIsHaveNewCleanDevice) {
                steerDefEnable = false;
            }
            SteerController.getInstance().saveDefaultPowerEnable(steerDefEnable ? 1 : 0);
            allConfigParams.put(StmTask.StmConfig.REG_STEER_DEFAULT_ENABLE, String.valueOf(steerDefEnable ? 1 : 0));
        }

        //舵机配置
        if (mBotInfoMgr.isHaveSteer()) {
            if (mSensorManager.cacheInfo().H_GIMBAL_INFO != null
                    && NumberUtil.inArray(mSensorManager.cacheInfo().H_GIMBAL_INFO.getType(), false, "0")) {
                allConfigParams.put(StmTask.StmConfig.REG_CAN_STEER_P_VALUE, String.valueOf(mSensorManager.cacheInfo().H_GIMBAL_INFO.getpValue()));
                allConfigParams.put(StmTask.StmConfig.REG_CAN_STEER_I_VALUE, String.valueOf(mSensorManager.cacheInfo().H_GIMBAL_INFO.getiValue()));
                allConfigParams.put(StmTask.StmConfig.REG_CAN_STEER_D_VALUE, String.valueOf(mSensorManager.cacheInfo().H_GIMBAL_INFO.getdValue()));
                allConfigParams.put(StmTask.StmConfig.REG_CAN_STEER_V_VALUE, String.valueOf(mSensorManager.cacheInfo().H_GIMBAL_INFO.getvValue()));
            }
        }

        //网络摄像头配置
        if (SensorInfoProvider.of(getRobot().getId()).cacheInfo().WEBCAM_INFO != null) {
            int fillLightMaxOutput = SensorInfoProvider.of(getRobot().getId()).cacheInfo().WEBCAM_INFO.getFillLightMaxOutput();
            if (fillLightMaxOutput != -1) {
                allConfigParams.put(StmTask.StmConfig.REG_FILL_LIGHT_PWM_MAX_OUTPUT, String.valueOf(fillLightMaxOutput));
            }
            ULog.d(TAG, "FillLightController 补光灯最多亮度 配置文件值 " + fillLightMaxOutput);
            allConfigParams.put(StmTask.StmConfig.REG_FILL_LIGHT_PWM_MAX_OUTPUT, String.valueOf(1000));
            FillLightController.getInstance().init(mSensorManager.cacheInfo().WEBCAM_INFO.getNightVisionChangeThreshold(),
                    mSensorManager.cacheInfo().WEBCAM_INFO.getNightVisionFloatRange());
        }

        //计算差异的配置
        Map<Integer, String> needConfigParams = new HashMap<>();
        Iterator<Integer> paramsKeysIte = allConfigParams.keySet().iterator();
        while (paramsKeysIte.hasNext()) {
            Integer key = paramsKeysIte.next();
            String oldVal = configedParams.get(key);
            String newVal = allConfigParams.get(key);

            if (oldVal == null || !oldVal.equals(newVal)) {
                needConfigParams.put(key, newVal);
                ULog.d(TAG, "需配置：0x" + Integer.toHexString(key) + " " + newVal);
            }
        }

        if (needConfigParams.isEmpty()) {
            ULog.i(TAG, "无需配置下位机参数");
            RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_STM_CONFIG_FINISHED));

            return;
        }

        synchronized (RobotFragment.this) {
            if (mStmConfigDisposable != null && !mStmConfigDisposable.isDisposed()) {
                return;
            }

            mStmConfigParams.clear();
            mStmConfigParams.putAll(needConfigParams);
            mStmConfigDisposable = Observable.interval(1, TimeUnit.SECONDS)
                    .subscribeOn(Schedulers.io())
                    .doOnNext(t -> {
                        Set<Integer> keySet = mStmConfigParams.keySet();
                        Iterator<Integer> iterator = keySet.iterator();
                        if (iterator.hasNext()) {
                            Integer reg = iterator.next();
                            String value = mStmConfigParams.get(reg);
                            Integer valueInt = null;
                            if (reg != null && reg == StmTask.StmConfig.REG_MOTOR_REDUCTION_RATIO) {
                                try {
                                    valueInt = UByte.strToInteger(value);
                                    if (valueInt == null) {
                                        valueInt = Float.floatToIntBits(Float.parseFloat(value));
                                    }
                                } catch (NumberFormatException e) {
                                    valueInt = Float.floatToIntBits(Float.parseFloat(value));
                                }
                            } else {
                                valueInt = UByte.strToInteger(value);
                            }

                            ULog.d(TAG, "配置下位机参数，寄存器：0x" + Integer.toHexString(reg) + ", 值：" + value + " valueInt: " + valueInt);
                            stmExecute.executeTaskNonQueue(new StmTask().configStm(reg, valueInt));
                        }
                    })
                    .filter(t -> mStmConfigParams.isEmpty())
                    .take(1)
                    .doOnNext(t -> {
                        ULog.d(TAG, "参数配置完成，重启下位机");
                        Thread.sleep(1000);
                        RxBus.getInstance().post(new Stm32Event(Stm32Event.STM_REBOOT, Stm32RebootReason.CONFIG_PARAMS));
                        reset(0);
                        //等待10s，等待下位机初始化
                        Thread.sleep(10_000);
                        ULog.d(TAG, "重启下位机GPIO控制完成");
                    })
                    .subscribe(e -> {
                        saveStmConfigedParams(new Gson().toJson(allConfigParams));
                        RxBus.getInstance().post(new RobotEvent(RobotEvent.EVENT_STM_CONFIG_FINISHED));
                    });
        }

    }

    private Map<Integer, String> getStmConfigedParams() {
        String configedParamsStr = UPreferences.getString(BrainApplication.getInstance(), UConstants.KEY_STM_CONFIG_PARAMS, "");
        HashMap<Integer, String> configedParams = null;
        try {
            Type type = new TypeToken<Map<Integer, String>>() {
            }.getType();
            configedParams = new Gson().fromJson(configedParamsStr, type);
        } catch (JsonSyntaxException e) {
            e.printStackTrace();
        }

        if (configedParams == null) {
            configedParams = new HashMap<>();
        }

        return configedParams;
    }

    private String getStmConfigedParamsStr() {
        String configedParamsStr = UPreferences.getString(BrainApplication.getInstance(), UConstants.KEY_STM_CONFIG_PARAMS, "");

        return configedParamsStr;
    }

    private void saveStmConfigedParams(String content) {
        UPreferences.putString(BrainApplication.getInstance(), UConstants.KEY_STM_CONFIG_PARAMS, content);
    }


    /*
        private void continueExecuteCommand() {
            ULog.d(TAG, "continueExecuteCommand:  === " + robotDirection + "  command   " + previousCommand);
            if (UString.isEmpty(previousCommand)) {
                return;
            }
            switch (previousCommand) {
                case MqttCommand.ROBOT_MOVE_FRONT_ACTION:
                case MqttCommand.ROBOT_MOVE_BACK_ACTION:
                    if (MqttCommand.ROBOT_MOVE_FRONT_ACTION.equals(previousCommand)) {
                        setRobotDirection(StmTask.MOVE_FRONT);
                    } else {
                        setRobotDirection(StmTask.MOVE_END);
                    }
                    previousCommand = "";
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                    setInCharger(false,"?");
                    UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
                    if (getRobot() != null && getRobot().getChargeStatus() == ChargerStatus.CHARGE_END) {
                        notifyLeaveCharger();
                    }
                    break;
                case inspectionCommand:
                    previousCommand = "";
                    startInspection();
                    break;
                default:
                    break;
            }
        }
     */
    private boolean parseMapResult(MapInfo mapInfo) {
        try {
            //            if (mapInfo.getRfidNodes() != null && mapInfo.getRfidNodes().size() != 0) {
            //                for (RfidNode n : mapInfo.getRfidNodes()) {
            //                    switch (n.getId()) {
            //                        case 3197:
            //                            n.setDistance(0f);
            //                            n.setDistanceReverse(0.0859f);
            //                            break;
            //                        case 3198:
            //                            n.setDistance(1.43123f);
            //                            n.setDistanceReverse(1.47126f);
            //                            break;
            //                        case 3199:
            //                            n.setDistance(3.01169f);
            //                            n.setDistanceReverse(3.1276f);
            //                            break;
            //                        case 3200:
            //                            n.setDistance(4.04187f);
            //                            n.setDistanceReverse(4.0855f);
            //                            break;
            //                    }
            //                }
            //            }
            boolean isupdate = true; //是否需要更新
            setRfidReadType(getRobotConfigParams().getRfidType());
            ULog.d(TAG, "stm_rfid 读标签方式 rfidReceiveTypeStm " + rfidReadType);
            if (rfidReadType == 2 || rfidReadType == 3) {
                String rfidNodeStr = StorageCenter.getRobotStorage().getString(StorageCenter.KEY_RFID_NODE, "");
                if (!TextUtils.isEmpty(rfidNodeStr)) {
                    List<RfidNode> cacheRfidNodes = gson.fromJson(rfidNodeStr, new TypeToken<ArrayList<RfidNode>>() {
                    }.getType());
                    if (cacheRfidNodes.size() == mapInfo.getAllRfidNodes().size()) {
                        boolean same = true;
                        for (RfidNode server : mapInfo.getRfidNodes()) {
                            same = cacheRfidNodes.stream().anyMatch(t -> server.getId() != null && server.getId()
                                    .equals(t.getId()) && server.getDistance() != null && server.getDistance()
                                    .equals(t.getDistance()) && server.getRfidTag() != null && server.getRfidTag().equals(t.getRfidTag()));
                            if (!same) { //出现一个不匹配则需要更新
                                ULog.d(TAG, "getMap 更新rfid里程 id = " + server.getId() + " distance = " + server.getDistance());
                                break;
                            }
                        }
                        isupdate = !same;
                    }
                }
                if (!isupdate && mapInfo.getRfidNodes().size() == 0) {
                    isupdate = true;
                }
                ULog.d(TAG, "getMap stm_rfid 更新rfid里程 == " + isupdate);
                mNeedUpdateStmMap = isupdate;
                if (mNeedUpdateStmMap) {
                    mSequenceInitializer.registerEventInitRet("CONFIG_STM_MAP",
                            RobotEvent.class,
                            RobotEvent.ACTION_UPDATE_STM_MAP_FINISHED);
                }
            }
            autoMoveManager.setNodes(mapInfo.getRfidNodes());
            autoMoveManager.setTaskNodes(mapInfo.getTaskNodes());
            inspectManager.setTaskParams(mapInfo.getTaskNodes());
            for (TaskNode taskNode : mapInfo.getTaskNodes()) {
                if (taskNode.getMold() != null &&
                        (taskNode.getMold() == TaskNodeMold.RGB_TO_DETECT_SERVER
                                || taskNode.getMold() == TaskNodeMold.IR_TO_DETECT_SERVER
                                || taskNode.getMold() == TaskNodeMold.IR_AND_RGB_TO_DETECT_SERVER
                        )) {
                    TakeImgInspectManager.getInstance(this).loadAndscreenArucoTaskAndSort(inspectManager.getTasks());
                    isNeedCheckAruco = true;
                    break;
                }
            }
            for (TaskNode taskNode : mapInfo.getTaskNodes()) {
                if (taskNode.getMold() != null && taskNode.getMold() == TaskNodeMold.RGB_PHOTO_NO_STOP) {
                    MainApp.isCokeOvenInspect = true;
                    CokeOvenInspectManager.getInstance(RobotFragment.this);//初始化焦炉场景
                    break;
                }
            }
            if (mapInfo.getTaskTypes() != null)
                inspectManager.setTaskTypes(mapInfo.getTaskTypes());


            if (CollectionUtils.isEmpty(mapInfo.getAllRfidNodes())) {
                sendNotMapInfo();
            }

            ULog.d(TAG,
                    "getmap 获取地图完成 rfidNodesSize=" + mapInfo.getRfidNodes().size() + " getTaskNodes " + mapInfo.getTaskNodes()
                            .size() + " getTaskObjs " + mapInfo.getTaskObjs().size() + " getTaskTypes " + mapInfo.getTaskTypes().size());

            return true;
        } catch (Exception e) {
            e.printStackTrace();
            MapManager.getInstance().getMap(getRobot().getId());
            return false;
        }
    }

    boolean isDeleteRfidMap = false;

    public void delRfidMap() {
        if (rfidReadType == 2 || rfidReadType == 3) {
            isDeleteRfidMap = true;
            cleanStmRfids = false;
            stmExecute.executeTask(new StmTask().rfidClean());
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_CLEAN_STM_RFID, 3000);
        }
    }

    /**
     * 初始化除尘相关参数
     */
    private void initCleanDeviceParams() {
        mCleanDeviceAreaList.clear();
        List<RfidNode> rfidNodes = MapManager.getInstance().getRfidNodeList();
        //计算驿站充电桩边界
        List<RfidNode> tempChargerNodes = MapManager.getInstance().findRfidNodesByType(NodeType.TEMPORARY_CHARGE);
        if (!CollectionUtils.isEmpty(tempChargerNodes)) {
            for (RfidNode tmpNode : tempChargerNodes) {
                //有驿站充电桩
                int tmpIndex = rfidNodes.indexOf(tmpNode);
                if (tmpIndex <= 0 || tmpIndex >= rfidNodes.size() - 1) {
                    //驿站充电桩不能是第一个或最后一个节点，此处忽略计算
                    continue;
                }

                RfidNode prevNode = rfidNodes.get(tmpIndex - 1);
                RfidNode nextNode = rfidNodes.get(tmpIndex + 1);

                float minDis = Math.min(prevNode.getDistance(), tmpNode.getDistance() - 2);
                float maxDis = Math.max(nextNode.getDistance(), tmpNode.getDistance() + 2);

                DistanceArea area = new DistanceArea(minDis, maxDis);
                mCleanDeviceAreaList.add(area);
                ULog.d(TAG, "X驿站充电桩节点里程=" + tmpNode.getDistance() + "，安全屋范围：" + area);
            }
        }

        //计算首端充电桩边界
        List<RfidNode> headChargerNodes = MapManager.getInstance().findRfidNodesByType(NodeType.HEAD_CHARGE);
        if (!CollectionUtils.isEmpty(headChargerNodes)) {
            DistanceArea area = new DistanceArea(Float.NEGATIVE_INFINITY, -0.2f);
            mCleanDeviceAreaList.add(area);
            ULog.d(TAG, "X充电桩节点里程=" + headChargerNodes.get(0).getDistance() + "，安全屋范围：" + area);
        }

    }

    /**
     * 是否在除尘设备区间内
     *
     * @param distance 要判断的里程值
     *
     * @return
     */
    public boolean isInCleanDeviceArea(float distance) {
        boolean ret = false;

        if (mIsHaveNewCleanDevice) {
//            for (DistanceArea area : mCleanDeviceAreaList) {
//                if (distance >= area.getMinDistance() && distance <= area.getMaxDistance()) {
//                    ret = true;
//                    break;
//                }
//            }
            ret = RestrictDistanceWatcher.getInstance().isInCleanDeviceArea(distance);

        }

        return ret;
    }

    public void checkUpgrade(int tag) {
        upgradeCheck(false, tag, 1);
    }

    private long sendNotMapInfoTime;

    public void sendNotMapInfo() {
        ULog.d(TAG, "sendNotMapInfo: ");
        if ((System.currentTimeMillis() - sendNotMapInfoTime) < 600_000) {
            return;
        }
        sendNotMapInfoTime = System.currentTimeMillis();
        mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_initialized_server_no_map_node));
        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_INITIALIZED_SERVER_NO_MAP_NODE);
    }

    private void updateChargeStatus(int status) {
        if (getRobot() != null) {
            getRobot().setChargeStatus(status);
            //            isUpdateRobot = true;
            //            robotStatusUpload();
        }
    }


    /*-----------------------------MQTT callBack----------------------------------*/
    @Override
    public void onConnectSuccess() {
        //        MainApp.from(mActivity).pushLog("mqtt onConnectSuccess: ");
        RxBus.getInstance().post(new RobotHeartEvent(RobotEventConstants.EVENT_SEND_CONNECT_TEST));
    }

    @Override
    public void onConnectFail() {
        ULog.d(TAG, "robot mqtt onConnectFail: ");
        //        MainApp.from(mActivity).pushLog("mqtt onConnectFail: ");
        //        mMqttManager.close();
        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_MQTT, 2000);
    }

    @Override
    public void onConnectLost() {
        ULog.d(TAG, "robot mqtt onConnectLost: ");
        if (MODE == MODE_UN_KNOW) {
            stmExecute.executeTaskNonQueue(new StmTask().stopMove("robot mqtt onConnectLost 53"));
        }
        //        MainApp.from(mActivity).pushLog("mqtt onConnectLost: ");
        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_MQTT, 1000);
    }

    @Override
    public void onSubscribeSuccess() {
        ULog.d(TAG, "robot mqtt onSubscribeSuccess: ");
        //        MainApp.from(mActivity).pushLog("mqtt onSubscribeSuccess: ");
    }

    @Override
    public void onSubscribeFail() {
        ULog.d(TAG, "robot mqtt onSubscribeFail: ");
        //        MainApp.from(mActivity).pushLog("mqtt onSubscribeFail: ");
        //        mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_MQTT, 1000);
    }


    /**
     * 自定义mqtt返回成功和失败
     *
     * @param command 接受到的command 转变目标和来源 然后发送
     * @param action  要发送的action 标识
     */
    private void sendMqttResult(MqttCommand command, String action, String value) {
        if (MqttManager.getInstance().isConnected()) {
            if (getRobot().getId().equals(command.getSource())) {
                ULog.d(TAG, "sendMqttResult: setTarget error");
                return;
            }
            MqttCommand clone = command.cloneCreateIdAndTimeStamp();
            clone.setTarget(command.getSource());
            clone.setSource(getRobot().getId());
            clone.setType(command.getType());
            clone.setAction(action);
            clone.setValue(value);
            mMqttManager.publishMessage(clone);
        }
    }

    public void sendMqttAll(String source, String type, String action, Object value) {
        if (CollUtil.isBlank(accounts)) {
            return;
        }
        for (String account : accounts) {
            sendMqtt(source, account, type, action, value);
        }
    }

    public void sendMqtt(String source, String target, String type, String action, Object value) {
        if (StrUtil.hasBlank(source, target) || !MqttManager.getInstance().isConnected()) {
            return;
        }
        MqttCommand command = new MqttCommand();
        command.setSource(source);
        command.setTarget(target);
        command.setType(type);
        command.setAction(action);
        command.setValue(value);
        mMqttManager.publishMessage(command);
    }

    public void sendMqttResult2(MqttCommand command, String action, Object value) {
        if (!command.getSource().equals(getRobot().getId())) {//防止自己给自己回消息死循环
            if (MqttManager.getInstance().isConnected()) {
                if (getRobot().getId().equals(command.getSource())) {
                    ULog.d(TAG, "sendMqttResult2: setTarget error");
                    return;
                }
                MqttCommand clone = command.cloneCreateIdAndTimeStamp();
                clone.setTarget(command.getSource());
                clone.setSource(getRobot().getId());
                clone.setType(command.getType());
                clone.setAction(action);
                clone.setValue(value);
                mMqttManager.publishMessage(clone);
            }
        }
    }


    // TODO: 2019/4/27 MQTT CallBack
    @RequiresApi(api = Build.VERSION_CODES.FROYO)
    @Override
    public void onMessageReceived(MqttCommand command) {
        if (command != null && getRobot() != null && !TextUtils.isEmpty(command.getTarget()) && command.getTarget()
                .equals(getRobot().getId())) {
            getExecutorService().execute(new MqttMsgHandle(command));
        }
    }

    public CommonResult inspectionToLocation(float targetLocation) {
        ULog.d(TAG, "inspection to location :" + targetLocation);

        startInspectTime = System.currentTimeMillis();
        UPreferences.putLong(mActivity, UConstants.PREFERENCES_START_INSPECT_TIME_KEY, startInspectTime);
        CommonResult result = null;
        stmExecute.executeTaskNonQueue(new StmTask().stopMove("inspectionToLocation 54"));

        InspectManager.targetInspectLocation = targetLocation;

        if (targetLocation > mDistance) {
            targetInspectDirection = MOVE_END;
            result = startInspection(MOVE_END,"inspectionToLocation2");
        } else {
            targetInspectDirection = MOVE_FRONT;
            result = startInspection(MOVE_FRONT,"inspectionToLocation1");
        }

        return result;
    }

    /**
     * 移动到目标位置的目标里程信息
     */
    public static float tgtLocation = UConstants.UNKONW;
    public static float tgtDirection = UConstants.UNKONW;
    /**
     *
     * 参考了 {@link #startInspection 定方向巡检方法}
     * @param tgtTaskNode 如需要去指定任务节点的话 这个参数就不应该为空 tgtLocation此时可为null
     * @param tgtLocation 如需要去指定里程而不是任务节点的话 这个参数不应该为空 tgtTaskNode此时可为null
     * @return OK 代表可以去目标位置  其他则不能
     */
    public String startToTarget(Integer tgtTaskNode, Float tgtLocation, String tag) {
        String nodeName = null;
        if (tgtTaskNode != null) {
            TaskNode taskNodeById = MapManager.getInstance().getTaskNodeById(tgtTaskNode);
            if(taskNodeById != null){
                nodeName = taskNodeById.getName();
                if(tgtLocation == null){
                    tgtLocation =  taskNodeById.getStartLocation();
                }
            }
        }

        if(tgtLocation == null){
            return  "检查参数";
        }
        ULog.d(TAG, "startToTarget: cDis:"+mDistance+"tTaskNode:"+nodeName+ " tgtLocation:"+tgtLocation + " tag:" + tag);

        if (MODE != MODE_UN_KNOW) {
            return "检查机器人模式... 当前:"+MODE;
        }



        boolean canMove = false;
        if (mDistance < 1.0f
                && (RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_FB || RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_MA)
                && NumberUtil.notNullAndEqual(CicadaRoomController.getInstance().haveRoom(), true)) {

            if (CicadaRoomController.getInstance().getControlSource() == RoomControlSource.ROBOT) {

                boolean doorOpened = CicadaRoomController.getInstance().getCurDorState() == CicadaRoomDoorState.OPEN;
                boolean waitingClose = RobotStatus.getIsWaitRoomDoorClose();
                if (!doorOpened || waitingClose) {
                    ULog.d(TAG, "cicada room 状态：" + CicadaRoomController.getInstance().getCurDorState());
                    setCmdAfterRoomOp(MqttCommands.createMoveToTargetCmd("self"
                            , getRobot().getId()
                            ,UGson.getGson().toJson(new MoveToTarget(tgtTaskNode,tgtLocation))));
                    RobotStatus.setIsWaitRoomDoorOpen(true);
                    CicadaRoomController.getInstance().controlDoor(CicadaRoomDoorState.OPEN);
                    return "Room正在开门,指令将在开门完成后执行";
                } else {
                    canMove = true;
                }
            } else {
                return "当Room处于手动控制状态时，且机器人处于Room范围内时，机器人不可移动";
            }
        } else {
            canMove = true;
        }
        if(canMove){
            if (getRobot() != null && getRobot().getChargeStatus() == ChargerStatus.CHARGE_END) {
                notifyLeaveCharger();
            }
            batteryAutoOff = false;
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_BATTERY_AUTO_OFF_KEY, false);
            if (mHandler.hasMessages(Msg.WHAT_LEAVE_CHARGER)) {
                mHandler.removeMessages(Msg.WHAT_LEAVE_CHARGER);
            }
            if (mHandler.hasMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE)) {
                mHandler.removeMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE);
            }

            mIsFirstDustingAfterBoot = false;
            mHasTriedGoChargerAfterMotorStall = false;
            //移除堵转后30分钟重试的消息
            mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);
            //移除堵转反方向移动的消息
            if(mHandler.hasMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD)){
                mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
            }
            //复位烟雾异常前的模式存储
            mRobotModeBeforeSmokeException = MODE_UN_KNOW;
            prepareLeaveCharger();
            removeRetryInspectMsg();
            int tempDir = StmTask.MOVE_FRONT;
            if(mDistance < tgtLocation){
                tempDir = StmTask.MOVE_END;
            }
            RobotFragment.tgtLocation = tgtLocation;
            RobotFragment.tgtDirection = tempDir;
            setMode(MODE_MOVE_TO_TARGET,"去目标位置模式-"+tag);
            setRobotDirection(tempDir,"移动到指定目标位置");
            setSpeed(UConstants.DEFAULT_SPEED, "去目标位置使用机器人默认速度");
            stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
            return "OK";
        }
        return "未知问题不能移动";
    }


    class MqttMsgHandle implements Runnable {
        MqttCommand command;

        public MqttMsgHandle(MqttCommand cmd) {
            command = cmd;
        }

        @Override
        public void run() {
            try {
                Thread.currentThread().setName("MqttMsgHandle");
                if (command == null) {
                    ULog.d(TAG, "mqtt command invalid");
                }
                userControlHandler(command);
                if (getRobot() == null) {
                    return;
                }

                if(MqttCommand.TTS_TYPE.equals(command.getType())){
                    String text = (String) command.getValue();
                    ULog.d(TAG,"TtsManager 接收到mqtt text:"+text);
                    if(TextUtils.isEmpty(text)){
                        mMqttManager.sendMqttResultFail(command,"要朗读的内容为空!");
                        ULog.e(TAG,"TtsManager 要朗读的内容为空!");
                        return;
                    }
                    int result = TtsManager.getInstance().submit(text);
                    if(result == -1){
                        mMqttManager.sendMqttResultFail(command,"tts未初始化!");
                    }else if(result == -2){
                        mMqttManager.sendMqttResultFail(command,"tts语音包未加载!");
                    }else if(result == -3){
                        mMqttManager.sendMqttResultFail(command,"tts正在朗读中请稍后再试!");
                    }else if(result == 1){
                        mMqttManager.sendMqttResultSuccess(command);
                    }
                    return;
                }

                if (!mIsRobotInitialized && !MqttCommand.ROBOT_REBOOT_INDEX_TYPE.equals(command.getType())) {
                    ULog.d(TAG, "机器人尚未初始化完成，无法处理MQTT指令。");
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_INITIALIZE_NOT_FINISH_YET_WAIT_BEFORE_CONTROL);
                    mMqttManager.broadcastShowInfo("机器人尚未初始化完成，请稍后再操作！");
                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_7));
                    return;
                }

                if (!getRobot().getActive() && !MqttCommand.ROBOT_UPDATE_ROBOT_INFO_INDEX.equals(command.getType())) {
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_NOT_ACTIVE);
                    mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_prohibit));
                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_8));
                    return;
                }
                if (MqttCommand.ROBOT_SHOW_UPGRADE_INFO_INDEX.equals(command.getType())) {
                    if (MqttCommand.ROBOT_SHOW_UPGRADE_OPEN_ACTION.equals(command.getAction())) {
                        if (!upgradeInfos.contains(command.getSource()))
                            upgradeInfos.add(command.getSource());
                        mMqttManager.sendMqttResultSuccess(command);
                    } else if (MqttCommand.ROBOT_SHOW_UPGRADE_CLOSE_ACTION.equals(command.getAction())) {
                        upgradeInfos.remove(command.getSource());
                        mMqttManager.sendMqttResultSuccess(command);
                    }
                }

                if(MqttCommand.ROBOT_PULL_RECORDER_TEST_TYPE.equals(command.getType())){
                    if(MqttCommand.ROBOT_PULL_RECORDER_TEST_START_ACTION.equals(command.getAction())){
                        //开启拉流测试
                        int i = Recorder.getInstance().startOrStopRecorder(Recorder.START_RECORDER, new Recorder.RecordingStorageCheckListener() {
                            @Override
                            public void onOutOfStorage() {
                                mMqttManager.sendMqttResultFail(command,"fail recording out of storage!");
                            }

                            @Override
                            public void onLongTime() {
                                mMqttManager.sendMqttResultFail(command,"fail recorder long time auto close!");
                            }
                        });
                        if (i == 1) {
                            mMqttManager.sendMqttResultSuccess(command);
                        } else if(i == -1 ){
                            mMqttManager.sendMqttResultFail(command,"fail last not close!");
                        }else if( i == -2){
                            mMqttManager.sendMqttResultFail(command,"fail recording or uploading or closing please wait!");
                        }else if(i == -3){
                            mMqttManager.sendMqttResultFail(command,"fail storage <= 20%!");
                        }

                    }else if(MqttCommand.ROBOT_PULL_RECORDER_TEST_STOP_ACTION.equals(command.getAction())){
                        //关闭拉流测试
                        int i = Recorder.getInstance().startOrStopRecorder(Recorder.STOP_RECORDER, null);
                        if (i == 1) {
                            mMqttManager.sendMqttResultSuccess(command);
                        } else if(i == -1){
                            mMqttManager.sendMqttResultFail(command,"fail last not open!");
                        }else if(i == -2){
                            mMqttManager.sendMqttResultFail(command,"fail closing please wait!");
                        }else{
                            mMqttManager.sendMqttResultFail(command);
                        }
                    }else if(MqttCommand.ROBOT_PULL_RECORDER_TEST_UPLOAD_VIDEO_ACTION.equals(command.getAction())){
                        //上传保存的视频
                        int i = Recorder.getInstance().upLoadVideo(getRobot().getId(), MainApp.uploadFileType, new Recorder.OnUploadCallBack() {
                            @Override
                            public void msgCallBack(String msg) {
                                mMqttManager.sendMqttResultSuccess(command,msg);
                            }

                            @Override
                            public void uploadFinish(String msg) {
                                mMqttManager.sendMqttResultSuccess(command,msg);
                            }
                        });
                        Log.i(TAG, "upLoadVideo: i="+i);
                        if(i == -1){
                            //recording
                            mMqttManager.sendMqttResultFail(command,"fail recording!");
                        }else if(i == -2){
                            //uploading
                            mMqttManager.sendMqttResultFail(command,"fail uploading!");
                        }else if(i == -3){
                            mMqttManager.sendMqttResultFail(command,"fail files is empty!");
                        }else if(i == 1){
                            mMqttManager.sendMqttResultSuccess(command);
                        }

                    }
                    return;
                }

                if (isStmUpgrade) {
                    //移动指令和巡检指令再提示
                    if (MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE.equals(command.getType()) ||
                            ROBOT_INSPECTION_INDEX_TYPE.equals(command.getType()) ||
                            MqttCommand.MOVE_TO_TARGET_TYPE.equals(command.getType())) {
                        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_STM32_UPGRADING_CANNOT_PROCESS_COMMANDS);
                        mMqttManager.broadcastShowInfo("下位机正在升级，无法处理指令");
                    }
                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_1));
                    return;
                }

                if (isUpgrading && !MqttCommand.ROBOT_REBOOT_INDEX_TYPE.equals(command.getType())) {
                    //移动指令和巡检指令再提示
                    if (MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE.equals(command.getType()) ||
                            ROBOT_INSPECTION_INDEX_TYPE.equals(command.getType())) {
                        //                        sendMobileInfo(mRes.getString(fun.unifun.library.android.R.string.robot_upgrading));
                        mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_upgrading));
                        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_UPGRADING_CANNOT_PROCESS_COMMANDS);
                        RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_2));
                    }
                    return;
                }
/*                Map<String, Object> mqttMap = new HashMap<>();
                mqttMap.put("mqttSource", command.getSource());
                mqttMap.put("mqttType", command.getType());
                mqttMap.put("mqttAction", command.getAction());
                mqttMap.put("mqttValue", command.getValue());
                MainApp.from(mActivity).pushLogMap(mqttMap);*/
                ULog.d(TAG,
                        "mqtt onMessageReceived:  == getSource = " + command.getSource() + " type " + command.getType() + " " +
                                "action " + command.getAction() + " value " + command.getValue() + " == isSleep = " + isSleep + " isSoftEmergencyStop " + isSoftEmergencyStop);

                if (command.getSource().contains("self")) {
                    ULog.d(TAG, "self_control " + command.getSource() + " type " + command.getType() + " action " + command.getAction() + " value " + command.getValue());
                }
                //正在休眠
                if (isSleep) {
                    //非自身指令，且非白名单指令，回复不可控制
                    if (!command.getSource().contains("self") && !mStandbyWhiteListCmdTypes.contains(command.getType())) {
                        mMqttManager.sendResultFail(command, MqttMsgCode.ERROR_ROBOT_STANDBY, mRes.getString(R.string.robot_standby_retry_operation_later));
                        RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_3));
                        return;
                    }
                }
                //正在休眠
                if (isSoftEmergencyStop) {
                    //非自身指令，且非白名单指令，回复不可控制
                    if (!mStandbyWhiteListCmdTypes.contains(command.getType())) {
                        mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_SOFT_EMERGENCY_STOP, mRes.getString(R.string.robot_soft_emergency_stop_retry_operation_later));
                        RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_4));
                        return;
                    }
                }
                if (MainApp.isEntryPowerSaveModeDelaying()){
                    //非自身指令，且非白名单指令，回复不可控制
                    if (!mStandbyWhiteListCmdTypes.contains(command.getType())) {
                        mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_ENTRY_POWER_SAVE_MODE_DELAYING, mRes.getString(R.string.robot_entry_power_save_mode_delaying));
                        RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_5));
                        return;
                    }
                }

                //todo 2021年7月28日 目前现场仍有部分帕沃斯的充电板，机器人ID以RK_1开头，新的中惠的充电板的机器人ID以RK_8或开头。帕沃斯的充电板仍然需要在离开充电桩时关闭充电
                //todo 若确保全部机器已更换中惠充电板，可以移除这一块代码
                if (getRobot().getId().startsWith("RK_1")) {
                    if (getRobot().getCharging() && (MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE.equals(command.getType())
                            || ROBOT_INSPECTION_INDEX_TYPE.equals(command.getType())) && mRetryLeaveChargerCount <= 4) {
                        if (MqttCommand.ROBOT_STOP_ACTION.equals(command.getAction())) {
                            mIsWaitToLeaveCharger = false;
                            mCommandBeforeLeaveCharger = null;
                            mRetryLeaveChargerCount = 0;
                        } else {
                            ULog.d(TAG, "机器人正在充电，准备延迟离开充电桩");
                            mIsWaitToLeaveCharger = true;
                            mCommandBeforeLeaveCharger = command;
                            mRetryLeaveChargerCount = 0;

                            if (mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
                                mHandler.removeMessages(Msg.WHAT_CHECK_BATTERY_STATUS);
                            }
                            if (mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
                                mHandler.removeMessages(Msg.WHAT_START_CHARGING);
                            }
                            if (mHandler.hasMessages(Msg.WHAT_START_DUSTING)) {
                                mHandler.removeMessages(Msg.WHAT_START_DUSTING);
                            }
                            if (currentChargerControlStatus == Msg.WHAT_OPEN_HEATER) {
                                mHandler.sendEmptyMessage(Msg.WHAT_CLOSE_HEATER);
                            }
                            if (currentChargerControlStatusCool == Msg.WHAT_OPEN_COOLER) {
                                mHandler.sendEmptyMessage(Msg.WHAT_CLOSE_COOLER);
                            }
                            if (mHandler.hasMessages(Msg.WHAT_UPGRADE_STM_CHECK)) {
                                mHandler.removeMessages(Msg.WHAT_UPGRADE_STM_CHECK);
                            }
                            if (mHandler.hasMessages(Msg.WHAT_START_SCHEDULED_INSPECTION)) {
                                mHandler.removeMessages(Msg.WHAT_START_SCHEDULED_INSPECTION);
                            }
                            mHandler.sendEmptyMessage(Msg.WHAT_END_CHARGING);
                            mHandler.sendEmptyMessage(Msg.WHAT_END_DUSTING);
                            mMqttManager.broadcastShowInfo("机器人正在关闭充电，请稍后");
                            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_CLOSING_CHARGING_NOW_PLEASE_WAIT);
                            return;
                        }
                    }

                    //如果已经在等待离开充电桩，接收到新的移动指令时，更新指令
                    if (mIsWaitToLeaveCharger && (MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE.equals(command.getType())
                            || ROBOT_INSPECTION_INDEX_TYPE.equals(command.getType()))) {
                        if (MqttCommand.ROBOT_STOP_ACTION.equals(command.getAction())) {
                            mIsWaitToLeaveCharger = false;
                            mCommandBeforeLeaveCharger = null;
                            mRetryLeaveChargerCount = 0;
                        } else {
                            ULog.d(TAG, "机器人准备延迟离开充电桩");
                            mCommandBeforeLeaveCharger = command;
                            mMqttManager.broadcastShowInfo("机器人正在等待离开充电桩，请稍后");
                            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_WAITING_TO_LEAVE_CHARGER_PLEASE_WAIT);
                            return;
                        }
                    }

                    if (mCommandBeforeLeaveCharger != null
                            && mCommandBeforeLeaveCharger.getType().equals(command.getType())
                            && mCommandBeforeLeaveCharger.getAction().equals(command.getAction())) {
                        mCommandBeforeLeaveCharger = null;
                        mRetryLeaveChargerCount = 0;
                        ULog.d(TAG, "开始处理延迟的行动指令，重置计数");
                    }
                }

                if (MODE == MODE_DEVICE_CLEAN && MqttCommands.isPossibleMoveCmd(command)) {
                    mMqttManager.broadcastShowInfo(getString(R.string.robot_clean_now_please_op_later));
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_CLEAN_NOW_PLEASE_OP_LATER);
                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_9));
                    return;
                }

                switch (command.getType()) {
                    case MqttCommand.RECLAIMER_TYPE:
                        ReclaimerInspection.getInstance(RobotFragment.this).mqttProcess(command);
                        break;
                    case ROBOT_AUTO_BUILD_MAP_TYPE://接收到手机端自动建图的相关 指令
                        //移除堵转后30分钟重试的消息
                        mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);
                        //移除堵转反方向移动的消息
                        if(mHandler.hasMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD)){
                            mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                        }
                        mIsFirstDustingAfterBoot = false;

                        switch (command.getAction()) {
                            //机器人检查正在自动建图人员id
                            case ROBOT_CHECK_AUTO_BUILD_MAP_ACCOUNT_ACTION:
                                mMqttManager.sendMqttResultSuccess(command,
                                        AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount());
                                break;

                            //手机端通知机器人更新机器人本地节点数据到云端服务器 之后再由机器人通知手机端去云端获取节点信息
                            case ROBOT_AUTO_BUILD_MAP_SYNC_DATA_ACTION:
                                //查询本地节点信息
                                AutoBuildRfidMapManager.getInstance().uploadNodes();
                                sendMqttResult2(command, command.getAction(), "机器人同步数据至云端成功!");
                                break;

                            //接收到暂停自动建图
                            case ROBOT_STOP_AUTO_BUILD_MAP_ACTION:
                                AutoBuildRfidMapManager.getInstance()
                                        .setBuildMapStatus(AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_STOPPED);
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("接收到暂停自动建图 55"));
                                mMqttManager.sendMqttResultSuccess(command);
                                break;

                            //接收到继续自动建图
                            case ROBOT_CONTINUE_AUTO_BUILD_MAP_ACTION: {
//                                if (rfidReadType == 2 || rfidReadType == 3) {
//                                    String configedMapStr = StorageCenter.getRobotStorage().getString(StorageCenter.KEY_RFID_NODE, "");
//                                    List<RfidNode> configedNodes = null;
//                                    try {
//                                        configedNodes = gson.fromJson(configedMapStr, new TypeToken<ArrayList<RfidNode>>() {
//                                        }.getType());
//                                    } catch (JsonSyntaxException e) {
//                                        ULog.e(TAG, "error parse configed stm map str", e);
//                                    }
//                                    if (!CollectionUtils.isEmpty(configedNodes)) {
//                                        mMqttManager.sendMqttResultFail(command);
//                                        mMqttManager.sendMessage(command.getSource(),
//                                                MqttCommand.ROBOT_SHOW_INFO_INDEX,
//                                                "",
//                                                mRes.getString(fun.unifun.library.android.R.string.start_auto_build_map_delete_map_info));
//                                        mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
//                                                MqttMsgCode.MSG_OLD_MAP_MUST_BE_DELETED_BEFORE_CREATE_NEW_ONE, null);
//
//                                        break;
//                                    }
//                                }
                                if (MODE != MODE_AUTO_BUILD_MAP) {
                                    ULog.d("auto_build_map fail mode " + MODE);
                                    mMqttManager.sendMqttResultFail(command, mRes.getString(fun.unifun.library.android.R.string.start_build_map_mode_error));
                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                            MqttMsgCode.MSG_AUTO_BUILD_MAP_MODE_ERROR, null);
                                    break;
                                }
                                autoMoveManager.continueBuildMap();
                                mMqttManager.sendMqttResultSuccess(command);

                            }
                            break;
                            case MqttCommand.ROBOT_SQUEEZE_OUT_BUILD_MAP_ACCOUNT_ACTION:
                                mIsWaitToQuitAutoBuildMapMode = false;
                                String currentBuildMapAccount_sq = AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount();
                                ULog.d(TAG, "SQUEEZE_OUT_BUILD_MAP_ACCOUNT_ACTION user_control 挤退建图 当前建图账户：" + currentBuildMapAccount_sq + " 新账户：" + command.getSource());

                                //先修改下本地状态 防止robot.UpdateByIdFrequent接口更新再改回来 (先修改 NowCreateMapAccount 再setMode setMode 会 robotStatusUpload
                                mIsWaitToEnterAutoBuildMapMode = true;
                                long receivedMsgTime_sq = System.currentTimeMillis();
                                RxBus.getInstance().toObservable(RobotEvent.class)
                                        .filter(event -> event.getAction() == RobotEvent.EVENT_ENTER_AUTO_BUILD_MAP_MODE_SUCCESS)
                                        .take(1)
                                        .subscribe(t -> {
                                            if (System.currentTimeMillis() - receivedMsgTime_sq < 5000) {
                                                mMqttManager.sendMqttResultSuccess(command);
                                            }
                                        });


                                getRobot().setNowCreateMapAccount(command.getSource());
                                getRobot().setBuildMapAccount(command.getSource());
                                setMode(MODE_AUTO_BUILD_MAP, "自动建图模式-挤退建图mqtt");

                                if (AutoBuildRfidMapManager.getInstance()
                                        .getBuildMapStatus() == AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_STOPPED) {
                                    AutoBuildRfidMapManager.getInstance()
                                            .setBuildMapStatus(AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_ENTERED);
                                }
//                                AutoBuildRfidMapManager.getInstance().loadSavedRecordNodes();
                                AutoBuildRfidMapManager.getInstance().setCurrentAutoBuildMapAccount(command.getSource());
                                if (!TextUtils.isEmpty(currentBuildMapAccount_sq)) {
                                    mMqttManager.sendMessage(currentBuildMapAccount_sq, MqttCommand.ROBOT_AUTO_BUILD_MAP_TYPE, MqttCommand.ROBOT_SQUEEZE_OUT_BUILD_MAP_ACCOUNT_ACTION, currentBuildMapAccount_sq);
                                }
                                break;

                            //接收到进入自动建图模式消息
                            case ROBOT_ENTER_AUTO_BUILD_MAP_ACTION:
                                mIsWaitToQuitAutoBuildMapMode = false;
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("接收到进入自动建图模式消息 56"));
                                String currentBuildMapAccount =
                                        AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount();
                                if (TextUtils.isEmpty(currentBuildMapAccount) || (!TextUtils.isEmpty(currentBuildMapAccount) && currentBuildMapAccount.equals(
                                        command.getSource()))) {
                                    //先修改下本地状态 防止robot.UpdateByIdFrequent接口更新再改回来 (先修改 NowCreateMapAccount 再setMode setMode 会 robotStatusUpload
                                    mIsWaitToEnterAutoBuildMapMode = true;
                                    long receivedMsgTime = System.currentTimeMillis();
                                    RxBus.getInstance().toObservable(RobotEvent.class)
                                            .filter(event -> event.getAction() == RobotEvent.EVENT_ENTER_AUTO_BUILD_MAP_MODE_SUCCESS)
                                            .take(1)
                                            .subscribe(t -> {
                                                if (System.currentTimeMillis() - receivedMsgTime < 5000) {
                                                    mMqttManager.sendMqttResultSuccess(command);
                                                }
                                            });


                                    getRobot().setNowCreateMapAccount(command.getSource());
                                    getRobot().setBuildMapAccount(command.getSource());
                                    setMode(MODE_AUTO_BUILD_MAP, "自动建图模式-进入自动建图模式mqtt");

                                    if (AutoBuildRfidMapManager.getInstance()
                                            .getBuildMapStatus() == AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_STOPPED) {
                                        AutoBuildRfidMapManager.getInstance()
                                                .setBuildMapStatus(AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_ENTERED);
                                    }
                                    AutoBuildRfidMapManager.getInstance().loadSavedRecordNodes();
                                    AutoBuildRfidMapManager.getInstance().setCurrentAutoBuildMapAccount(command.getSource());

                                } else {
                                    mMqttManager.sendMqttResultFail(command, currentBuildMapAccount);
                                }
                                break;


                            //接收到开始自动建图消息
                            case ROBOT_START_AUTO_BUILD_MAP_ACTION: {
                                if (MODE != MODE_AUTO_BUILD_MAP) {
                                    ULog.d("auto_build_map fail mode " + MODE);
                                    mMqttManager.sendMqttResultFail(command, mRes.getString(fun.unifun.library.android.R.string.start_build_map_mode_error));
                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                            MqttMsgCode.MSG_AUTO_BUILD_MAP_MODE_ERROR, null);
                                    break;
                                }
                                String currentBuildMapAccount_start_build = AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount();
                                if ((!TextUtils.isEmpty(currentBuildMapAccount_start_build) && currentBuildMapAccount_start_build.equals(command.getSource()))) {
                                    if ((rfidReadType == 2 || rfidReadType == 3) && MapManager.getInstance().getRfidNodeList().size() != 0) {
                                        ULog.d("stm_rfid 下位机读标签 自动建图 开始失败 必须先删除地图 auto_build_map fail");
                                        mMqttManager.sendMessage(currentBuildMapAccount_start_build, MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                                MqttMsgCode.MSG_OLD_MAP_MUST_BE_DELETED_BEFORE_CREATE_NEW_ONE,
                                                "地图缓存或者地图未删除，请点击清空地图");
                                        break;
                                    }
                                } else {
                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                            "用户" + AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount() + "正在控制机器人自动建图中");
                                    break;
                                }

                                if (inCharger()) {
                                    prepareLeaveCharger();
                                }
                                autoMoveManager.startAutoBuildMap(command);
                            }
                            break;

                            case ROBOT_START_TO_FRONT_AUTO_BUILD_MAP_ACTION:
                                autoMoveManager.startToFrontAutoBuildMap(command);
                                UPreferences.putString(mActivity,
                                        UConstants.PREFERENCES_AUTO_BUILD_MAP_STATUS,
                                        ROBOT_START_TO_FRONT_AUTO_BUILD_MAP_ACTION);
                                AutoBuildRfidMapManager.getInstance()
                                        .setBuildMapStatus(AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_BUILDING_TO_FRONT);
                                break;

                            //接收到手机端的心跳
                            case ROBOT_AUTO_BUILD_MAP_SEND_HEART_ACTION:
                                sendMqttResult2(command, ROBOT_AUTO_BUILD_MAP_SEND_HEART_ACTION, null);
                                break;

                            //机器人退出自动建图模式
                            case ROBOT_QUIT_AUTO_BUILD_MAP_ACTION:
                                mIsWaitToEnterAutoBuildMapMode = false;
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("机器人退出自动建图模式 57"));

                                //                            AutoBuildRfidMapManager.getInstance().uploadNodes();
                                setSpeed(UConstants.DEFAULT_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_49);
                                setStmTarget(StmTask.TARGET_CANCEL,"10");
                                AutoMoveManager.setChargerTarget = false;

                                long receivedMsgTime = System.currentTimeMillis();
                                mIsWaitToQuitAutoBuildMapMode = true;
                                RxBus.getInstance().toObservable(RobotEvent.class)
                                        .filter(event -> event.getAction() == RobotEvent.EVENT_QUIT_AUTO_BUILD_MAP_MODE_SUCCESS)
                                        .take(1)
                                        .subscribe(t -> {
                                            if (System.currentTimeMillis() - receivedMsgTime < 5000) {
                                                mMqttManager.sendMqttResultSuccess(command);
                                            }
                                        });
                                //先修改下本地状态 防止robot.UpdateByIdFrequent接口更新再改回来 (先修改 NowCreateMapAccount 再setMode setMode 会 robotStatusUpload
                                getRobot().setNowCreateMapAccount("");
                                setMode(MODE_UN_KNOW, "正常模式-退出自动建图模式mqtt");
                                AutoBuildRfidMapManager.getInstance()
                                        .setBuildMapStatus(AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_STOPPED);
                                AutoBuildRfidMapManager.getInstance().clearData();
                                AutoBuildRfidMapManager.getInstance().setCurrentAutoBuildMapAccount("");
                                MapManager.getInstance().getMap(getRobot().getId());
                                break;

                            //接收到手机端查找某个漏读的节点
                            case ROBOT_AUTO_BUILD_MAP_PHONE_NOTIFY_ROBOT_FIND_MISSING_NODE_ACTION:

                                break;

                            //手机端通知机器人去尝试寻将某个节点的信息上传至云端
                            case ROBOT_AUTO_BUILD_MAP_PHONE_NOTIFY_ROBOT_UPLOAD_ONE_NODE_INFO_ACTION:

                                break;

                            case MqttCommand.ACTION_ROBOT_LOAD_CACHE:
                                AutoBuildRfidMapManager.getInstance().loadSavedRecordNodes();
                                mMqttManager.sendMqttResultSuccess(command);
                                break;

                            case MqttCommand.AutoBuildMap.ACTION_ENABLE_REVERSE_CALIBRATE_DISTANCE:
                                ULog.d(TAG, "自动建图，打开反向里程校正");
                                AutoBuildRfidMapManager.getInstance().setReverseCalibrateDistanceSwitch(UConstants.VALUE_SWITCH_STATUS_ON);
                                mMqttManager.sendMqttResultSuccess(command);
                                break;

                            case MqttCommand.AutoBuildMap.ACTION_DISABLE_REVERSE_CALIBRATE_DISTANCE:
                                ULog.d(TAG, "自动建图，禁用反向里程校正");
                                AutoBuildRfidMapManager.getInstance().setReverseCalibrateDistanceSwitch(UConstants.VALUE_SWITCH_STATUS_OFF);
                                mMqttManager.sendMqttResultSuccess(command);
                                break;

                            default:
                                break;
                        }
                        break;
                    case ROBOT_WEB_CAMERA_TAKE_PHOTO_TYPE://机器人网络摄像头拍照相关
                        if (ROBOT_WEB_CAMERA_TAKE_PHOTO_ACTION.equals(command.getAction())) {
                            //接收到手机端通知机器人主动拍照
                            takePhoto(0, null, command.getSource());
                        }
                        break;
                    //向 下位机 发送配置气体采集板
                    case ROBOT_CONFIG_GAS_SENSOR_BOARD_CH4_TYPE:  //甲烷
                        switch (command.getAction()) {
                            case CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION://调零
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CH4,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION://校准
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CH4,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_RESET_ACTION://复位
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CH4,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION://标气值
                                standardGasval = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CH4,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE,
                                        (int) (standardGasval * 1)));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION://上限
                                upperVal = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CH4,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE,
                                        (int) (upperVal * 1)));
                                break;

                            default:
                                break;
                        }
                        break;
                    case MqttCommand.ROBOT_GET_CURRENT_ROLLER_NAME_INDEX_TYPE:
                        if (inspectManager.mCurrentTaskNode != null) {
                            if (MqttManager.getInstance().isConnected()) {
                                if (getRobot().getId().equals(command.getSource())) {
                                    ULog.d(TAG, "sendMqttResult: setTarget error");
                                    return;
                                }
                                MqttCommand clone = command.cloneCreateIdAndTimeStamp();
                                clone.setTarget(command.getSource());
                                clone.setSource(getRobot().getId());
                                clone.setValue(inspectManager.mCurrentTaskNode.getName());
                                mMqttManager.publishMessage(clone);
                            }
                        }
                        break;
                    case ROBOT_CONFIG_GAS_SENSOR_BOARD_CO_TYPE://一氧化碳
                        switch (command.getAction()) {
                            case CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION://调零
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION://校准
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_RESET_ACTION://复位
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION://标气值
                                standardGasval = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE,
                                        (int) (standardGasval * 1)));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION://上限
                                upperVal = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE,
                                        (int) (upperVal * 1)));
                                break;
                            default:
                                break;
                        }
                        break;
                    case ROBOT_CONFIG_GAS_SENSOR_BOARD_CO2_TYPE://二氧化碳
                        switch (command.getAction()) {
                            case CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION://调零
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION://校准
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_RESET_ACTION://复位
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION://标气值
                                standardGasval = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE,
                                        (int) (standardGasval * 1)));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION://上限
                                upperVal = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_CO2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE,
                                        (int) (upperVal * 1)));
                                break;
                            default:
                                break;
                        }
                        break;
                    case ROBOT_CONFIG_GAS_SENSOR_BOARD_O2_TYPE://氧气
                        switch (command.getAction()) {
                            case CONFIG_GAS_SENSOR_BOARD_ZERO_ADJUST_ACTION://调零
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_O2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_ZERO_SET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_CALIBRATION_ACTION://校准
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_O2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_CALIBRATION,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_RESET_ACTION://复位
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_O2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_RESET,
                                        0));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_STANDAR_GAS_ACTION://标气值
                                standardGasval = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_O2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_STANDARD_GAS_VALUE,
                                        (int) (standardGasval * 1)));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_FOR_UPPER_ACTION://上限
                                upperVal = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_O2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_UPPER_ALARM_VALUE,
                                        (int) (upperVal * 1)));
                                break;
                            case CONFIG_GAS_SENSOR_BOARD_FOR_LOWER_ACTION://下限
                                lowerVal = (double) command.getValue();
                                stmExecute.executeTaskNonQueue(new StmTask().sendConfigGasSensor(GAS_SENSOR_BOARD_TYPE_O2,
                                        GAS_SENSOR_BOARD_CONFIG_FUNCTION_SET_LOWER_ALARM_VALUE,
                                        (int) (lowerVal * 1)));
                                break;
                            default:
                                break;
                        }
                        break;
                    case MqttCommand.ROBOT_RESET_STM_SERIAL_PORT_INDEX_TYPE:
                        ULog.d(TAG, "stm串口重连");
                        mMqttManager.sendMqttResultSuccess(command);
                        stmExecute.resetSerialPort(mActivity.getApplicationContext());
                        break;
                    case MqttCommand.ROBOT_REBOOT_STM_INDEX_TYPE:
                        ULog.d(TAG, "下位机重启");

                        mMqttManager.sendMqttResultSuccess(command);
                        stmExecute.executeTaskNonQueue(new StmTask().stopMove("下位机重启 58"));

                        if (System.currentTimeMillis() - MainApp.mUpdateMotorTime < 1000) {
                            ULog.d(TAG, "mqtt reset stm gpio_stm_reset_75 电机心跳正常，不执行复位，通过指令重启");
                            stmExecute.executeTask(new StmTask().stmReset(1000));
                        } else {
                            mHandler.postDelayed(() -> {
                                stmExecute.clearQueue();
                                ULog.d(TAG, "GPIO_STM_RESET === 0");
                                RxBus.getInstance().post(new Stm32Event(Stm32Event.STM_REBOOT, Stm32RebootReason.MQTT));
                                gpioCtrl(UConstants.GPIO_STM_RESET, 0);
                            }, 1000);

                            mHandler.postDelayed(() -> {
                                ULog.d(TAG, "GPIO_STM_RESET === 1");
                                gpioCtrl(UConstants.GPIO_STM_RESET, 1);
//                            SteerController.getInstance().resetSteer();
                                isNeedInitSteer = true;
                            }, 2000);
                        }
                        resetStmHeartCheck();
                        break;
                    case MqttCommand.MOVE_TO_TARGET_TYPE:
                        MoveToTarget moveToTarget = null;
                        try{
                            String value1 = (String) command.getValue();
                            moveToTarget = UGson.getGson().fromJson(value1, MoveToTarget.class);
                        }catch (Exception e){
                            ULog.e(TAG,"解析 MOVE_TO_TARGET_TYPE value json error:"+e.getMessage());
                        }
                        if(moveToTarget != null && (moveToTarget.getTgtTaskNodeId() != null || moveToTarget.getTgtLocation() != null)){
                            String fromMqtt = startToTarget(moveToTarget.getTgtTaskNodeId(), moveToTarget.getTgtLocation(), "fromMqtt");
                            ULog.d(TAG,"startToTarget2 "+fromMqtt);
                            if(!command.getSource().contains("self")){
                                if(fromMqtt.contains("OK")){
                                    mMqttManager.sendMqttResultSuccess(command);
                                }else{
                                    mMqttManager.sendMqttResultFail(command);
                                }
                            }else{

                            }
                        }else{
                            if(!command.getSource().contains("self")) {
                                mMqttManager.sendMqttResultFail(command);
                            }
                        }
                        break;
                    case MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE:
                        mIsFirstDustingAfterBoot = false;
                        mHasTriedGoChargerAfterMotorStall = false;
                        //移除堵转后30分钟重试的消息
                        mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);
                        //移除堵转反方向移动的消息
                        if(mHandler.hasMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD)){
                            mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                        }

                        if (MODE == MODE_AUTO_BUILD_MAP) {
                            if (!TextUtils.isEmpty(command.getSource()) && !command.getSource().equals(AutoBuildRfidMapManager.getInstance()
                                    .getCurrentAutoBuildMapAccount())) {
                                mMqttManager.sendMqttResultFail(command,
                                        "用户" + AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount() + "正在控制机器人自动建图中");
                                mMqttManager.sendResultFail(command,
                                        MqttMsgCode.MSG_USER_X_BUILD_MAP_NOW,
                                        AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount());
                                RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_10,AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount()));
                                return;
                            }
                        }
                        if (MainApp.emergencyStopButton == 0) {
                            //给手机管家发送
                            mMqttManager.sendResultFail(command, MqttMsgCode.MSG_EMERGENCY_BUTTON_PRESSED_CANNOT_MOVE, mRes.getString(R.string.stop_button_pressed_not_move));
                            RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_11));
                            return;
                        }
                        switch (command.getAction()) {
                            case MqttCommand.ROBOT_MOVE_FRONT_ACTION:
                                if (MODE == MODE_INSPECTION || MODE == MODE_CHECKING_STOP) {
                                    //给手机管家发送
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_INSPECTION_NOW_STOP_BEFORE_CONTROL, mRes.getString(R.string.inspecting));
                                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_12));
                                    return;
                                }
                                if (MODE == MODE_GOTO_CHARGER) {
                                    //给手机管家发送
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_GOTO_CHARGER_NOW_STOP_BEFORE_CONTROL, mRes.getString(R.string.tips_goto_charging_cannot_control));
                                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_13));
                                    return;
                                }


                                //复位烟雾异常前的模式存储
                                mRobotModeBeforeSmokeException = MODE_UN_KNOW;
                                prepareLeaveCharger();
                                removeRetryInspectMsg();
                                setRobotDirection(StmTask.MOVE_FRONT,"18");

                                if (mDistance < 1.0f && (RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_FB || RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_MA)
                                        && NumberUtil.notNullAndEqual(CicadaRoomController.getInstance().haveRoom(), true)) {
	                                if (CicadaRoomController.getInstance().getControlSource() == RoomControlSource.ROBOT) {
		                                boolean doorOpened = CicadaRoomController.getInstance()
				                                .getCurDorState() == CicadaRoomDoorState.OPEN;
		                                boolean waitingClose = RobotStatus.getIsWaitRoomDoorClose();
		                                if (!doorOpened || waitingClose) {
			                                ULog.d(TAG, "MOVE_BACK cicada room 状态：" + CicadaRoomController.getInstance().getCurDorState());
			                                mCmdAfterRoomOp = command.cloneCreateIdAndTimeStamp();
			                                RobotStatus.setIsWaitRoomDoorOpen(true);
			                                CicadaRoomController.getInstance().controlDoor(CicadaRoomDoorState.OPEN);
			                                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROOM_IS_OPENING_DOOR_COMMAND_CONTINUE_AFTER_DOOR_OPEN);
			                                mMqttManager.broadcastShowInfo("Room正在开门，指令将在开门完成后执行");
                                            RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_14));
											return;
		                                } else {
			                                ObstacleController.getInstance().setObstacleOn(false,"19");
			                                setRobotActionCode(robotDirection == MOVE_FRONT ?
					                                RobotActionCode.MOVE_FRONT : RobotActionCode.MOVE_END);
                                            stmExecute.executeTask(new StmTask().move(robotDirection,
                                                    (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? defaultRotate :
                                                            (Float.parseFloat(String.valueOf(command.getValue()))),
                                                    (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? DEFAULT_DISTANCE :
                                                            (Float.parseFloat(String.valueOf(command.getValue())))));
		                                }
	                                } else {
										mMqttManager.broadcastShowInfo(getString(R.string.robot_cannot_move_when_room_in_manual_control));
										mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_CANNOT_MOVE_WHEN_IN_ROOM_AREA_AND_ROOM_IN_MANUAL_CONTROL);
                                        RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_15));
										return;
	                                }
                                } else {
                                    setRobotActionCode(robotDirection == MOVE_FRONT ?
                                            RobotActionCode.MOVE_FRONT : RobotActionCode.MOVE_END);
                                    stmExecute.executeTask(new StmTask().move(robotDirection,
                                            (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? defaultRotate :
                                                    (Float.parseFloat(String.valueOf(command.getValue()))),
                                            (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? DEFAULT_DISTANCE :
                                                    (Float.parseFloat(String.valueOf(command.getValue())))));
                                }
                                if (getRobot() != null && getRobot().getChargeStatus() == ChargerStatus.CHARGE_END) {
                                    notifyLeaveCharger();
                                }
                                batteryAutoOff = false;
                                UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_BATTERY_AUTO_OFF_KEY, false);
                                if (mHandler.hasMessages(Msg.WHAT_LEAVE_CHARGER)) {
                                    mHandler.removeMessages(Msg.WHAT_LEAVE_CHARGER);
                                }
                                if (mHandler.hasMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE)) {
                                    mHandler.removeMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE);
                                }
                                break;
                            case MqttCommand.ROBOT_MOVE_BACK_ACTION:

                                if (MODE == MODE_INSPECTION || MODE == MODE_CHECKING_STOP) {
                                    //给手机管家发送
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_INSPECTION_NOW_STOP_BEFORE_CONTROL, null);
                                    mMqttManager.sendMqttResultFail(command, mRes.getString(fun.unifun.library.android.R.string.inspecting));
                                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_12));
                                    return;
                                }

                                if (MODE == MODE_GOTO_CHARGER) {
                                    //给手机管家发送
                                    mMqttManager.sendMqttResultFail(command, mRes.getString(fun.unifun.library.android.R.string.tips_goto_charging_cannot_control));
                                    RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_13));
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_GOTO_CHARGER_NOW_STOP_BEFORE_CONTROL, null);

                                    return;
                                }

                                //复位烟雾异常前的模式存储
                                mRobotModeBeforeSmokeException = MODE_UN_KNOW;
                                prepareLeaveCharger();
                                removeRetryInspectMsg();
                                setRobotDirection(StmTask.MOVE_END,"19");
                                if (mDistance < 0.0f && (RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_FB || RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_MA)
                                        && NumberUtil.notNullAndEqual(CicadaRoomController.getInstance().haveRoom(), true)) {
									if (CicadaRoomController.getInstance().getControlSource() == RoomControlSource.ROBOT) {
										boolean doorOpen = CicadaRoomController.getInstance().getCurDorState() == CicadaRoomDoorState.OPEN;
										boolean waitingClose = RobotStatus.getIsWaitRoomDoorClose();
										if (!doorOpen || waitingClose) {
											ULog.d(TAG, "MOVE_BACK cicada room 状态：" + CicadaRoomController.getInstance().getCurDorState());
											mCmdAfterRoomOp = command.cloneCreateIdAndTimeStamp();
											RobotStatus.setIsWaitRoomDoorOpen(true);
											CicadaRoomController.getInstance().controlDoor(CicadaRoomDoorState.OPEN);
											mMqttManager.broadcastShowInfo("Room正在开门，指令将在开门完成后执行");
                                            RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_14));
											mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROOM_IS_OPENING_DOOR_COMMAND_CONTINUE_AFTER_DOOR_OPEN);

											return;
										} else {
											ObstacleController.getInstance().setObstacleOn(false,"20");
											setRobotActionCode(robotDirection == MOVE_FRONT ?
													RobotActionCode.MOVE_FRONT : RobotActionCode.MOVE_END);
                                            stmExecute.executeTask(new StmTask().move(robotDirection,
                                                    (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? defaultRotate :
                                                            (Float.parseFloat(String.valueOf(command.getValue()))),
                                                    (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? DEFAULT_DISTANCE :
                                                            (Float.parseFloat(String.valueOf(command.getValue())))));
										}
									} else {
										mMqttManager.broadcastShowInfo(getString(R.string.robot_cannot_move_when_room_in_manual_control));
                                        RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_15));
										mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_CANNOT_MOVE_WHEN_IN_ROOM_AREA_AND_ROOM_IN_MANUAL_CONTROL);
										return;
									}
                                } else {
                                    setRobotActionCode(robotDirection == MOVE_FRONT ?
                                            RobotActionCode.MOVE_FRONT : RobotActionCode.MOVE_END);
                                    stmExecute.executeTask(new StmTask().move(robotDirection,
                                            (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? defaultRotate :
                                                    (Float.parseFloat(String.valueOf(command.getValue()))),
                                            (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue()))) ? DEFAULT_DISTANCE :
                                                    (Float.parseFloat(String.valueOf(command.getValue())))));
                                }
                                if (getRobot() != null && getRobot().getChargeStatus() == ChargerStatus.CHARGE_FRONT) {
                                    notifyLeaveCharger();
                                }
                                batteryAutoOff = false;
                                UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_BATTERY_AUTO_OFF_KEY, false);
                                if (mHandler.hasMessages(Msg.WHAT_LEAVE_CHARGER)) {
                                    mHandler.removeMessages(Msg.WHAT_LEAVE_CHARGER);
                                }
                                if (mHandler.hasMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE)) {
                                    mHandler.removeMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE);
                                }
                                break;
                            case MqttCommand.ROBOT_STOP_ACTION:
                                MapManager.getInstance().findRFIDNodeByDistance(mDistance);
                                execStopMove("mqtt 停止指令");
                                if (MainApp.isCokeOvenInspect) {
                                    isServerStartRecognise = false;
                                    mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_INSPECTION_STOP_COKE_OVEN_RECOGNISE_ACTION, "STOP");
                                }
                                if (MainApp.isRgbRecognition) {
                                    isServerStartRecogniseRGB = false;
                                    mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_INSPECTION_STOP_RGB_RECOGNISE_ACTION, "STOP");
                                }
                                if (MainApp.isRecordVideoAutoRecognition) {
                                    isServerStartRecordVideoRecog = false;
                                    mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_RECORD_VIDEO_RECOGNISE_STOP_ACTION, "STOP");
                                }
                                break;


                            default:
                                break;
                        }
                        //TODO 未判断下位机返回结果 不应该直接返回给手机端mqtt
                        mMqttManager.sendMqttResultSuccess(command);
                        break;
                    case MqttCommand.ROBOT_COLLECTION_INDEX_TYPE: //采集
                        Map<String, String> collectionMap = new HashMap<>();
                        collectionMap.put(command.getSource(), command.getType());
                        mqttMsgList.add(collectionMap);
                        RfidController.getInstance().readData();
                        //                    mHandler.sendEmptyMessageDelayed(Msg.WHAT_RFID_TIMEOUT, 5000);
                        break;

                    case MqttCommand.ROBOT_IR_PUT_TEXT_TYPE:
                        if (MqttCommand.ROBOT_IR_PUT_TEXT_OPEN_ACTION.equals(command.getAction())) {
                            setPutText(true);
                        } else if (MqttCommand.ROBOT_IR_PUT_TEXT_CLOSE_ACTION.equals(command.getAction())) {
                            setPutText(false);
                        }
                        break;
                    case MqttCommand.ROBOT_MA_CURRENT_LIMIT_TYPE:
                        if (MqttCommand.ROBOT_MA_CURRENT_LIMIT_OPEN_ACTION.equals(command.getAction())) {
                            ULog.d(TAG, "限流open 6000");
                            stmExecute.executeTask(new StmTask().sendStmCommand("motec write 5 6000".getBytes()));
                            stmExecute.executeTask(new StmTask().sendStmCommand("motec write 209 6000".getBytes()));
                            stmExecute.executeTask(new StmTask().sendStmCommand("motec write 211 6000".getBytes()));
                        } else if (MqttCommand.ROBOT_MA_CURRENT_LIMIT_CLOSE_ACTION.equals(command.getAction())) {
                            ULog.d(TAG, "限流close 3000");
                            stmExecute.executeTask(new StmTask().sendStmCommand("motec write 5 3000".getBytes()));
                            stmExecute.executeTask(new StmTask().sendStmCommand("motec write 209 3000".getBytes()));
                            stmExecute.executeTask(new StmTask().sendStmCommand("motec write 211 3000".getBytes()));
                        }
                        break;
                    case MqttCommand.ROBOT_SPEED_STATE_INDEX_TYPE:
//                        if (MODE == MODE_AUTO_BUILD_MAP) {
//                            if (AutoBuildRfidMapManager.getInstance()
//                                    .getBuildMapStatus() == AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_BUILDING_TO_END || AutoBuildRfidMapManager.getInstance()
//                                    .getBuildMapStatus() == AutoBuildRfidMapManager.AUTO_BUILD_MAP_STATUS_BUILDING_TO_FRONT) {
//                                mMqttManager.sendMqttResultFail(command, "自动建图中不可修改速度");
//                                return;
//                            }
//                        }
/*                        if (MODE == MODE_COLLECTION_RAW_DATA_MP4) {
                            //给手机管家发送
                            sendMqtt(getRobot().getId(), productionClientId, MqttCommand.ROBOT_SHOW_INFO_INDEX, null, mRes.getString(fun.unifun.library.android.R.string.raw_data_recording_not_modify_speed));
                            mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.raw_data_recording_not_modify_speed));
                            //                        sendMqttResult(command);
                            return;
                        }*/
                        if (MODE == MODE_GOTO_CHARGER) {
                            //给手机管家发送
                            mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_GOTO_CHARGER_CANNOT_SET_SPEED, null);
                            mMqttManager.sendMqttResultFail(command, mRes.getString(fun.unifun.library.android.R.string.goto_charger_not_modify_speed));
                            RxBus.getInstance().post(new BluetoothEvent(BLE_BLUETOOTH_MSG_SHOW_MSG_ACTION,MSG_CODE_16));
                            return;
                        }
                        float speed = Float.parseFloat(command.getAction());
                        if (speed < 0) {
                            speed = 0;
                        } else if (speed > UConstants.MAX_SPEED) {
                            speed = (float) UConstants.MAX_SPEED;
                        }

                        UConstants.DEFAULT_SPEED = speed;
                        setSpeed(speed, RobotSetSpeedLogTags.SPEELD_lOG_TAG_33_ROF_PHOEN);
                        ULog.d(TAG, "onMessageReceived:  == mqtt speed  = " + MqttManager.getInstance().isConnected());
                        //todo： 2021年2月25日 需要切换新版消息回复
                        mMqttManager.sendMqttResultSuccess(command,speed);
                        break;

                    case MqttCommand.ROBOT_LIGHT_STATE_INDEX_TYPE:
                        if (MqttCommand.ROBOT_LIGHT_OPEN_ACTION.equals(command.getAction())) {
                            stmExecute.executeTask(new StmTask().sayHello());
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_LIGHT_CLOSE, 5000);
                        } else {
                            stmExecute.executeTask(new StmTask().sayByeBye());
                        }

                        mMqttManager.sendMqttResultSuccess(command);
                        break;

                    case ROBOT_INSPECTION_INDEX_TYPE:
                        //移除堵转后30分钟重试的消息
                        mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);
                        //移除堵转反方向移动的消息
                        if(mHandler.hasMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD)){
                            mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
                        }
                        if (RobotActionCode.isHindranceCode(mBotInfoMgr.getRobotActionCode())) {
                            mBotInfoMgr.setRobotActionCode(RobotActionCode.IDLE, null);
                        }
                        mHasTriedGoChargerAfterMotorStall = false;

                        if (MODE == MODE_AUTO_BUILD_MAP) {
                            if (!TextUtils.isEmpty(command.getSource()) && !command.getSource().equals(AutoBuildRfidMapManager.getInstance()
                                    .getCurrentAutoBuildMapAccount())) {
                                mMqttManager.sendMessage(command.getSource(),
                                        MqttCommand.ROBOT_SHOW_INFO_INDEX,
                                        "",
                                        "用户" + AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount() + "正在控制机器人自动建图中");
                                mMqttManager.sendMessage(command.getSource(),
                                        MqttCommand.ROBOT_SHOW_INFO_INDEX,
                                        "",
                                        MqttMsgCode.MSG_USER_X_BUILD_MAP_NOW,
                                        AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount());
                                return;
                            }
                        }
                        if (MqttCommand.ROBOT_INSPECTION_START_ACTION.equals(command.getAction()) ||
                                MqttCommand.ROBOT_INSPECTION_FORCE_ACTION.equals(command.getAction()) ||
                                (MqttCommand.ROBOT_INSPECTION_CHARGING_ACTION.equals(command.getAction()) && MODE != MODE_BATCH_PRODUCTION_TEST)) {

                            switch (autoMoveManager.checkMap()) {
                                case 1:
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_NOT_BUILD_MAP, mRes.getString(R.string.robot_not_build_map));
                                    MapManager.getInstance().getMap(getRobot().getId());
                                    return;
                                case 2:
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_MAP_NO_HEAD, mRes.getString(R.string.map_lack_head));
                                    return;
                                /*case 3:
                                    sendMobileInfo(mRes.getString(fun.unifun.library.android.R.string.map_lack_charger));
                                    return;*/
                                case 4:
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_MAP_NO_TAIL, mRes.getString(R.string.map_lack_tail));
                                    return;
                                case 5:
                                case 6:
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_MAP_RFID_EXCEPTION, mRes.getString(R.string.robot_map_rfid_exception));
                                    break;
                                case 7:
                                case 8:
                                    mMqttManager.sendResultFail(command, MqttMsgCode.MSG_ROBOT_MAP_TASK_EXCEPTION, mRes.getString(R.string.robot_map_task_exception));
                                    break;
                                default:
                                    break;
                            }

                        }
                        if (MainApp.emergencyStopButton == 0) {
                            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_EMERGENCY_BUTTON_PRESSED);
                            mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.stop_button_pressed_not_move));

                            return;
                        }
                        if (MqttCommand.ROBOT_INSPECTION_START_ACTION.equals(command.getAction())) {
                            autoMoveManager.gotoChargerCheck("mqtt巡检?_回充");
                        } else if (MqttCommand.ROBOT_INSPECTION_STOP_ACTION.equals(command.getAction())) {
                            if (mHandler.hasMessages(Msg.WHAT_START_INSPECTION)) {
                                mHandler.removeMessages(Msg.WHAT_START_INSPECTION);
                            }
                            stmExecute.executeTaskNonQueue(new StmTask().stopMove("STOP_INSPECTION 59"));
                            setSpeed(UConstants.DEFAULT_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_34);
                            if (MODE != MODE_BATCH_PRODUCTION_TEST) {
                                setMode(MODE_UN_KNOW, "正常模式-STOP_INSPECTION");
                            }
                        } else if (MqttCommand.ROBOT_INSPECTION_CHARGING_ACTION.equals(command.getAction())) {
                            if (MODE == MODE_BATCH_PRODUCTION_TEST || MODE == MODE_AGING_TEST) {
                                setStmTarget(StmTask.TARGET_CHARGER,"11");
                                AutoMoveManager.setChargerTarget = true;
                                setRobotDirection(StmTask.MOVE_FRONT,"20");
                                stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                            } else {
                                clearMotorOverCurrentFlags();
                                //                            mMotorSlipCount = 0;

                                checkInPlaceSwitchNum = 0;
                                //记录方向
                                lastRobotDirection = robotDirection;
                                ULog.d(TAG,
                                        "onMessageReceived: mqtt robotDirection = " + robotDirection + ", lastRobotDirection = " + lastRobotDirection);
                                autoMoveManager.gotoChargerCheck("mqtt_回充");
                            }
                        } else if (MqttCommand.ROBOT_INSPECTION_FORCE_ACTION.equals(command.getAction())) {
                            if (MODE == MODE_AUTO_BUILD_MAP) {
                                if (!TextUtils.isEmpty(command.getSource()) && !command.getSource()
                                        .equals(AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount())) {
                                    sendMqtt(getRobot().getId(),
                                            command.getSource(),
                                            MqttCommand.ROBOT_SHOW_INFO_INDEX,
                                            null,
                                            "用户" + AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount() + "正在控制机器人自动建图中");
                                    return;
                                }
                            }
                            if (MODE == MODE_INSPECTION) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", mRes.getString(R.string.robot_inspecting_now_do_not_repeat_op));
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                        MqttMsgCode.MSG_ROBOT_INSPECTING_NOW_DO_NOT_REPEAT_OP, null);
                                return;
                            }
//                            if (MainApp.isReclaimer) {
//                                if (MODE == MODE_RECLAIMER) {
//                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "机器人已经在取料机巡检，请勿重复点击");
//                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
//                                            MqttMsgCode.MSG_ROBOT_INSPECTING_NOW_DO_NOT_REPEAT_OP, null);
//                                    return;
//                                }
//                            }
                            if (getRobot().getPowerPercent() <= getRobot().getLowPowerThreshold()) {
                                sendMqtt(getRobot().getId(),
                                        command.getSource(),
                                        MqttCommand.ROBOT_SHOW_INFO_INDEX,
                                        null,
                                        "低于电量阈值: " + getRobot().getLowPowerThreshold() + ", 机器人无法强制巡检");
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", MqttMsgCode.MSG_ROBOT_POWER_BELOW_THRESHOLD_CANNOT_INSPECT, getRobot().getLowPowerThreshold());
                                return;
                            }

                            autoMoveManager.cancelRoomIgnoreChargeNotice();

                            ULog.d(TAG, "ROBOT_INSPECTION command.getValue() = " + command.getValue());
                            if (command.getValue() != null && !TextUtils.isEmpty(String.valueOf(command.getValue())) && !"null".equalsIgnoreCase(String.valueOf(command.getValue()))) {
                                String s = command.getValue().toString();
                                if (MqttCommand.ROBOT_INSPECTION_CORRIDOR.equals(s)) {
                                    RobotConfigParams configParams = getRobotConfigParams();
                                    RobotConfigParams.CorridorInspectionSwitchNodeInfo corridorInspectionSwitchNodeInfo = configParams.getCorridorInspectionSwitchNodeInfo();
                                    if (corridorInspectionSwitchNodeInfo != null
                                            && corridorInspectionSwitchNodeInfo.getSwitchNodeListEnd() != null
                                            && corridorInspectionSwitchNodeInfo.getSwitchNodeListFront() != null
                                            && corridorInspectionSwitchNodeInfo.getSwitchNodeListEnd().size() > 0
                                            && corridorInspectionSwitchNodeInfo.getSwitchNodeListFront().size() > 0) {
                                        //廊道巡检模式根据 根据value 判断某个标识，来设置廊道巡检  廊道巡检 只调整机器人的摄像头位置 过程中暂时不检测红外温度（之后要检测红外温度） 巡检过充中如果遇到充电桩节点并且是往充电桩方向走 就让机器人回充 标识置空
                                        setCorridorInspection(true);
                                        inspectManager.setCorridorInspectionSwitchNodeInfo(corridorInspectionSwitchNodeInfo);
                                        inspectManager.clearInspectTargetInfo();
                                        inspectIsBySelf(command);
                                        startInspection("mqtt_廊道巡检");
                                    } else {
                                        mMqttManager.broadcastShowInfo("请检查机器人廊道巡检所需配置!");
                                        setCorridorInspection(false);
                                        return;
                                    }

                                } else {
                                    //指定位置巡检
                                    setCorridorInspection(false);

                                    int targetNodeId = (int) Double.parseDouble(s);
                                    TaskNode targetNode = inspectManager.getTaskNodeById(targetNodeId);
                                    if (targetNode == null) {
                                        ULog.d(TAG, "未获取到目标巡检位置，无法开始巡检");
                                        mMqttManager.sendMqttResultFail(command);
                                        return;
                                    }
                                    //                                else if ((inspectManager.mCurrentTaskNode != null && targetNode.getId().equals(inspectManager.mCurrentTaskNode.getId()))) {
                                    //                                    ULog.w(TAG, "当前已在巡检指定目标位置!");
                                    //                                    return;
                                    //                                }

                                    ULog.d(TAG,
                                            "巡检至目标节点：" + targetNodeId + "name=" + targetNode.getName() + "AngleJson=" + targetNode.getAngleJson() + "  WebcamJson=" + targetNode.getWebcamJson());
                                    TaskNode mTargetInspectionNode = targetNode;
                                    inspectManager.targetNodeAngleH = -1;
                                    inspectManager.targetNodeAngleV = -1;
                                    inspectManager.targetNodeWebcamJson = null;
                                    inspectManager.targetFillLightLevel = null;
                                    if (!TextUtils.isEmpty(mTargetInspectionNode.getAngleJson())) {
                                        float[] angle = UConstants.getAngle(mTargetInspectionNode.getAngleJson());
                                        inspectManager.targetNodeAngleH = angle[0] + MainApp.hAngleOffset;
                                        inspectManager.targetNodeAngleV = angle[1] + MainApp.vAngleOffset;
                                    }
                                    if (!TextUtils.isEmpty(mTargetInspectionNode.getWebcamJson())) {
                                        inspectManager.targetNodeWebcamJson = mTargetInspectionNode.getWebcamJson();
                                        inspectManager.targetFillLightLevel = mTargetInspectionNode.getWebFillLightBrightness();
                                    }
                                    inspectIsBySelf(command);
                                    CommonResult result = inspectionToLocation(mTargetInspectionNode.getStartLocation());
                                    if (result.resultCode != ResultCode.OK) {
                                        mMqttManager.broadcastShowInfo(result.message);
                                    }

                                }
                            } else {
                                //正常巡检模式
                                setCorridorInspection(false);
                                inspectManager.clearInspectTargetInfo();
                                inspectIsBySelf(command);
                                CommonResult insResult = startInspection("mqtt_巡检有可能机器人自及发的");
                                if (insResult.resultCode != ResultCode.OK) {
                                    mMqttManager.broadcastShowInfo(insResult.message);
                                    mMqttManager.broadcastShowInfoMsgCode(insResult.msgCode);
                                    return;
                                }
                            }

                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_FORCE_INSPECTION_KEY, 1);
                        } else if (MqttCommand.ROBOT_RECORD_VIDEO_START_MILEAGE_ACTION.equals(command.getAction())) {
                            if (mDistance > -4 && mDistance <= -0.2) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "机器人已经在开始录制位置");
                                return;
                            }
                            if (MODE == MODE_INSPECTION) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", mRes.getString(R.string.robot_inspecting_now_do_not_repeat_op));
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                        MqttMsgCode.MSG_ROBOT_INSPECTING_NOW_DO_NOT_REPEAT_OP, null);
                                return;
                            }

                            setCorridorInspection(false);
                            ULog.d(TAG, "移动到开始录制位置 -0.2m");
                            inspectIsBySelf(command);
                            CommonResult result = inspectionToLocation(-0.2f);
                            if (result.resultCode != ResultCode.OK) {
                                mMqttManager.broadcastShowInfo(result.message);
                            }
                        } else if (MqttCommand.ROBOT_RECORD_VIDEO_CONTINUE_MILEAGE_ACTION.equals(command.getAction())) {
                            float continueMileage = StorageCenter.getRobotStorage().getFloat(UConstants.PREFERENCES_RECORD_VIDEO_CONTINUE_MILEAGE_KEY, -10f);

                            ULog.d(TAG, "移动到继续录制位置 " + continueMileage);
                            if (mDistance < continueMileage && mDistance > continueMileage - 1) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "机器人已经在继续录制位置");
                                return;
                            }
                            if (MODE == MODE_INSPECTION) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", mRes.getString(R.string.robot_inspecting_now_do_not_repeat_op));
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                        MqttMsgCode.MSG_ROBOT_INSPECTING_NOW_DO_NOT_REPEAT_OP, null);
                                return;
                            }

                            setCorridorInspection(false);
                            inspectIsBySelf(command);
                            CommonResult result = inspectionToLocation(continueMileage - 0.2f);
                            if (result.resultCode != ResultCode.OK) {
                                mMqttManager.broadcastShowInfo(result.message);
                            }
                        } else if (MqttCommand.ROBOT_RECORD_VIDEO_RESTART_ACTION.equals(command.getAction())) {
                            if (command.getValue() == null || TextUtils.isEmpty((String)command.getValue())) {
                                ULog.d(TAG, "开始录制 value is null" + command.getValue());
                                return;
                            }
                            //1 只录像 2 录像加识别
                            int option = MqttCommand.ROBOT_RECORD_VIDEO_ONLY_ACTION.equals((String)command.getValue()) ? 1 : 2;
                            ULog.d(TAG, "开始录制 option " + option);
                            if (mDistance < -4 || mDistance > -0.1) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "机器人不在开始录制位置");
                                return;
                            }
                            if (MODE == MODE_INSPECTION) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", mRes.getString(R.string.robot_inspecting_now_do_not_repeat_op));
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                        MqttMsgCode.MSG_ROBOT_INSPECTING_NOW_DO_NOT_REPEAT_OP, null);
                                return;
                            }
                            UPreferences.putInt(mActivity, UConstants.PREFERENCE_RECORD_VIDEO_MODE_KEY, option);
                            //正常巡检模式
                            setCorridorInspection(false);
                            inspectManager.clearInspectTargetInfo();
                            inspectIsBySelf(command);
                            CommonResult insResult = startInspection("mqtt_从头开始录像");
                            if (insResult.resultCode != ResultCode.OK) {
                                mMqttManager.broadcastShowInfo(insResult.message);
                                mMqttManager.broadcastShowInfoMsgCode(insResult.msgCode);
                                return;
                            }

                        } else if (MqttCommand.ROBOT_RECORD_VIDEO_CONTINUE_ACTION.equals(command.getAction())) {
                            if (command.getValue() == null || TextUtils.isEmpty((String)command.getValue())) {
                                ULog.d(TAG, "继续录制 value is null" + command.getValue());
                                return;
                            }
                            float continueMileage = StorageCenter.getRobotStorage().getFloat(UConstants.PREFERENCES_RECORD_VIDEO_CONTINUE_MILEAGE_KEY, -10f);

                            //1 只录像 2 录像加识别
                            int option = MqttCommand.ROBOT_RECORD_VIDEO_ONLY_ACTION.equals((String)command.getValue()) ? 1 : 2;
                            ULog.d(TAG, "继续录制 option " + option + " continueMileage " +continueMileage);

                            if (mDistance < continueMileage - 1 || mDistance > continueMileage + 0.05) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "机器人不在继续录制位置");
                                return;
                            }
                            if (MODE == MODE_INSPECTION) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", mRes.getString(R.string.robot_inspecting_now_do_not_repeat_op));
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                        MqttMsgCode.MSG_ROBOT_INSPECTING_NOW_DO_NOT_REPEAT_OP, null);
                                return;
                            }
                            UPreferences.putInt(mActivity, UConstants.PREFERENCE_RECORD_VIDEO_MODE_KEY, option);
                            //正常巡检模式
                            setCorridorInspection(false);
                            inspectManager.clearInspectTargetInfo();
                            inspectIsBySelf(command);
                            CommonResult insResult = startInspection("mqtt_继续录像");
                            if (insResult.resultCode != ResultCode.OK) {
                                mMqttManager.broadcastShowInfo(insResult.message);
                                mMqttManager.broadcastShowInfoMsgCode(insResult.msgCode);
                                return;
                            }

                        } else if (MqttCommand.ROBOT_INSPECTION_TO_MILEAGE_ACTION.equals(command.getAction())) {
                            if (MODE == MODE_AUTO_BUILD_MAP) {
                                if (!TextUtils.isEmpty(command.getSource()) && !command.getSource()
                                        .equals(AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount())) {
                                    sendMqtt(getRobot().getId(),
                                            command.getSource(),
                                            MqttCommand.ROBOT_SHOW_INFO_INDEX,
                                            null,
                                            "用户" + AutoBuildRfidMapManager.getInstance().getCurrentAutoBuildMapAccount() + "正在控制机器人自动建图中");
                                    return;
                                }
                            }
                            if (MODE == MODE_INSPECTION) {
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", mRes.getString(R.string.robot_inspecting_now_do_not_repeat_op));
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                        MqttMsgCode.MSG_ROBOT_INSPECTING_NOW_DO_NOT_REPEAT_OP, null);
                                return;
                            }
                            autoMoveManager.cancelRoomIgnoreChargeNotice();


                            if (command.getValue() != null) {
                                String s = command.getValue().toString();
                                if (!MqttCommand.ROBOT_INSPECTION_CORRIDOR.equals(s)) {
                                    //指定位置巡检
                                    setCorridorInspection(false);
                                    float location = Float.parseFloat(s);
                                    ULog.d(TAG,
                                            "巡检至目标里程：" + location);
                                    inspectIsBySelf(command);
                                    CommonResult result = inspectionToLocation(location);
                                    if (result.resultCode != ResultCode.OK) {
                                        mMqttManager.broadcastShowInfo(result.message);
                                    }
                                }
                            }
                        } else if (MqttCommand.ROBOT_INSPECTION_START_COKE_OVEN_RECOGNISE_READY_ACTION.equals(command.getAction())) {
                            ULog.d(TAG, "CokeOven 焦炉巡检识别开启");
                            isServerStartRecognise = true;
                            startInspection(robotDirection,"焦炉巡检识别开启");
                        } else if (MqttCommand.ROBOT_INSPECTION_STOP_COKE_OVEN_RECOGNISE_READY_ACTION.equals(command.getAction())) {
                            ULog.d(TAG, "CokeOven 焦炉巡检识别停止");
                            isServerStartRecognise = false;
                        }
                        mMqttManager.sendMqttResultSuccess(command);
                        break;

                    case MqttCommand.ROBOT_DELETE_MAP_INDEX_TYPE:
                        //todo 暂未决定删图逻辑，RFID删除暂时分开处理
                        if (!TextUtils.isEmpty(command.getAction())) {
                            switch (command.getAction()) {
                                case MqttCommand.ROBOT_ACTION_DELETE_RFID_MAP:
                                    ULog.w(TAG, "删除RFID地图");
                                    if (mSegment == null || mSegment.getMapId() == null) {
                                        ULog.e(TAG, "线段id未空");
                                        mMqttManager.sendMqttResultFail(command);
                                        break;
                                    }

                                    DeleteByMapId deleteRfidNodesRequest = new DeleteByMapId();
                                    deleteRfidNodesRequest.setMapId(mSegment.getMapId());

                                    RfidNodeServiceImpl.getInstance().getRfidNodeService()
                                            .deleteRfidNodesByMapId(deleteRfidNodesRequest)
                                            .subscribe(new NextObserver<DeleteByMapId>() {
                                                @Override
                                                public void onNext(@NonNull DeleteByMapId deleteByMapId) {
                                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("删除RFID地图 60"));
                                                    MapManager.getInstance().deleteMap(MapManager.DELETE_RFID_MAP);
                                                    RfidLostChecker.getInstance().deleteAllRecords();
                                                    AutoMoveManager.getInstance(getContext(), RobotFragment.this).clearNodes();
                                                    AutoBuildRfidMapManager.getInstance().clearData();
                                                    ChargerNodeManager.getInstance().clearMapData();
                                                    mMqttManager.sendMqttResultSuccess(command);
                                                }

                                                @Override
                                                public void onError(@NonNull Throwable e) {
                                                    super.onError(e);
                                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("删除RFID地图失败 61"));

                                                    ULog.e(TAG, "删除地图RFID失败", e);
                                                    e.printStackTrace();
                                                    mMqttManager.sendMqttResultFail(command, mRes.getString(R.string.server_err));
                                                }
                                            });


                                    break;

                                default:
                                    break;
                            }
                        }
                        break;

                    case MqttCommand.ROBOT_OBSTACLE_STATE_INDEX:
                        if (MqttCommand.ROBOT_OPEN_OBSTACLE_ACTION.equals(command.getAction())) {
                            ObstacleController.getInstance().setObstacleOn(true,"21");
                        } else {
                            ObstacleController.getInstance().setObstacleOn(false,"22");
                        }
                        mMqttManager.sendMqttResultSuccess(command);
                        break;
                    case MqttCommand.ROBOT_UPDATE_ROBOT_INFO_INDEX:
                        if (getRobot() != null) {
                            mBotInfoMgr.getRobotByIdFromServer(getRobot().getId())
                                    .subscribeOn(Schedulers.io())
                                    .subscribe(new Observer<FindById>() {
                                        @Override
                                        public void onSubscribe(@NonNull Disposable d) {

                                        }

                                        @Override
                                        public void onNext(@NonNull FindById findById) {
                                            mMqttManager.sendMqttResultSuccess(command);
                                            ULog.e(TAG, "onResponseOk: onMessageReceived:  mqtt == robot ROBOT_UPDATE_ROBOT_INFO_INDEX");

                                            parseRobotInfo(findById.getRobot());
                                        }

                                        @Override
                                        public void onError(@NonNull Throwable e) {
                                            ULog.e(TAG, "onFailure: onMessageReceived:  mqtt == robot ROBOT_UPDATE_ROBOT_INFO_INDEX");
                                            mMqttManager.sendMqttResultFail(command);
                                            e.printStackTrace();
                                        }

                                        @Override
                                        public void onComplete() {

                                        }
                                    });
                        } else {
                            ULog.e(TAG, "mqtt   : localRobot is null");
                            mMqttManager.sendMqttResultFail(command);
                        }
                        break;
                    case MqttCommand.ROBOT_RAW_DATA_COLLECTION_STATE_INDEX:
                        //                    if
                        break;
                    case MqttCommand.AGING_TEST_INDEX:
                        switch (command.getAction()) { //agingTestChargerId
                            case MqttCommand.AGING_START_ACTION:
                                agingTestChargerId = (String) command.getValue();
                                if (getRobot() != null && !TextUtils.isEmpty(agingTestChargerId)) {
                                    setMode(MODE_AGING_TEST, "老化测试模式-老化测试mqtt");
                                    setRobotDirection(StmTask.MOVE_END,"21");
                                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                                    agingTestGoTOCharger = false;
                                    mMqttManager.sendMqttResultSuccess(command);
                                } else {
                                    mMqttManager.sendMqttResultFail(command);
                                }
                                break;
                            case MqttCommand.AGING_STOP_ACTION:
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("老化测试 停止 62"));
                                setMode(MODE_UN_KNOW, "正常模式-停止老化测试mqtt");
                                break;
                            default:
                                break;
                        }
                        mMqttManager.sendMqttResultSuccess(command);
                        break;
                    case MqttCommand.ROBOT_BATCH_PRODUCTION_INDEX_TYPE:
                        switch (command.getAction()) {
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_START_ACTION:
                                if (getRobot() != null) {
                                    MqttCommand commandBP = new MqttCommand();
                                    commandBP.setSource(getRobot().getId());
                                    commandBP.setTarget(productionClientId);
                                    commandBP.setType(MqttCommand.ROBOT_BATCH_PRODUCTION_INDEX_TYPE);

                                    setMode(MODE_BATCH_PRODUCTION_TEST, "量产测试模式-量产测试mqtt");
                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("量产测试 63"));
                                    setStmTarget(StmTask.TARGET_CANCEL,"13");
                                    AutoMoveManager.setChargerTarget = false;

                                    commandBP.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_START_ACTION);
                                    batch_production_test_power_bms_network = false;
                                    batch_production_test_wired_charging = false;
                                    batch_production_test_emergency_stop = false;
                                    batch_production_test_front_obstacle = false;
                                    batch_production_test_behind_obstacle = false;
                                    batch_production_test_audio_decibel = false;
                                    batch_production_test_rfid = false;
                                    batch_production_test_in_place = false;
                                    batch_production_test_wireless_charging = false;


                                    //                                if (getRobot().getDebug() == 1) {
                                    //                                    setMode(MODE_BATCH_PRODUCTION_TEST);
                                    //                                    stmExecute.executeTaskNonQueue(new StmTask().stopMove());
                                    //                                    stmExecute.executeTask(new StmTask().setTarget(StmTask.TARGET_CANCEL));
                                    //
                                    //                                    commandBP.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_START_ACTION);
                                    //                                    batch_production_test_power_bms_network = false;
                                    //                                    batch_production_test_wired_charging = false;
                                    //                                    batch_production_test_emergency_stop = false;
                                    //                                    batch_production_test_front_obstacle = false;
                                    //                                    batch_production_test_behind_obstacle = false;
                                    //                                    batch_production_test_audio_decibel = false;
                                    //                                    batch_production_test_rfid = false;
                                    //                                    batch_production_test_in_place = false;
                                    //                                    batch_production_test_wireless_charging = false;
                                    //                                } else {
                                    //                                    //回复未打开debug开关
                                    //                                    commandBP.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_SHOW_INFO_ACTION);
                                    //                                    commandBP.setValue("未打开debug开关");
                                    //                                }

                                    if (MqttManager.getInstance().isConnected()) {
                                        MqttManager.getInstance().publishMessage(commandBP);
                                    }
                                }
                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STOP_ACTION: //退出量产测试
                                setMode(MODE_UN_KNOW, "正常模式-退出量产测试mqtt");
                                stmExecute.executeTaskNonQueue(new StmTask().stopMove("退出量产测试 64"));
                                setStmTarget(StmTask.TARGET_CANCEL,"14");
                                AutoMoveManager.setChargerTarget = false;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_WIRED_CHARGING_ACTION:
                                test_wired_charging = true;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_WIRELESS_CHARGING_ACTION:
                                test_wireless_charging = true;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_1_3_ACTION: //开机
                                batch_production_test_power_bms_network = true;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_4_ACTION: //有线充电
                                batch_production_test_wired_charging = true;
                                test_wired_charging = false;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_5_ACTION: //急停按钮
                                batch_production_test_emergency_stop = true;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_9_10_ACTION: //分贝采集
                                batch_production_test_audio_decibel = true;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_11_ACTION: //rfid
                                batch_production_test_rfid = true;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_12_ACTION: //到位开关
                                batch_production_test_in_place = true;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            case MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_13_ACTION: //无线充电
                                batch_production_test_wireless_charging = true;
                                test_wireless_charging = false;
                                mMqttManager.sendMqttResultSuccess(command);

                                break;
                            default:
                                break;
                        }
                        break;
                    case MqttCommand.ROBOT_LEAVE_CHARGER_INDEX_TYPE:
                        //共用充电桩逻辑已取消
                        //                    if (getRobot() != null) {
                        //                        if (MODE == MODE_NAVIGATION_TARGET_NODE_WAIT) {
                        //                            if (command.getSource().equals(getRobot().getPreviousRobot())) { //前一个机器离开
                        //                                if (waitDirection == StmTask.MOVE_FRONT) { //正在前端等待
                        //                                    if (MqttCommand.ROBOT_LEAVE_TAIL_ACTION.equals(command.getAction())) {  //离开的是上一个机器人的尾端充电桩
                        //                                        //向前端回充电桩
                        //                                        if (isArrive) { //可以增加判断当前速度
                        //                                            setSpeed(UConstants.DEFAULT_GOTO_CHARGER_SPEED, SPEELD_lOG_TAG_36);
                        //                                        }
                        //                                        setMode(MODE_GOTO_CHARGER);
                        //                                        gotoChargerStepThree(StmTask.MOVE_FRONT);
                        //                                    }
                        //                                }
                        //                            } else if (command.getSource().equals(getRobot().getNextRobot())) {
                        //                                if (waitDirection == StmTask.MOVE_END) { //正在尾端等待
                        //                                    if (MqttCommand.ROBOT_LEAVE_HEAD_ACTION.equals(command.getAction())) {  //离开的是后一个机器人的前端充电桩
                        //                                        //向尾端回充电桩
                        //                                        if (isArrive) { //可以增加判断当前速度
                        //                                            setSpeed(UConstants.DEFAULT_GOTO_CHARGER_SPEED, SPEELD_lOG_TAG_37);
                        //                                        }
                        //                                        setMode(MODE_GOTO_CHARGER);
                        //                                        gotoChargerStepThree(StmTask.MOVE_END);
                        //                                    }
                        //                                }
                        //                            }
                        //                        }
                        //                    }
                        break;
                    case MqttCommand.ROBOT_REBOOT_INDEX_TYPE:
                        if (MqttCommand.ROBOT_ANDROID_API_REBOOT_ACTION.equals(command.getAction())) {
                            ULog.d(TAG, "收到mqtt Android自重启 _ ROBOT_ANDROID_API_REBOOT_ACTION");
                            //                            MainApp.from(mActivity).aLiLog.post("收到mqtt重启消息 _ ROBOT_ANDROID_API_REBOOT_ACTION");
                            mMqttManager.sendMqttResultSuccess(command);
                            try {
                                Thread.sleep(500);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            //                        PowerManager pm = (PowerManager) mActivity.getSystemService(Context.POWER_SERVICE);
                            //                        pm.reboot("");


                            RxBus.getInstance().post(new DeviceEvent(DeviceEvent.ACTION_REBOOT_ANDROID, "mqtt reboot " +
                                    "android , op:" + command.getSource()));
                        } else if (MqttCommand.ROBOT_STM_CONTROL_ANDROID_REBOOT_ACTION.equals(command.getAction())) {
                            ULog.d(TAG, "收到mqtt 断电重启 _ ROBOT_ANDROID_API_REBOOT_ACTION");
                            String timeStr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CHINA).format(new Date());
                            StorageCenter.getRobotStorage().putString(KeyConstant.Storage.LAST_REBOOT_REASON, "mqtt stm32 reboot android ,op:" + command.getSource());
                            StorageCenter.getRobotStorage().putString(KeyConstant.Storage.LAST_REBOOT_TRIGGER_TIME, timeStr);
                            StorageCenter.getRobotStorage().save();

                            //                            MainApp.from(mActivity).aLiLog.post("收到mqtt重启消息 _ ROBOT_STM_CONTROL_ANDROID_REBOOT_ACTION");
                            mMqttManager.sendMqttResultSuccess(command);

//                            stmExecute.executeTaskNonQueue(new StmTask().delayPowerOff());
                            try {
                                Thread.sleep(1500);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
//                            stmExecute.executeTask(new StmTask().stmRebootAndroid());
                            URootCmd.execRootCmdSilent("reboot -p");
                        } else if (MqttCommand.ROBOT_BMS_REBOOT_ACTION.equals(command.getAction())) {
                            if (mRobotType.getSubType() != RobotSubType.BZ) {
                                if(mCurrent >= 0 ){
                                    mMqttManager.sendMqttResultFail(command);
                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "机器人正在充电中,无法电池断电重启!");
                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                            MqttMsgCode.MSG_ROBOT_CHARGEING_CANNOT_BATTERY_POWER_OFF_RESTART, null);

                                }else{
                                    mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "机器人电池断电重启 指令执行成功!");
                                    mMqttManager.sendMqttResultSuccess(command);
                                    int time = 20;
                                    BaseBmsCommunicator.getInstance().enterPowerSaveMode(time, "MQTT-" + command.getSource());
                                }
                            }else{
                                mMqttManager.sendMqttResultFail(command);
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "", "该类型机器人不支持电池断电重启!");
                                mMqttManager.sendMessage(command.getSource(), MqttCommand.ROBOT_SHOW_INFO_INDEX, "",
                                        MqttMsgCode.MSG_THIS_TYPE_ROBOT_NONSUPPORT_BATTERY_POWER_OFF_RESTART, null);
                            }
                        }

                        break;
                    case MqttCommand.ROBOT_MOTOR_DRIVER_ENABLE_INDEX_TYPE:
                        stmExecute.executeTaskNonQueue(new StmTask().forceMotorDriveEnable());
                        mMqttManager.sendMqttResultSuccess(command);
                        break;
                    case MqttCommand.ROBOT_PUSH_STREAM_ROLLBACK_TYPE:
                        if (MqttCommand.ROBOT_PUSH_STREAM_ROLLBACK_ACTION.equals(command.getAction())) {
                            if (command.getValue() != null) {
                                long rollbackTime = Long.parseLong(String.valueOf(command.getValue()));
                                getWebCameraPusher().rollBackPush(rollbackTime);
                            }
                        }
                        break;
                    case MqttCommand.ROBOT_BELT_CONVEYOR_INDEX_TYPE:
                        //@焦浩康 任何巡检策略下,皮带机开机都应出去巡检,已删除对皮带机开启巡检策略的判断
                        if (MqttCommand.ROBOT_BELT_CONVEYOR_START_INDEX_ACTION.equals(command.getAction())) { //开始运转
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 1);
                            UPreferences.putLong(mActivity,
                                    UConstants.PREFERENCES_BELT_CONVEYOR_START_DATE_KEY,
                                    System.currentTimeMillis());
                            isBeltConveyorStart = true;
                            if ("1".equals((String) command.getValue())) {
                                inspectionUseAngleType = 1;//甲侧使用反向标定角度
                            } else if ("2".equals((String) command.getValue())) {
                                inspectionUseAngleType = 2;//乙侧使用正向标定角度
                            } else if (TextUtils.isEmpty((String) command.getValue())) {
                                inspectionUseAngleType = 0;//普通巡检 往尾端行驶使用正向标定角度  往前端行驶使用反向标定角度
                            }
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_INSPECTION_USE_ANGLE_TYPE_KEY, inspectionUseAngleType);
                            ULog.d(TAG,
                                    "onMessageReceived:  ==== 皮带机开始运转 = " + (mInspectionEnableThread == null ? "null" : mInspectionEnableThread.isAlive()));
                            if (getInspectEnableThreadNeedExec()) {
                                mInspectionEnableThread.start();
                            }
                        } else if (MqttCommand.ROBOT_BELT_CONVEYOR_STOP_INDEX_ACTION.equals(command.getAction())) {
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 0);
                            isBeltConveyorStart = false;
                            ULog.d(TAG, "onMessageReceived:  ==== 皮带机停止运转");
                            inspectionUseAngleType = 0;
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_INSPECTION_USE_ANGLE_TYPE_KEY, inspectionUseAngleType);
                            if (MODE != MODE_GOTO_CHARGER) {
                                autoMoveManager.gotoChargerCheck("mqtt皮带机停止运转_回充");
                            }
                        } else if (MqttCommand.ROBOT_CHECK_BELT_CONVEYOR_STATE_INDEX_ACTION.equals(command.getAction())) {
                            String val = (String) command.getValue();
                            if (!TextUtils.isEmpty(val)) {
                                if ("0".equals(val)) {
                                    //获取到皮带机关闭状态 更新状态 机器人不出去巡检
                                    ULog.d(TAG, "确认皮带机未开启，不巡检");
                                    isBeltConveyorStart = false;
                                } else if ("1".equals(val)) {
                                    //获取到皮带机开启状态 更新状态 机器人出去巡检
                                    isBeltConveyorStart = true;
                                    ULog.d(TAG, "确认皮带机开启，开始巡检");
                                    startInspection("确认皮带机开启，开始巡检");
                                }
                            }
                        }
                        if (MqttManager.getInstance().isConnected()) {
                            MqttCommand beltResult = new MqttCommand();
                            beltResult.setTarget(command.getSource());
                            beltResult.setSource(getRobot().getId());
                            beltResult.setType(command.getType());
                            beltResult.setAction(command.getAction());
                            beltResult.setValue(MqttCommand.ROBOT_RESULT_SUCCESS_VALUE);

                            mMqttManager.publishMessage(beltResult);
                            ULog.d(TAG, "onMessageReceived:  ==== 回复充电桩收到消息：" + command.getAction());
                        }
                    case MqttCommand.ROBOT_MANAGER_CHARGER_STATE_INDEX:
                        if (MqttCommand.ROBOT_MANAGER_OPEN_CHARGE_ACTION.equals(command.getAction())) {
                            if (command.getValue() != null && command.getValue().equals(MqttCommand.ROBOT_RESULT_SUCCESS_VALUE)) {
                                openChargeSuccess();
                                ULog.d(TAG, "onMessageReceived:  == 开始充电 成功");
                            }
                        } else if (MqttCommand.ROBOT_MANAGER_CLOSE_CHARGE_ACTION.equals(command.getAction())) {
                            if (command.getValue() != null && command.getValue().equals(MqttCommand.ROBOT_RESULT_SUCCESS_VALUE)) {
                                closeChargeSuccess();
                                ULog.d(TAG, "onMessageReceived:  == 结束充电 成功");
                            }
                        }
                        break;
                    case MqttCommand.ROBOT_MANAGER_DUSTING_STATE_INDEX:
                        if (MqttCommand.ROBOT_MANAGER_OPEN_DUSTING_ACTION.equals(command.getAction())) {
                            startDustingSuccess();
                            ULog.d(TAG, "onMessageReceived:  == 开始除尘 成功");
                        } else if (MqttCommand.ROBOT_MANAGER_CLOSE_DUSTING_ACTION.equals(command.getAction())) {
                            endDustingSuccess();
                            ULog.d(TAG, "onMessageReceived:  == 结束除尘 成功");
                        } else if (MqttCommand.ROBOT_MANAGER_DUSTING_FINISH_ACTION.equals(command.getAction())) {
                            ULog.d(TAG, "onMessageReceived:  == 充电桩 除尘 完成");
                            endDustingSuccess();
                        }
                        break;
                    case MqttCommand.ROBOT_ENVIRONMENTAL_TEMPERATURE_INDEX_TYPE:
                        if (command.getValue() != null) {
                            envTempeMap.put(command.getSource(), Float.parseFloat(String.valueOf(command.getValue())));
                            environmentalTemperature = Float.parseFloat(String.valueOf(command.getValue()));
                            ULog.d(TAG,"environmentalTemperature update 3 :"+environmentalTemperature);
                            if (environmentalTemperature != UConstants.UNKONW && environmentalTemperature != 0 && environmentalTemperature > -40 && environmentalTemperature < 100) {
                                setAirTmp(environmentalTemperature);
                            }
                        }
                        break;

                    case MqttCommand.ROBOT_STEER_ENGINE_CONTROL_TYPE:
                        ULog.d(TAG, "onMessageReceived:  ==== STEER_ENGINE_ANGLE == " + command.getValue());
                        //                    if (command.getValue() == null || TextUtils.isEmpty(String.valueOf(command.getValue())))
                        //                        break;
                        if (!MqttCommand.ROBOT_STEER_ENGINE_INIT_ACTION.equalsIgnoreCase(command.getAction()) && command.getValue() == null) {
                            break;
                        }
                        float angle = 90;
                        if (command.getValue() != null) {
                            angle = Float.parseFloat(String.valueOf(command.getValue()));
                        }

                        if (Float.isNaN(angle)) {
                            ULog.e(TAG, "ERROR: mqtt set steer angle NAN");
                            return;
                        }

                        if (!mBotInfoMgr.isHaveSteer() || !SteerController.getInstance().checkPermission()) {
                            mMqttManager.sendMqttResultFail(command, "舵机暂不可控，请稍后再试");
                            return;
                        }

                        switch (command.getAction()) {
                            case MqttCommand.ROBOT_STEER_ENGINE_INIT_ACTION:
                                //初始化舵机角度
                                SteerController.getInstance().setSteerAngle(15, 180, SteerControlTag.RESET_TO_INIT.getReason());
                                break;
                            case MqttCommand.ROBOT_STEER_ENGINE_FRONT_H_ACTION:
                                //                                setCheckTargetNodeAngle("angleH", angle);
                                SteerController.getInstance().setHAngle(angle, RobotSetSpeedLogTags.SPEELD_lOG_TAG_1);
                                break;
                            case MqttCommand.ROBOT_STEER_ENGINE_FRONT_V_ACTION:
                                //                                setCheckTargetNodeAngle("angleV", angle);
                                SteerController.getInstance().setVAngle(angle, RobotSetSpeedLogTags.SPEELD_lOG_TAG_2);
                                break;

                            case MqttCommand.ACTION_SET_STEER_ENGINE_ANGLE: {
                                List<String> params = JsonHelper.parseJson((String) command.getValue(),
                                        new TypeReference<List<String>>() {
                                        });
                                try {
                                    if (!CollectionUtils.isEmpty(params) && params.size() >= 2) {
                                        float angleH = Float.parseFloat(params.get(0));
                                        float angleV = Float.parseFloat(params.get(1));
                                        SteerController.getInstance().setSteerAngle(angleH, angleV, SteerControlTag.MANUAL.getReason());
                                    }
                                } catch (NumberFormatException e) {
                                    ULog.e(TAG, "mqtt steer angle error:" + command.getValue(), e);
                                    mMqttManager.sendMqttResultFail(command, "角度值错误，请重试！");
                                    return;
                                }
                            }
                            break;

/*                            case MqttCommand.ROBOT_STEER_ENGINE_BEHIND_H_ACTION:
                                setCheckTargetNodeBackAngle("angleH", angle);
                                setSteerEngineAngle(2, 1, angle, RobotSetSpeedLogTags.SPEELD_lOG_TAG_3);
                                break;
                            case MqttCommand.ROBOT_STEER_ENGINE_BEHIND_V_ACTION:
                                setCheckTargetNodeBackAngle("angleV", angle);
                                setSteerEngineAngle(2, 2, angle, RobotSetSpeedLogTags.SPEELD_lOG_TAG_4);
                                break;*/
                            default:
                                break;
                        }
                        mMqttManager.sendMqttResultSuccess(command);
                        break;
                    case MqttCommand.ROBOT_PUSH_STREAM_INDEX_TYPE:
                        ULog.d(TAG, "onMessageReceived:  ====== 111111 ");
                        MqttCommand commandPushType = new MqttCommand();
                        commandPushType.setType(MqttCommand.ROBOT_PUSH_STREAM_INDEX_TYPE);
                        commandPushType.setSource(getRobot().getId());
                        commandPushType.setTarget(command.getSource());
                        if (!irServiceIsAlive()) {
                            if (MqttManager.getInstance().isConnected()) {
                                commandPushType.setAction(MqttCommand.ROBOT_RESULT_FAIL_ACTION);
                                mMqttManager.publishMessage(commandPushType);
                            }
                            return;
                        }
                        ULog.d(TAG, "onMessageReceived:  ====== 222222 ");
                        pushCtrlIr(false);
                        if (MqttCommand.ROBOT_PUSH_STREAM_FRONT_INDEX_ACTION.equalsIgnoreCase(command.getAction())) {
                            irService.setCallbackType(1);
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_PUSH_TYPE_INDEX_KEY, 1);
                            pushType = 1;
                        } else if (MqttCommand.ROBOT_PUSH_STREAM_BEHIND_INDEX_ACTION.equalsIgnoreCase(command.getAction())) {
                            irService.setCallbackType(2);
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_PUSH_TYPE_INDEX_KEY, 2);
                            pushType = 2;
                        } else if (MqttCommand.ROBOT_PUSH_STREAM_NORMAL_INDEX_ACTION.equalsIgnoreCase(command.getAction())) {
                            irService.setCallbackType(0);
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_PUSH_TYPE_INDEX_KEY, 0);
                            pushType = 0;
                        }

                        ULog.d(TAG, "onMessageReceived:  ====== 3333333 ");
                        if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_ARR)) {
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_ARR, 10000);
                        }
                        ULog.d(TAG, "onMessageReceived:  ====== 4444444 ");
                        break;
                    case MqttCommand.ROBOT_FORCE_OFF_CHARGING_TYPE:
                        ULog.d(TAG, "onMessageReceived:  ====== 关闭重复上电 ");
                        if (command.getValue() != null) {
                            isCloseRepeatCharge = ((boolean) command.getValue());
                            UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_ROBOT_FORCE_CLOSE_CHARGING_KEY, isCloseRepeatCharge);
                            ULog.d(TAG,
                                    "onMessageReceived:  ====== 关闭重复上电 isForceOffCharging :" + isCloseRepeatCharge + ",inCharger :" + inCharger());
                            //判断isForceOffCharging (true:关闭重复上电  false:恢复上电)
                            if (isCloseRepeatCharge) {
                                //移除需要上电消息
                                if (mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
                                    mHandler.removeMessages(Msg.WHAT_START_CHARGING);
                                }
                            }
                            //                            else {
                            //                                //打开继电器
                            //                                stmExecute.executeTask(new StmTask().openCharge(1));
                            //                            }
                            //回复
                            mMqttManager.sendMqttResultSuccess(command);
                            //                        if (MqttCommand.mqttIsConnect) {
                            //                            MqttCommand forceOffCommand = new MqttCommand();
                            //                            forceOffCommand.setSource(getRobot().getId());
                            //                            forceOffCommand.setTarget(command.getSource());
                            //                            forceOffCommand.setType(command.getType());
                            //                            forceOffCommand.setAction(MqttCommand.ROBOT_RESULT_SUCCESS_ACTION);
                            //                            forceOffCommand.setValue(isForceOffCharging);
                            //                            mMqttManager.publishMessage(forceOffCommand);
                            //                        }
                        }
                        break;
                    case MqttCommand.ROBOT_IR_POSITION_AREA_INDEX_TYPE:
                        if (MqttManager.getInstance().isConnected()) {
                            MqttCommand areaCommand = new MqttCommand();
                            areaCommand.setSource(getRobot().getId());
                            areaCommand.setTarget(command.getSource());
                            areaCommand.setType(command.getType());
                            areaCommand.setAction(command.getAction());
                            areaCommand.setValue(mDistance);
                            mMqttManager.publishMessage(areaCommand);
                        }
                        break;
                    case MqttCommand.ROBOT_SLEEP_TYPE:
                        ULog.d(TAG, "onMessageReceived:  ====== 休眠 ");
                        removeHindranceRetryMsg();
                        mCmdAfterRoomOp = null;
                        isSleep = true;
                        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_ROBOT_SLEEP_KEY, isSleep);
                        //停止
                        stmExecute.executeTaskNonQueue(new StmTask().stopMove("休眠 65"));
                        if (!inCharger()) {
                            //回充电桩
                            autoMoveManager.gotoChargerCheck("mqtt待机_回充");
                        } else {
                            if (mBotInfoMgr.getRobotSubType() == RobotSubType.MA) {
                                if (CicadaRoomController.getInstance().haveRoom()) {
                                    boolean doorClosed = CicadaRoomController.getInstance()
                                            .getCurDorState() == CicadaRoomDoorState.CHARGING;
                                    if (!doorClosed) {
                                        CicadaRoomController.getInstance().controlDoor(CicadaRoomDoorState.CHARGING);
                                        if (!NumberUtil.notNullAndEqual(RobotInfoManager.getInstance()
                                                        .getRobotConfigParams()
                                                        .getIgnoreRoomControl(),
                                                UConstants.VALUE_SWITCH_STATUS_ON)) {
                                            mMqttManager.broadcastShowInfo("Room正在关门...");
                                            mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROOM_IS_CLOSING_DOOR);
                                        }
                                    }
                                }
                            }
                        }
                        //回复mqtt
                        mMqttManager.sendMqttResultSuccess(command);
                        break;
                    case MqttCommand.ROBOT_WAKE_UP_TYPE:
                        ULog.d(TAG, "onMessageReceived:  ====== 唤醒 ");
                        isSleep = false;
                        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_ROBOT_SLEEP_KEY, isSleep);
                        //回复mqtt
                        mMqttManager.sendMqttResultSuccess(command);
                        //                    if (MqttCommand.mqttIsConnect) {
                        //                        MqttCommand wakeUpCommand = new MqttCommand();
                        //                        wakeUpCommand.setSource(getRobot().getId());
                        //                        wakeUpCommand.setTarget(command.getSource());
                        //                        wakeUpCommand.setType(command.getType());
                        //                        wakeUpCommand.setAction(MqttCommand.ROBOT_RESULT_SUCCESS_ACTION);
                        //                        mMqttManager.publishMessage(wakeUpCommand);
                        //                    }
                        break;
                    case MqttCommand.ROBOT_SET_RFID_POWER_TYPE:
                        ULog.d(TAG, "onMessageReceived:  ====== 设置rfid功率 " + command.getValue());
                        if (command.getValue() != null) {
                            String power = (String) command.getValue();
                            if (!UString.isEmpty(power)) {
                                String regex = ",";
                                String[] split = power.split(regex);
                                if (split.length > 1 && !UString.isEmpty(split[0]) && !UString.isEmpty(split[1])) {
                                    int read = Integer.parseInt(split[0]);
                                    int write = Integer.parseInt(split[1]);

                                    RxBus.getInstance().toObservable(RfidEvent.class)
                                            .filter(event -> event.getAction() == RfidEvent.ACTION_WRITE_POWER_RESULT)
                                            .take(1)
                                            .subscribe(rfidEvent -> {
                                                ULog.i(TAG, "设置RFID功率结果：" + rfidEvent.isSuccess());
                                                if (rfidEvent.isSuccess()) {
                                                    mMqttManager.sendMqttResultSuccess(command);
                                                } else {
                                                    mMqttManager.sendMqttResultFail(command);
                                                }
                                            });
                                    ULog.d(TAG, "MQTT: 设置RFID功率 read = " + read + "  write = " + write);
                                    RfidController.getInstance().setPower(read, write, true);
                                }
                            }
                        }
                        break;
                    case MqttCommand.ROBOT_BATCH_PRODUCTION_SET_TARGET_TYPE:    //修改 productionClientId
                        setProductionClientId(command.getValue());
                        break;
                    /*case ROBOT_GET_CURRENT_NODE_INFO_TYPE:
                        if (ROBOT_GET_CURRENT_NODE_INFO_ACTION.equals(command.getAction())) {
                            ULog.i("jiao_test_get_current_node", "run: 获取当前节点" + mCurrentNode.getTag1());
                            sendMqttResult2(command, ROBOT_GET_CURRENT_NODE_INFO_ACTION, UGson.getGson().toJson(mCurrentNode));
                        }
                        break;*/
                    case MqttCommand.ROBOT_WEB_CAMERA_CONTROL_TYPE:
                        processWebCamControlCommand(command);
                        break;

                    case MqttCommand.ROBOT_INFRARED_CAMERA_POSITION_CONTROL_STATE_INDEX_TYPE:
                        //收到红外摄像头控制消息
                        switch (command.getAction()) {
                            case MqttCommand.ROBOT_INFRARED_CAMERA_SHOW_AREA:
                                ULog.d(TAG, "控制红外摄像头 === 显示标定框-");
                                mInfraredCameraIsShowArea = true;
                                UPreferences.putBoolean(getContext(), UConstants.KEY_INFRARED_CAMERA_IS_SHOW_AREA, true);
                                break;

                            case MqttCommand.ROBOT_INFRARED_CAMERA_HIDE_AREA:
                                ULog.d(TAG, "控制红外摄像头 === 隐藏标定框-");
                                mInfraredCameraIsShowArea = false;
                                UPreferences.putBoolean(getContext(), UConstants.KEY_INFRARED_CAMERA_IS_SHOW_AREA, false);
                                break;
                            default:
                                break;
                        }
                        break;

                    case MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE:
                        switch (command.getAction()) {
                            case MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_NO_ARUCO_ACTION:
                                //接收到mqtt消息后直接拍照 然后创建任务节点 不检测Aruco码
                                TaskNode taskNode1 = null;
                                try {
                                    String strTaskNodeJson = String.valueOf(command.getValue());
                                    taskNode1 = UGson.getGson().fromJson(strTaskNodeJson, TaskNode.class);
                                } catch (Exception e) {
                                    Log.e(TAG, "run: 解析TskNode出错");
                                    sendMqttResult2(command, command.getAction(), "解析任务节点json出错!");
                                }

                                if (taskNode1 != null) {
                                    takePhoto(2, taskNode1, command.getSource());
                                }
                                break;
                            case MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION:
                                //接收到mqtt消息后 创建任务节点 需要之前拍照检测Aruco码
                                checkArucoAccount = command.getSource();
                                if (checkArucoAccount == null) {
                                    return;
                                }
                                String value = command.getValue().toString();
                                if (takePhotoBytes != null && takePhotoBytes.length > 0 && taskNodeLocation != null) {
                                    TaskNode taskNode = null;
                                    try {
                                        taskNode = UGson.getGson().fromJson(value, TaskNode.class);
                                    } catch (Exception e) {
                                        ULog.d("ROBOT_IMAGE_CAPTRUE_TYPE:", e.getMessage());
                                    }
                                    String taskNodeName = command.getValue().toString();
                                    createTaskNodeGetWebCamFocusAndZoom(taskNodeName, checkArucoAccount, taskNode);
                                    checkArucoAccount = null;
                                } else {
                                    //通知手机端
                                    sendMqtt(robotId,
                                            checkArucoAccount,
                                            MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE,
                                            MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION,
                                            "请先检测Aruco码");
                                    checkArucoAccount = null;
                                }
                                break;
                            default:
                                break;
                        }
                        break;

                    case MqttCommand.TYPE_ROBOT_CONFIG:
                        processRobotConfigCommand(command);
                        break;

                    case MqttCommand.FillLight.TYPE_FILL_LIGHT_CONTROL:
                        processFillLightControlCommand(command);
                        break;

                    case MqttCommand.Rfid.TYPE_RFID_CONTROL:
                        processRfidMqttCommand(command);
                        break;

                    case MqttCommand.StmLog.TYPE_TRANSFER_STM_LOG:
                        processStmLogCommand(command);
                        break;

                    case MqttCommand.ROBOT_RESULT_TYPE: {
                        processResultCommand(command);
                    }
                    break;

	                case MqttCommand.Room.TYPE_ROOM:
						processRoomCommand(command);
						break;

                    default:
                        break;
                }
            } catch (Throwable tr) {
                ULog.e(TAG, "mqtt msg handle error", tr);
                mMqttManager.sendResultFail(command, MqttMsgCode.ERROR_COMMAND_ILLEGAL, null);
                CrashReport.postCatchedException(tr, Thread.currentThread());
            }
        }
    }

    /**
     * 获取机器人配置参数
     *
     * @return
     */
    public RobotConfigParams getRobotConfigParams() {
        return mBotInfoMgr.getRobotConfigParams();
    }

    /**
     * 设置手机或管理平台设置的摄像头偏移角度同步到 inspectManager.checkTargetNodeBack中
     *
     * @param angleH
     * @param angle
     */
    private void setCheckTargetNodeBackAngle(String angleH, float angle) {
        if (inspectManager == null || inspectManager.mCheckTargetNodeBack == null) {
            return;
        }
        String angleJson = inspectManager.mCheckTargetNodeBack.getAngleJson();
        if (StrUtil.isBlank(angleJson)) {
            return;
        }
        JSONObject jobj = JSON.parseObject(angleJson);
        if (jobj == null) {
            return;
        }
        jobj.put(angleH, angle);
        inspectManager.mCheckTargetNodeBack.setAngleJson(jobj.toJSONString());
        inspectManager.lastSpecialSwitchNodeTimeBack = System.currentTimeMillis();
    }

    /**
     * 设置手机或管理平台设置的摄像头偏移角度同步到 inspectManager.checkTargetNode中
     *
     * @param angleH
     * @param angle
     */
    private void setCheckTargetNodeAngle(String angleH, float angle) {
        if (inspectManager == null || inspectManager.mCheckTargetNode == null) {
            return;
        }
        String angleJson = inspectManager.mCheckTargetNode.getAngleJson();
        if (StrUtil.isBlank(angleJson)) {
            return;
        }
        JSONObject jobj = JSON.parseObject(angleJson);
        if (jobj == null) {
            return;
        }
        jobj.put(angleH, angle);
        inspectManager.mCheckTargetNode.setAngleJson(jobj.toJSONString());
        inspectManager.lastSpecialSwitchNodeTime = System.currentTimeMillis();
    }

	/**
	 * 处理Room控制指令
	 * @param mqttCommand 要处理的Mqtt消息
	 */
	private void processRoomCommand(MqttCommand mqttCommand) {
		switch (mqttCommand.getAction()) {
			case MqttCommand.Room.ACTION_CHANGE_TO_MANUAL_CONTROL: {
				if (RobotStatus.getIsChangingRoomControl()) {
					ULog.w("CicadaRoomController","change control source is procecssing now, ignore repeat request");
					return;
				}

				if (inCharger() || mDistance > 0.0f) {
					setMode(MODE_UN_KNOW, "正常模式-room切换到手动控制");
					stmExecute.executeTaskNonQueue(new StmTask().stopMove("room相关 切换到手动控制 66"));
					RobotStatus.setIsChangingRoomControl(true);
					RobotStatus.setIsWaitRoomDoorOpen(false);
					RobotStatus.setIsWaitRoomDoorClose(false);
					Message msg = mHandler.obtainMessage(Msg.WHAT_CHECK_AND_CHANGE_ROOM_TO_MANUAL_CONTROL, mqttCommand);
					mHandler.sendMessageDelayed(msg, 5000);
				} else {
					//在Room范围内，不允许切换
					mMqttManager.sendMqttResultFail(mqttCommand);
					mMqttManager.broadcastShowInfo(getString(R.string.robot_in_room_area_cannot_change_to_manual_control));
					mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_IN_ROOM_AREA_CANNOT_CHANGE_TO_MANUAL_CONTROL);
				}
			}
			break;

			case MqttCommand.Room.ACTION_CHANGE_TO_ROBOT_CONTROL: {
				RobotStatus.setIsChangingRoomControl(true);
				CicadaRoomController.getInstance().startCheckServerDoorState();
				Message msg = mHandler.obtainMessage(Msg.WHAT_CHECK_AND_CHANGE_ROOM_TO_ROBOT_CONTROL, mqttCommand);
				mHandler.sendMessageDelayed(msg, 5000);
			}
			break;

			default:
				break;
		}
	}

    /**
     * 处理配置机器人的MQTT指令
     *
     * @param mqttCommand
     */
    private void processRobotConfigCommand(MqttCommand mqttCommand) {

        switch (mqttCommand.getAction()) {
            case MqttCommand.ACTION_ROBOT_CHANGE_DIRECTION:
                ULog.d(TAG, "更换机器人方向，当前方向" + rfidDirection);
                stmExecute.executeTaskNonQueue(new StmTask().stopMove("更换机器人方向mqtt 67"));
                if (rfidReadType >= 0) {
                    stmExecute.executeTask(new StmTask().correctDistance(mDistance));
                }
                int tmpDir = 0;
                if (rfidDirection == 0) {
                    rfidDirection = 1;
                    tmpDir = 1;
                } else {
                    rfidDirection = 0;
                    tmpDir = -1;
                }

                stmExecute.executeTask(new StmTask().setRFIDDirection(tmpDir,"mqtt主动改电机方向"));
                UPreferences.putInt(mActivity, UConstants.ACTION_ROBOT_RFID_DIRECTION_ACTION, rfidDirection);
                StmTask.updateDirection(rfidDirection,"q4");
                if(MODE == MODE_AUTO_BUILD_MAP){
                    AutoBuildRfidMapManager.getInstance().makeTagForRFIDDirection();
                }
                mMqttManager.sendMqttResultSuccess(mqttCommand);
                break;
        }
    }

    /**
     * 处理补光灯控制指令
     *
     * @param mqttCommand
     */
    private void processFillLightControlCommand(MqttCommand mqttCommand) {
        ULog.d(TAG, "补光灯控制：" + mqttCommand.getAction());
        switch (mqttCommand.getAction()) {
            case MqttCommand.FillLight.ACTION_READ_FILL_LIGHT_LEVEL: {
                RxBus.getInstance().toObservable(FillLightEvent.class)
                        .filter(event -> event.getAction() == FillLightEvent.EVENT_READ_FILL_LIGHT_LEVEL_RESULT)
                        .observeOn(Schedulers.io())
                        .take(1)
                        .subscribe(event -> {
                            mMqttManager.sendMqttResultSuccess(mqttCommand, event.getValue());
                        });
                FillLightController.getInstance().getFillLightLevel();
            }

            break;

            case MqttCommand.FillLight.ACTION_SET_FILL_LIGHT_LEVEL: {
                if (FillLightController.getInstance().getFillLightSwitchMode() == FillLightSwitchMode.MODE_DEBUG) {
                    try {
                        int setLevel = Integer.parseInt((String) mqttCommand.getValue());
                        RxBus.getInstance().toObservable(FillLightEvent.class)
                                .filter(event -> event.getAction() == FillLightEvent.EVENT_SET_FILL_LIGHT_LEVEL_RESULT)
                                .observeOn(Schedulers.io())
                                .take(1)
                                .subscribe(event -> {
                                    mMqttManager.sendMqttResultSuccess(mqttCommand, event.getValue());
                                });
                        FillLightController.getInstance().setFillLightLevel(setLevel);
                    } catch (NumberFormatException e) {
                        e.printStackTrace();
                    }
                } else {
                    mMqttManager.sendMqttResultFail(mqttCommand, "未开启调试模式时不能设置补光灯强度");
                }
            }

            break;

            case MqttCommand.FillLight.ACTION_READ_FILL_LIGHT_CHANGE_RATE: {
                RxBus.getInstance().toObservable(FillLightEvent.class)
                        .filter(event -> event.getAction() == FillLightEvent.EVENT_READ_FILL_LIGHT_CHANGE_RATE_RESULT)
                        .observeOn(Schedulers.io())
                        .take(1)
                        .subscribe(event -> {
                            mMqttManager.sendMqttResultSuccess(mqttCommand, event.getValue());
                        });
                FillLightController.getInstance().getFillLightChangeRate();
            }

            break;

            case MqttCommand.FillLight.ACTION_SET_FILL_LIGHT_CHANGE_RATE: {
                try {
                    int changeRate = Integer.parseInt((String) mqttCommand.getValue());

                    RxBus.getInstance().toObservable(FillLightEvent.class)
                            .filter(event -> event.getAction() == FillLightEvent.EVENT_SET_FILL_LIGHT_CHANGE_RATE_RESULT)
                            .observeOn(Schedulers.io())
                            .take(1)
                            .subscribe(event -> {
                                mMqttManager.sendMqttResultSuccess(mqttCommand, event.getValue());
                            });
                    FillLightController.getInstance().setFillLightChangeRate(changeRate);
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                }
            }

            break;

            case MqttCommand.FillLight.ACTION_READ_PHOTOSENSITIVE_SAMPLING_VALUE: {
                mMqttManager.sendMqttResultSuccess(mqttCommand, FillLightController.getInstance().getPhotosensitiveAdcValue());
            }

            break;

            case MqttCommand.FillLight.ACTION_START_FILL_LIGHT_DEBUG_MODE:
                FillLightController.getInstance().setFillLightMode(FillLightSwitchMode.MODE_DEBUG);
                mMqttManager.sendMqttResultSuccess(mqttCommand);
                break;

            case MqttCommand.FillLight.ACTION_STOP_FILL_LIGHT_DEBUG_MODE:
                FillLightController.getInstance().setFillLightMode(FillLightSwitchMode.MODE_AUTO);
                mMqttManager.sendMqttResultSuccess(mqttCommand);
                break;

            default:
                break;
        }
    }

    /**
     * 处理RFID 控制相关的mqtt指令
     *
     * @param command
     */
    private void processRfidMqttCommand(MqttCommand command) {
        switch (command.getAction()) {
            case MqttCommand.Rfid.ACTION_READ_RFID_DATA:
                command.setTimeStamp(System.currentTimeMillis());
                RxBus.getInstance().toObservable(RfidEvent.class)
                        .filter(event -> event.getAction() == RfidEvent.ACTION_READ_RFID_TAG_RESULT || event.getAction() == RfidEvent.ACTION_RECEIVED_RFID_TAG)
                        .observeOn(Schedulers.io())
                        .take(1)
                        .subscribe(event -> {
                            long currentTimeInMills = System.currentTimeMillis();
                            if (currentTimeInMills - command.getTimeStamp() <= 10_000) {
                                mMqttManager.sendMqttResultSuccess(command, event.getEpc());
                            }
                        });

                RfidController.getInstance().queryTagOnce(3000);
                break;

            case MqttCommand.Rfid.ACTION_WRITE_RFID_DATA:

                break;

            default:
                break;
        }
    }


    /**
     * 处理网络摄像头控制相关指令
     *
     * @param command
     */
    private void processWebCamControlCommand(MqttCommand command) {
        ULog.d(TAG, "mqtt网络摄像头控制");
        switch (command.getAction()) {
            //恢复网络摄像头默认图像配置
            case MqttCommand.ROBOT_WEB_CAMERA_RESET_IMAGE_SETTINGS_ACTION:
                try {
                    WebCamManager.getInstance().getImageSettingsInfo()
                            .subscribe(new NextObserver<String>() {
                                @Override
                                public void onNext(@NonNull String String) {
                                    sendMqttResult2(command, MqttCommand.ROBOT_WEB_CAMERA_RESET_IMAGE_SETTINGS_ACTION, "恢复网络摄像头默认图像配置成功!");
                                }

                                @Override
                                public void onError(@NonNull Throwable e) {
                                    super.onError(e);
                                    sendMqttResult2(command, MqttCommand.ROBOT_WEB_CAMERA_RESET_IMAGE_SETTINGS_ACTION, "恢复网络摄像头默认图像配置失败!");
                                }
                            });
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                    sendMqttResult2(command, MqttCommand.ROBOT_WEB_CAMERA_GET_SETTINGS_INFO_ACTION, e.getMessage());
                }
                break;
            //获取图像等基础参数信息
            case MqttCommand.ROBOT_WEB_CAMERA_GET_SETTINGS_INFO_ACTION:
                try {
                    WebCamManager.getInstance().getImageSettingsInfo()
                            .subscribe(new NextObserver<String>() {
                                @Override
                                public void onNext(@NonNull String String) {
                                    sendMqttResult2(command, MqttCommand.ROBOT_WEB_CAMERA_GET_SETTINGS_INFO_ACTION, String);
                                }

                                @Override
                                public void onError(@NonNull Throwable e) {
                                    super.onError(e);
                                    sendMqttResult2(command, MqttCommand.ROBOT_WEB_CAMERA_GET_SETTINGS_INFO_ACTION, e.getMessage());
                                }
                            });
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                    sendMqttResult2(command, MqttCommand.ROBOT_WEB_CAMERA_GET_SETTINGS_INFO_ACTION, e.getMessage());
                }
                break;
            //设置机器人网络摄像头 最大自动快门
            case ROBOT_WEB_CAMERA_SETTING_MAX_SHUTTER_ACTION: {
                String maxShutterArg = (String) command.getValue();
                try {
                    Integer maxSpeed = Integer.parseInt(maxShutterArg);
                    WebCamManager.getInstance().setMaxShutterSpeed(maxSpeed)
                            .subscribe(new NextObserver<ResponseBody>() {
                                @Override
                                public void onNext(@NonNull ResponseBody responseBody) {
                                    sendMqttResult2(command, ROBOT_WEB_CAMERA_SETTING_MAX_SHUTTER_ACTION, command.getValue());
                                }

                                @Override
                                public void onError(@NonNull Throwable e) {
                                    super.onError(e);
                                    sendMqttResult2(command, ROBOT_WEB_CAMERA_SETTING_MAX_SHUTTER_ACTION, null);

                                }
                            });
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                }
            }
            break;

            //设置机器人网络摄像头 最小自动快门
            case ROBOT_WEB_CAMERA_SETTING_MIN_SHUTTER_ACTION: {
                String minShutterArg = (String) command.getValue();
                try {
                    Integer minSpeed = Integer.parseInt(minShutterArg);
                    WebCamManager.getInstance().setMinShutterSpeed(minSpeed)
                            .subscribe(new NextObserver<ResponseBody>() {
                                @Override
                                public void onNext(@NonNull ResponseBody responseBody) {
                                    sendMqttResult2(command, ROBOT_WEB_CAMERA_SETTING_MIN_SHUTTER_ACTION, command.getValue());
                                }

                                @Override
                                public void onError(@NonNull Throwable e) {
                                    super.onError(e);
                                    sendMqttResult2(command, ROBOT_WEB_CAMERA_SETTING_MIN_SHUTTER_ACTION, null);

                                }
                            });
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                }
            }
            break;

            //手机端发送mqtt获取 网络摄像头变焦和变倍
            case ROBOT_WEB_CAMERA_REFRESH_FOCUS_AND_ZOOM_ACTION: {
                WebCamManager.getInstance().getZoomAndFocus()
                        .subscribe(new NextObserver<Map<String, Float>>() {
                            @Override
                            public void onNext(@NonNull Map<String, Float> stringIntegerMap) {
                                Float zoomPos = stringIntegerMap.get("zoom_pos");
                                Integer focusPos = UConstants.FloatToInteger(stringIntegerMap.get("focus_pos"));

                                ULog.d(TAG, "网络摄像头 变焦和变倍的值 getZoomAndFocus === zoompos:" + zoomPos + " focuspos:" + focusPos);
                                WebCameraArgumentBean webCameraArgumentBean = new WebCameraArgumentBean();
                                webCameraArgumentBean.setZoompos(zoomPos);
                                webCameraArgumentBean.setFocuspos(focusPos);
                                sendMqttResult2(command,
                                        ROBOT_WEB_CAMERA_REFRESH_FOCUS_AND_ZOOM_ACTION,
                                        UGson.getGson().toJson(webCameraArgumentBean));
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                super.onError(e);
                                ULog.d(TAG, "网络摄像头 变焦和变倍的值 onSettingFailure === e:" + e);
                                boolean isRet = checkWebCameraIsOnLine(e.getMessage(), () -> processWebCamControlCommand(command));
                                if (!isRet) {
                                    sendMqttResult2(command, ROBOT_WEB_CAMERA_REFRESH_FOCUS_AND_ZOOM_ACTION, null);
                                }
                            }
                        });
            }
            break;

            //保存当前网络摄像头 变焦和变倍信息到 当前节点中
            //TODO 暂时没地方用了 删除掉相关逻辑 相对应手机端一些逻辑也删除下?  to be removed
            case ROBOT_WEB_CAMERA_SAVE_FOCUS_AND_ZOOM_ACTION: {
                if (command.getValue() != null) {
                    WebCameraArgumentBean webCameraArgumentBean = UGson.getGson().fromJson((String) command.getValue(),
                            WebCameraArgumentBean.class);
                    inspectManager.saveWebcamAges(command, webCameraArgumentBean, 1);
                } else {
                    sendMqttResult2(command, ROBOT_WEB_CAMERA_SAVE_FOCUS_AND_ZOOM_ACTION, null);
                }
            }
            break;

            //设置网络摄像头聚焦模式
            case ROBOT_WEB_CAMERA_SET_FOCUS_MODE_ACTION: {
                int mode = NumberUtil.parseInt((String) command.getValue(), -1);
                if (mode == -1) {
                    mMqttManager.sendMqttResultFail(command);
                } else {
                    WebCamManager.getInstance().setFocusMode(mode)
                            .subscribe(new NextObserver<Map<String, String>>() {
                                @Override
                                public void onNext(@NonNull Map<String, String> stringStringMap) {
                                    sendMqttResult2(command, ROBOT_WEB_CAMERA_SET_FOCUS_MODE_ACTION, command.getValue());
                                }

                                @Override
                                public void onError(@NonNull Throwable e) {
                                    super.onError(e);
                                    sendMqttResult2(command, ROBOT_WEB_CAMERA_SET_FOCUS_MODE_ACTION, null);
                                }
                            });
                }
            }
            break;

            //设置网络摄像头 焦距 value 值
            case ROBOT_WEB_CAMERA_SETTING_FOCAL_VALUE_ACTION: {
                try {
                    int focus = NumUtil.parseInt(command.getValue());
                    WebCamManager.getInstance().setZoomPos(focus)
                            .subscribe(new NextErrorObserver<Map<String, Float>>() {
                                @Override
                                public void onNext(@NonNull Map<String, Float> resultMap) {
                                    Integer focus = UConstants.FloatToInteger(resultMap.get("focus_pos"));
                                    mMqttManager.sendMqttResultSuccess(command, focus);
                                }

                                @Override
                                public void onError(@NonNull Throwable e) {
                                    mMqttManager.sendMqttResultFail(command);
                                }
                            });
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                    mMqttManager.sendMqttResultFail(command);
                }
            }
            break;

            //设置网络摄像头 变倍 value 值
            case ROBOT_WEB_CAMERA_SETTING_RANGE_VALUE_ACTION: {
                try {
                    int zoom = NumUtil.parseInt(command.getValue());
                    WebCamManager.getInstance().setZoomPos(zoom)
                            .subscribe(new NextErrorObserver<Map<String, Float>>() {
                                @Override
                                public void onNext(@NonNull Map<String, Float> valuesMap) {
                                    Float zoomPos = valuesMap.get("zoom_pos");
                                    mMqttManager.sendMqttResultSuccess(command, zoomPos);
                                }

                                @Override
                                public void onError(@NonNull Throwable e) {
                                    mMqttManager.sendMqttResultFail(command);
                                }
                            });
                } catch (NumberFormatException e) {
                    e.printStackTrace();
                    mMqttManager.sendMqttResultFail(command);
                }
            }
            break;

            //设置网络摄像头 焦距&变倍 value 值
            case ROBOT_WEB_CAMERA_SETTING_FOCAL_AND_RANGE_VALUE_ACTION: {
                if (command.getValue() != null && !TextUtils.isEmpty((String) command.getValue())) {
                    String val = (String) command.getValue();
                    WebCameraArgumentBean webCameraArgumentBean = UGson.getGson().fromJson(val, WebCameraArgumentBean.class);
                    if (webCameraArgumentBean.getFocuspos() != null && webCameraArgumentBean.getZoompos() != null) {
                        WebCamManager.getInstance().setZoomAndFocus(webCameraArgumentBean.getZoompos(),
                                        webCameraArgumentBean.getFocuspos())
                                .subscribe(new NextErrorObserver<Map<String, Float>>() {
                                    @Override
                                    public void onNext(@NonNull Map<String, Float> resultMap) {
                                        Integer focusPos = UConstants.FloatToInteger(resultMap.get("focus_pos"));
                                        Float zoomPos = resultMap.get("zoom_pos");

                                        WebCameraArgumentBean webCameraArgumentBean = new WebCameraArgumentBean();
                                        webCameraArgumentBean.setFocuspos(focusPos);
                                        webCameraArgumentBean.setZoompos(zoomPos);
                                        sendMqttResult2(command,
                                                ROBOT_WEB_CAMERA_SETTING_FOCAL_AND_RANGE_VALUE_ACTION,
                                                UGson.getGson().toJson(webCameraArgumentBean));
                                    }

                                    @Override
                                    public void onError(@NonNull Throwable e) {
                                        mMqttManager.sendMqttResultFail(command);
                                    }
                                });
                    } else {
                        mMqttManager.sendMqttResultFail(command);
                    }

                } else {
                    mMqttManager.sendMqttResultFail(command);
                }
            }

            break;


            case MqttCommand.ROBOT_WEB_CAMERA_FOCAL_ADD_ACTION: {
                WebCamManager.getInstance().focusAdd()
                        .subscribe(new NextErrorObserver<String>() {
                            @Override
                            public void onNext(@NonNull String resStr) {
                                mMqttManager.sendMqttResultSuccess(command);
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                mMqttManager.sendMqttResultFail(command);
                            }
                        });
            }

            break;

            case MqttCommand.ROBOT_WEB_CAMERA_FOCAL_SUBTRACT_ACTION: {
                WebCamManager.getInstance().focusSubtract()
                        .subscribe(new NextErrorObserver<String>() {
                            @Override
                            public void onNext(@NonNull String resStr) {
                                mMqttManager.sendMqttResultSuccess(command);
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                mMqttManager.sendMqttResultFail(command);
                            }
                        });

            }
            break;

            case MqttCommand.ROBOT_WEB_CAMERA_RANGE_ADD_ACTION: {
                WebCamManager.getInstance().zoomAdd()
                        .subscribe(new NextErrorObserver<String>() {
                            @Override
                            public void onNext(@NonNull String resStr) {
                                mMqttManager.sendMqttResultSuccess(command);
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                mMqttManager.sendMqttResultFail(command);
                            }
                        });
            }
            break;

            case MqttCommand.ROBOT_WEB_CAMERA_RANGE_SUBTRACT_ACTION: {
                WebCamManager.getInstance().zoomSubtract()
                        .subscribe(new NextErrorObserver<String>() {
                            @Override
                            public void onNext(@NonNull String resStr) {
                                mMqttManager.sendMqttResultSuccess(command);
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                mMqttManager.sendMqttResultFail(command);
                            }
                        });
            }
            break;

            case MqttCommand.WebCamera.ACTION_OPEN_NIGHT_VISION_MODE: {
                WebCamManager.getInstance().changeNightVisionMode(true)
                        .subscribe(new NextErrorObserver<String>() {
                            @Override
                            public void onNext(@NonNull String s) {
                                mMqttManager.sendMqttResultSuccess(command);
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                mMqttManager.sendMqttResultFail(command);
                            }
                        });
            }
            break;

            case MqttCommand.WebCamera.ACTION_CLOSE_NIGHT_VISION_MODE: {
                WebCamManager.getInstance().changeNightVisionMode(false)
                        .subscribe(new NextErrorObserver<String>() {
                            @Override
                            public void onNext(@NonNull String s) {
                                mMqttManager.sendMqttResultSuccess(command);
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                mMqttManager.sendMqttResultFail(command);
                            }
                        });
            }
            break;


            case MqttCommand.ROBOT_WEB_CAMERA_GET_FOCUS_MODE_ACTION: {
                WebCamManager.getInstance().getFocusMode()
                        .subscribe(new NextErrorObserver<String>() {
                            @Override
                            public void onNext(@NonNull String s) {
                                sendMqttResult2(command, MqttCommand.ROBOT_WEB_CAMERA_GET_FOCUS_MODE_ACTION, s);
                                mMqttManager.sendMqttResultSuccess(command);
                            }

                            @Override
                            public void onError(@NonNull Throwable e) {
                                ULog.e(TAG, "网络摄像头 聚焦模式 onError === e:" + e.getMessage());
                                mMqttManager.sendMqttResultFail(command, "获取网络摄像头聚焦模式失败!");
                            }
                        });
            }
            break;

            default:
                break;
        }
    }
    long userControlTime;
    private void userControlHandler(MqttCommand command) {
        if (command.getSource() != null && command.getSource().contains("self")) {
            return;
        }
        if (command.getAction() != null && command.getAction().contains("COKE_OVEN")) return; //包含焦炉的不算
        boolean isUserControl = false;
        switch(command.getType()) {
            case MqttCommand.ROBOT_MOVE_STATE_INDEX_TYPE:
            case MqttCommand.ROBOT_INSPECTION_INDEX_TYPE:
            case MqttCommand.ROBOT_SLEEP_TYPE:
            case MqttCommand.ROBOT_IR_PUT_TEXT_TYPE:
            case MqttCommand.ROBOT_SPEED_STATE_INDEX_TYPE:
            case MqttCommand.ROBOT_OBSTACLE_STATE_INDEX:
            case MqttCommand.ROBOT_MOTOR_DRIVER_ENABLE_INDEX_TYPE:
            case MqttCommand.ROBOT_STEER_ENGINE_CONTROL_TYPE:
            case MqttCommand.ROBOT_WEB_CAMERA_CONTROL_TYPE:
            case MqttCommand.ROBOT_WAKE_UP_TYPE:
            case MqttCommand.ROBOT_INFRARED_CAMERA_POSITION_CONTROL_STATE_INDEX_TYPE:
            case MqttCommand.ROBOT_REBOOT_INDEX_TYPE:
            case MqttCommand.ROBOT_REBOOT_STM_INDEX_TYPE:
                isUserControl = true;
        }
        if (!isUserControl && command.getAction() != null) {
            switch (command.getAction()) {
                case MqttCommand.ROBOT_ENTER_AUTO_BUILD_MAP_ACTION:
                case MqttCommand.ROBOT_START_AUTO_BUILD_MAP_ACTION:
                case MqttCommand.ROBOT_AUTO_BUILD_MAP_SYNC_DATA_ACTION:
                case MqttCommand.ROBOT_START_TO_FRONT_AUTO_BUILD_MAP_ACTION:
                case MqttCommand.ROBOT_QUIT_AUTO_BUILD_MAP_ACTION:
                case MqttCommand.ROBOT_STOP_AUTO_BUILD_MAP_ACTION:
                case MqttCommand.ROBOT_CONTINUE_AUTO_BUILD_MAP_ACTION:
                    isUserControl = true;
            }
        }

        if (isUserControl) {
            userControlTime = System.currentTimeMillis();
            ULog.d(TAG, "user_control " + command.getSource() + " type " + command.getType() + " action " + command.getAction() + " value " + command.getValue());
            if (moveHinderNeedSleep) {
                moveHinderNeedSleep = false;
                moveHinderLowPower = true;
                moveHinderNetDisconnect = true;
                UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_LOW_POWER_GO_CHARGER_KEY, true);
                UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NET_DISCONNECT_GO_CHARGER_KEY, true);
                UPreferences.putBoolean(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_NEED_SLEEP_KEY, moveHinderNeedSleep);
                sleepTimeMoveHinder = 0;
                UPreferences.putInt(MainApp.getInstance(), UConstants.PREFERENCE_MOVE_HINDER_SLEEP_TIME_KEY, sleepTimeMoveHinder);
            }
            if (mHandler.hasMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE)) {
                mHandler.removeMessages(Msg.WHAT_NOTIFY_STM_ENTER_POWER_SAVE_MODE);
            }
        }
    }
    //移除巡检的重试消息
    private void removeRetryInspectMsg() {
        mHandler.removeMessages(Msg.WHAT_COKE_OVEN_INSPECT);
        mHandler.removeMessages(Msg.WHAT_RGB_RECOGNITION_INSPECT);
        mHandler.removeMessages(Msg.WHAT_RECORD_VIDEO_RECOGNITION_INSPECT);
    }
    private void execStopMove(String tag) {
        mLastCleanDeviceTimestamp = 0L;
        mMotorAlertCount = 0;
        saveLastOpenDustingTimestamp(0L);
        mCmdAfterRoomOp = null;
        RobotStatus.setIsWaitRoomDoorClose(false);
        RobotStatus.setIsWaitRoomDoorOpen(false);

        //移除堵转后30分钟重试的消息
        mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);
        removeRetryInspectMsg();
        //移除堵转反方向移动的消息
        if(mHandler.hasMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD)){
            mHandler.removeMessages(Msg.WHAT_MOTOR_OVER_CURRENT_BACKWARD);
        }

        mHandler.removeMessages(Msg.WHAT_SELF_CYCLE_CLEAN_END_HANDLE);
        ULog.d(TAG,"RgbSharpnessChecker_TEST 移除倒计时1");
        clearMotorOverCurrentFlags();
        //                            mMotorSlipCount = 0;
        inspectManager.clearInspectTargetInfo();
        //复位烟雾异常前的模式存储
        mRobotModeBeforeSmokeException = MODE_UN_KNOW;

        if (mHandler.hasMessages(Msg.WHAT_START_INSPECTION)) {
            mHandler.removeMessages(Msg.WHAT_START_INSPECTION);
        }
        if (MODE != MODE_BATCH_PRODUCTION_TEST && MODE != MODE_AUTO_BUILD_MAP) {
            setMode(MODE_UN_KNOW, "正常模式-停止指令");
        }
        setRobotActionCode(RobotActionCode.MOVE_STOPPED);
        setStmTarget(StmTask.TARGET_CANCEL,"15");
        AutoMoveManager.setChargerTarget = false;
        stmExecute.executeTaskNonQueue(new StmTask().stopMove(tag+" execStopMove 68"));
        if (MODE != MODE_AUTO_BUILD_MAP) {
            setSpeed(UConstants.DEFAULT_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_28);
        }
        if (getRobot() != null && (getRobot().getChargeStatus() == ChargerStatus.GOTO_CHARGE_END || getRobot().getChargeStatus() == ChargerStatus.GOTO_CHARGE_FRONT)) {
            updateChargeStatus(ChargerStatus.NOT_IN_CHARGER);
        }
        autoMoveManager.cancelRoomIgnoreChargeNotice();
        ULog.d(TAG, "onMessageReceived:  ====== stop 停止 01 07");
    }

    /**
     * 处理下位机日志传输相关指令
     *
     * @param command
     */
    private void processStmLogCommand(MqttCommand command) {
        if (TextUtils.isEmpty(command.getAction())) {
            return;
        }

        switch (command.getAction()) {
            case MqttCommand.StmLog.ACTION_START_TRANSFER: {
                if (!isSleep) {
                    mMqttManager.sendMqttResultFail(command, "非待机状态下不允许传输下位机日志");
                    return;
                }
                StmLogRequest params = JsonHelper.parseJson(String.valueOf(command.getValue()),
                        StmLogRequest.class);
                if (params == null) {
                    ULog.e(TAG, "stm log time bound error");

                    return;
                }
                execStopMove("处理下位机日志传输相关指令");
                mHandler.postDelayed(() -> {
                    StmLogHelper.getInstance().startTransferLog(params.getStartTimeInSeconds(), params.getEndTimeInSeconds());
                }, 1000);
                mMqttManager.sendMqttResultSuccess(command);
            }
            break;

            case MqttCommand.StmLog.ACTION_END_TRANSFER:
                StmLogHelper.getInstance().stopTransferLog();
                mMqttManager.sendMqttResultSuccess(command);
                break;

            case MqttCommand.StmLog.ACTION_QUERY_STATUS:
                mMqttManager.sendMqttResultSuccess(command, new Gson().toJson(StmLogHelper.getInstance().getTransferStatus()));
                break;

            default:
                break;
        }
    }


    private void processResultCommand(MqttCommand command) {
        if (MqttCommand.RECLAIMER_TYPE.equals(command.getOriginalType())) {
            ReclaimerInspection.getInstance(this).mqttResultProcess(command);
            return;
        }
        if (MqttCommand.ROBOT_RESULT_SUCCESS_ACTION.equals(command.getAction())) {
            //指令执行成功
            switch (command.getOriginalType()) {
                case MqttCommand.ROBOT_INSPECTION_INDEX_TYPE:
                    switch (command.getOriginalAction()) {
                        case MqttCommand.ROBOT_INSPECTION_START_RGB_RECOGNISE_ACTION:
                            ULog.d(TAG, "rgb_recognise rgb上传文件巡检识别开启");
                            isServerStartRecogniseRGB = true;
                            startInspection(robotDirection,"rgb上传文件巡检识别开启");
                            break;
                        case MqttCommand.ROBOT_INSPECTION_STOP_RGB_RECOGNISE_ACTION:
                            ULog.d(TAG, "rgb_recognise rgb上传文件巡检识别停止");
                            isServerStartRecogniseRGB = false;
                            break;
                        case MqttCommand.ROBOT_RECORD_VIDEO_RECOGNISE_ACTION:
                            ULog.d(TAG, "recordVideo_recognise rgb上传文件 自动识别标定开启");
                            isServerStartRecordVideoRecog = true;
                            startInspection(robotDirection,"rgb上传文件 自动识别标定开启");
                            break;
                    }
                    break;
                case MqttCommand.ROBOT_MANAGER_DUSTING_STATE_INDEX: {
                    switch (command.getOriginalAction()) {
                        case MqttCommand.ROBOT_MANAGER_OPEN_DUSTING_ACTION:
                            startDustingSuccess();
                            break;

                        case MqttCommand.ROBOT_MANAGER_CLOSE_DUSTING_ACTION:
                            endDustingSuccess();
                            break;

                        default:
                            break;
                    }
                }
                break;
                case MqttCommand.ROBOT_MANAGER_CHARGER_STATE_INDEX: {
                    switch (command.getOriginalAction()) {
                        case MqttCommand.ROBOT_MANAGER_OPEN_CHARGE_ACTION:
                            openChargeSuccess();
                            break;
                        case MqttCommand.ROBOT_MANAGER_CLOSE_CHARGE_ACTION:
                            closeChargeSuccess();
                            break;
                    }
                }
                break;
                case MqttCommand.CHARGER_TEMPERATURE_CONTROL_TYPE:
                    int tempStatus = 0;
                    switch (command.getOriginalAction()) {
                        case MqttCommand.CHARGER_TEMPERATURE_CONTROL_OPEN_HEATER_ACTION:
                            chargerControlStatus = 0;
                            tempStatus = Msg.WHAT_OPEN_HEATER;
                            currentChargerControlStatus = tempStatus;
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_TEMPERATURE_CONTROL_STATUS, tempStatus);
                            break;
                        case MqttCommand.CHARGER_TEMPERATURE_CONTROL_CLOSE_HEATER_ACTION:
                            chargerControlStatus = 0;
                            tempStatus = Msg.WHAT_CLOSE_HEATER;
                            currentChargerControlStatus = tempStatus;
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_TEMPERATURE_CONTROL_STATUS, tempStatus);
                            break;
                        case MqttCommand.CHARGER_TEMPERATURE_CONTROL_OPEN_COOLER_ACTION:
                            chargerControlStatusCool = 0;
                            tempStatus = Msg.WHAT_OPEN_COOLER;
                            currentChargerControlStatusCool = tempStatus;
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_TEMPERATURE_CONTROL_STATUS_COOL, tempStatus);
                            break;
                        case MqttCommand.CHARGER_TEMPERATURE_CONTROL_CLOSE_COOLER_ACTION:
                            chargerControlStatusCool = 0;
                            tempStatus = Msg.WHAT_CLOSE_COOLER;
                            currentChargerControlStatusCool = tempStatus;
                            UPreferences.putInt(mActivity, UConstants.PREFERENCES_TEMPERATURE_CONTROL_STATUS_COOL, tempStatus);
                            break;
                    }
                    mHandler.removeMessages(tempStatus);
                    ULog.d(TAG, "温控执行成功 " + command.getOriginalAction() + " currentChargerControlStatus " + tempStatus);
                    break;
            }
        } else {
            //指令执行失败
            switch (command.getOriginalType()) {

                default:
                    break;
            }

        }
    }

    private void createTaskNodeGetWebCamFocusAndZoom(String taskNodeName, @androidx.annotation.NonNull String sendMqttTarget,
                                                     TaskNode taskNode) {
        if (taskNode == null || mSegment.getMapId() == null) {
            pushDeviceControl(true,"6", false);
            //获取摄像头变焦和倍数
            WebCamManager.getInstance().getZoomAndFocus()
                    .subscribe(new NextErrorObserver<Map<String, Float>>() {
                        @Override
                        public void onNext(@NonNull Map<String, Float> resultMap) {
                            Float zoomPos = resultMap.get("zoom_pos");
                            Integer focusPos = UConstants.FloatToInteger(resultMap.get("focus_pos"));

                            ULog.d(TAG,
                                    "获取网络摄像头 变焦和变倍的值 onSettingSuccess === zoompos:" + zoomPos + " focuspos:" + focusPos);
                            WebCameraArgumentBean webCameraArgumentBean = new WebCameraArgumentBean();
                            webCameraArgumentBean.setZoompos(zoomPos);
                            webCameraArgumentBean.setFocuspos(focusPos);
                            sendMqtt(robotId,
                                    sendMqttTarget,
                                    MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE,
                                    MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION,
                                    "获取网络摄像头焦距和倍数参数成功! 正在通知服务器创建任务节点...");

                            /**
                             *      Integer id;
                             *      name 任务节点名称
                             *      enable 任务节点是否可用
                             *      camera 是前后摄像头
                             *      map_id 地图id
                             *      start_location 开始检测位置
                             *      angle_json 云台角度
                             *      is_stop 是否停止
                             *      order_num 排序
                             *      direction 机器人方向
                             *      time
                             *      exception
                             *      robot_speed
                             *      webcam_json
                             *      terrain 地形
                             *      String webcamJson; 舵机云台角度
                             *      Float y;
                             *      Float z;
                             *      Integer type;  节点类型 首段尾端 等
                             *      String pictureUrl;  采样节点图片路径
                             *      String currentPictureUrl;
                             *      String locationCodeJson; aruco json
                             *      String serverMethodJson; 识别服务器参数
                             *      String threshold;  上下限阈值
                             *      mold
                             *      chck
                             */

                            TaskNode taskNode = new TaskNode();
                            taskNode.setName(taskNodeName);
                            taskNode.setMapId(mSegment.getMapId());
                            taskNode.setStartLocation(mDistance);

                            String currentCameraAngle = getRobot().getCurrentCameraAngle();
                            CurrentCameraAngle currentCameraAngle1 = UGson.getGson().fromJson(currentCameraAngle, CurrentCameraAngle.class);
                            Float h = currentCameraAngle1.getH();
                            Float v = currentCameraAngle1.getV();
                            AngleBean angleBean = new AngleBean();
                            if (h != null) {
                                angleBean.setAngleH(h);
                            }
                            if (v != null) {
                                angleBean.setAngleV(v);
                            }

                            taskNode.setAngleJson(UGson.getGson().toJson(angleBean));
                            taskNode.setIsStop(true);
                            taskNode.setDirection(robotDirection);
                            taskNode.setWebcamJson(UGson.getGson().toJson(webCameraArgumentBean));
                            taskNode.setType(NodeType.OTHER);
                            //taskNode.setPictureUrl(path);
                            taskNode.setCurrentPictureUrl("");
                            taskNode.setLocationCodeJson(UGson.getGson().toJson(taskNodeLocation));
                            taskNodeLocation = null;
                            taskNode.setServerMethodJson("");
                            taskNode.setThreshold("");
                            taskNode.setMold(2);
                            taskNode.setCheck(1);
                            createTaskNode(taskNode, sendMqttTarget, null, 0);
                        }

                        @Override
                        public void onError(@NonNull Throwable e) {
                            ULog.d(TAG, "网络摄像头 变焦和变倍的值 onSettingFailure === e:" + e);
                            boolean isRet = checkWebCameraIsOnLine(e.getMessage(),
                                    () -> createTaskNodeGetWebCamFocusAndZoom(taskNodeName, sendMqttTarget, taskNode));
                            if (!isRet) {
                                //通知手机端
                                sendMqtt(robotId,
                                        sendMqttTarget,
                                        MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE,
                                        MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION,
                                        "获取网络摄像头焦距和倍数参数失败!");
                            }
                        }
                    });
        } else {
            createTaskNode(taskNode, sendMqttTarget, null, 0);
        }
    }

    private void createTaskNode(TaskNode taskNode, @androidx.annotation.NonNull String sendMqttTarget, final byte[] imageBytes, int type) {
        CreateAndSaveSamplingImage createAndSaveSamplingImage = new CreateAndSaveSamplingImage();
        createAndSaveSamplingImage.setRobotId(robotId);
        createAndSaveSamplingImage.setTaskNode(taskNode);

        OkHttpClient client = new OkHttpClient();
        MultipartBody.Builder builder = new MultipartBody.Builder();
        builder.setType(MultipartBody.FORM);
        builder.addFormDataPart("data_json", UGson.getGson().toJson(createAndSaveSamplingImage));
        builder.addFormDataPart("image", "image", new okhttp3.RequestBody() {
            @Override
            public MediaType contentType() {
                String contentType = "image/jpeg";
                return okhttp3.MediaType.parse(contentType);
            }

            @Override
            public long contentLength() {
                try {
                    if (type == 0) {
                        ULog.e("createTaskNode", "长度0 " + takePhotoBytes.length);
                        return takePhotoBytes.length;
                    } else if (type == 1) {
                        ULog.e("createTaskNode", "长度1 " + imageBytes.length);
                        return imageBytes.length;
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return 0;
            }

            @Override
            public void writeTo(BufferedSink sink) {
                Source source = null;
                try {
                    if (type == 0) {
                        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(takePhotoBytes);
                        source = Okio.source(byteArrayInputStream);
                    } else if (type == 1) {
                        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(imageBytes);
                        source = Okio.source(byteArrayInputStream);
                    }
                    sink.writeAll(source);  //写入文件的读取流
                } catch (IOException e) {
                    e.printStackTrace();
                } finally {
                    Util.closeQuietly(source);
                }
            }

        });
        MultipartBody build = builder.build();
        Request request = new Request.Builder().url(UrlManager.getBaseUrl() + "/tasknode/create_and_save_sampling_image_V3_1_6_5")
                .post(build).build();

        client.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                sendMqtt(robotId,
                        sendMqttTarget,
                        MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE,
                        MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION,
                        "更新任务节点采样图片地址失败!");
                ULog.e("createTaskNode", "onFailure" + e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                String str = null;
                if (response.body() != null) {
                    str = response.body().string();
                }
                if (!TextUtils.isEmpty(str)) {
                    CreateAndSaveSamplingImage createAndSaveSamplingImage1 = null;
                    try {
                        createAndSaveSamplingImage1 = UGson.getGson().fromJson(str, CreateAndSaveSamplingImage.class);
                    } catch (Exception e) {
                        ULog.e("createTaskNode", e.getMessage());
                    }
                    if (createAndSaveSamplingImage1 != null && createAndSaveSamplingImage1.getMessage() != null) {
                        sendMqtt(robotId,
                                sendMqttTarget,
                                MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE,
                                MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION,
                                createAndSaveSamplingImage1.getMessage());
                    } else {
                        sendMqtt(robotId,
                                sendMqttTarget,
                                MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE,
                                MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION,
                                "访问接口解析数据异常!");
                    }
                } else {
                    sendMqtt(robotId,
                            sendMqttTarget,
                            MqttCommand.ROBOT_IMAGE_CAPTRUE_TYPE,
                            MqttCommand.ROBOT_TAKE_PHOTO_AND_CREATE_TASK_NODE_ACTION,
                            "访问接口相响应数据异常!");
                }
            }
        });
    }

    public void turnAround() {
        inspectManager.resetTurnAroundFlag();
    }

    public void rmMsg(int what) {
        if (mHandler.hasMessages(what)) {
            mHandler.removeMessages(what);
        }
    }

    boolean backwardDistanceIsZero = true;//机器人往复运动距离是否为0 默认为true;

    /**
     * 结束除尘成功
     */
    private void endDustingSuccess() {
        ULog.d(TAG, "endDustingSuccess 除尘结束 sensorEnableStatus " + sensorEnableStatus + " delay " + getRobotConfigParams().getSensorRecoveryEnableTime());
        if (mHandler.hasMessages(Msg.WHAT_END_DUSTING)) {
            mHandler.removeMessages(Msg.WHAT_END_DUSTING);
        }
        if (!sensorEnableStatus && !mHandler.hasMessages(Msg.WHAT_SENSOR_ENABLE)) {
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_SENSOR_ENABLE, getRobotConfigParams().getSensorRecoveryEnableTime() * 1000);
        }
        if (MODE == MODE_DEVICE_CLEAN) {
            //除尘已结束，停止除尘流程
            mHandler.removeMessages(Msg.WHAT_SELF_CYCLE_CLEAN_END_HANDLE);
            ULog.d(TAG,"RgbSharpnessChecker_TEST 移除倒计时2");
            Message obtain = Message.obtain();
            obtain.what = Msg.WHAT_SELF_CYCLE_CLEAN_END_HANDLE;
            obtain.obj = 2;
            mHandler.sendMessage(obtain);
        }
    }
    private long lastStartDustSuccessTime = 0; //上一次开始除尘成功时间
    /**
     * 开始除尘成功
     */
    private void startDustingSuccess() {
        ULog.d(TAG, "startDustingSuccess");
        if (mHandler.hasMessages(Msg.WHAT_START_DUSTING)) {
            mHandler.removeMessages(Msg.WHAT_START_DUSTING);
        }
        lastStartDustSuccessTime = System.currentTimeMillis();
        if (MODE == MODE_UN_KNOW && mIsHaveNewCleanDevice && inCharger()) {
            enterDustingMode();
        }
    }

    /**
     * 关闭充电桩成功
     */
    private void closeChargeSuccess() {
        ULog.d(TAG, "closeChargeSuccess");
        if (mHandler.hasMessages(Msg.WHAT_END_CHARGING)) {
            mHandler.removeMessages(Msg.WHAT_END_CHARGING);
        }
        if (mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
            mHandler.removeMessages(Msg.WHAT_START_CHARGING);
        }
        if (mIsWaitToLeaveCharger && mCommandBeforeLeaveCharger != null) {
            ULog.d(TAG, "充电已确保关闭，准备离开充电桩，继续执行指令");
            RxBus.getInstance().post(new RobotChargeEvent(RobotEventConstants.EVENT_CLOSE_CHARGER_SUCCESS));
        }
        //        else {
        //            continueExecuteCommand();
        //        }
    }

    /**
     * 打开充电桩成功
     */
    private void openChargeSuccess() {
        ULog.d(TAG, "openChargeSuccess");
        if (mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
            mHandler.removeMessages(Msg.WHAT_START_CHARGING);
        }
        if (mHandler.hasMessages(Msg.WHAT_END_CHARGING)) {
            mHandler.removeMessages(Msg.WHAT_END_CHARGING);
        }
        //告诉手机端isCloseRepeatCharge置为false
        if (MqttManager.getInstance().isConnected()) {
            getExecutorService().execute(new OpenChargeSuccessEnable());
        }
    }

    /**
     * 皮带机停止
     */
    private void beltConveyorStop() {
        ULog.i(TAG, "belt convertor stop");

        UPreferences.putInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 0);
        isBeltConveyorStart = false;
        if (MODE != MODE_GOTO_CHARGER && MODE != MODE_AUTO_BUILD_MAP && isAutoInspection()) {
            autoMoveManager.gotoChargerCheck("皮带机停止2_回充");
        }
    }

    /**
     * 皮带机开启
     */
    private void beltConveyorStart() {
        ULog.i(TAG, "belt convertor start");
        UPreferences.putInt(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_KEY, 1);
        MainApp.beltStartDate = System.currentTimeMillis();
        UPreferences.putLong(mActivity, UConstants.PREFERENCES_BELT_CONVEYOR_START_DATE_KEY, MainApp.beltStartDate);
        isBeltConveyorStart = true;
        if (getInspectEnableThreadNeedExec()) {
            mInspectionEnableThread.start();
        }
    }

    /*-----------------------------MQTT callBack end----------------------------------*/
    //离开充电桩
    public void prepareLeaveCharger() {
        if (mBotInfoMgr.isHaveSteer() && isInCleanDeviceArea(mDistance) && mIsHaveNewCleanDevice) {
            if (mBotInfoMgr.getRobotConfigParams().getLeaveBySteerVerticalDown() == UConstants.VALUE_SWITCH_STATUS_ON) {
                SteerController.getInstance().directSetVAngle(180, SteerControlTag.LEAVE_CLEAN_DEVICE.getReason());
            }
        }

        if (mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
            mHandler.removeMessages(Msg.WHAT_CHECK_BATTERY_STATUS);
        }
        if (mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
            mHandler.removeMessages(Msg.WHAT_START_CHARGING);
        }
        if (mHandler.hasMessages(Msg.WHAT_START_DUSTING)) {
            mHandler.removeMessages(Msg.WHAT_START_DUSTING);
        }
        if (currentChargerControlStatus == Msg.WHAT_OPEN_HEATER) {
            mHandler.sendEmptyMessage(Msg.WHAT_CLOSE_HEATER);
        }
        if (currentChargerControlStatusCool == Msg.WHAT_OPEN_COOLER) {
            mHandler.sendEmptyMessage(Msg.WHAT_CLOSE_COOLER);
        }
        if (mHandler.hasMessages(Msg.WHAT_UPGRADE_STM_CHECK)) {
            mHandler.removeMessages(Msg.WHAT_UPGRADE_STM_CHECK);
        }
        if (mHandler.hasMessages(Msg.WHAT_START_SCHEDULED_INSPECTION)) {
            mHandler.removeMessages(Msg.WHAT_START_SCHEDULED_INSPECTION);
        }

        mHandler.sendEmptyMessage(Msg.WHAT_END_CHARGING);
        mHandler.sendEmptyMessage(Msg.WHAT_END_DUSTING);
        setInCharger(false,"prepareLeaveCharger");
        UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
        autoMoveManager.cancelRoomIgnoreChargeNotice();
    }

    /**
     * 通知离开充电桩
     */
    public void notifyLeaveCharger() {
        if (getRobot() != null) {
            if (getRobot().getChargeStatus() == ChargerStatus.CHARGE_FRONT) {
                if (!TextUtils.isEmpty(getRobot().getPreviousRobot())) {
                    if (MqttManager.getInstance().isConnected()) {
                        MqttCommand command = new MqttCommand();
                        command.setTarget(getRobot().getPreviousRobot());
                        command.setSource(getRobot().getId());
                        command.setType(MqttCommand.ROBOT_LEAVE_CHARGER_INDEX_TYPE);
                        command.setAction(MqttCommand.ROBOT_LEAVE_HEAD_ACTION);
                        mMqttManager.publishMessage(command);
                    }
                    updateChargeStatus(ChargerStatus.NOT_IN_CHARGER);
                }
            } else if (getRobot().getChargeStatus() == ChargerStatus.CHARGE_END) {
                if (!TextUtils.isEmpty(getRobot().getNextRobot())) {
                    if (MqttManager.getInstance().isConnected()) {
                        MqttCommand command = new MqttCommand();
                        command.setTarget(getRobot().getNextRobot());
                        command.setSource(getRobot().getId());
                        command.setType(MqttCommand.ROBOT_LEAVE_CHARGER_INDEX_TYPE);
                        command.setAction(MqttCommand.ROBOT_LEAVE_TAIL_ACTION);
                        mMqttManager.publishMessage(command);
                    }
                    updateChargeStatus(ChargerStatus.NOT_IN_CHARGER);
                }
            }
        }
    }

    /**
     * 检查当前条件是否可以巡检
     *
     * @return
     */
    private CommonResult checkInspectionCondition() {
        CommonResult result = new CommonResult(ResultCode.ERROR);

        if (isSleep) {
            ULog.w(TAG, "机器人处于待机状态，无法巡检");
            InspectManager.targetInspectLocation = UConstants.UNKONW;
            result.message = "机器人处于待机状态，无法巡检";
            result.msgCode = MqttMsgCode.ERROR_ROBOT_STANDBY;

            return result;
        }
        if (MainApp.isEntryPowerSaveModeDelaying()) {
            ULog.w(TAG, "机器人等待断电重启中，无法巡检");
            InspectManager.targetInspectLocation = UConstants.UNKONW;
            result.message = "机器人等待断电重启中，无法巡检";
            result.msgCode = MqttMsgCode.ERROR_ROBOT_STANDBY;
            return result;
        }

        if (isSoftEmergencyStop) {
            ULog.w(TAG, "机器人处于软件急停状态，无法巡检");
            InspectManager.targetInspectLocation = UConstants.UNKONW;
            result.message = "机器人处于软件急停状态，无法巡检";
            result.msgCode = MqttMsgCode.ERROR_ROBOT_STANDBY;

            return result;
        }

        int powerThreshold = 50;
        if (getRobot().getLowPowerThreshold() != null) {
            powerThreshold = getRobot().getLowPowerThreshold();
        }
        if (getRobot().getPowerPercent() < powerThreshold) {
            ULog.d(TAG, "startInspection: 电量不足无法巡检 ");
            InspectManager.targetInspectLocation = UConstants.UNKONW;
            result.message = "电量值低于回充阈值，无法巡检";
            result.msgCode = MqttMsgCode.MSG_ROBOT_POWER_LOW_CANNOT_INSPECT;

            return result;
        }

        if(getRobotConfigParams().isCheckRgbSharpness() && rgbLensDirtyState){
            ULog.w(TAG, "网络摄像头污损,不巡检");
            InspectManager.targetInspectLocation = UConstants.UNKONW;
            result.message = "网络摄像头污损,不巡检";
            result.msgCode = MqttMsgCode.ERROR_ROBOT_STANDBY;
            return result;
        }

        if (inspectManager.mWayNum == -1) {
            //            sendMobileInfo("地图数据有问题，无法巡检");//因和"地图数据错误，无法巡检"都提示了，形成重复提示所以注释掉
            InspectManager.targetInspectLocation = UConstants.UNKONW;
            result.message = "任务节点数据错误，无法巡检";
            result.msgCode = MqttMsgCode.MSG_TASK_NODE_DATA_ERROR_CANNOT_INSPECT;

            return result;
        }
        ULog.d(TAG,"checkInspectionCondition environmentalTemperature :"+environmentalTemperature +" getColdProtectTemp:"+mBotInfoMgr.getRobotConfigParams()
                .getColdProtectTemp() + " envChargerId " + mBotInfoMgr.getRobotConfigParams().getColdProtectChargerId() + " envTemp: " + gson.toJson(envTempeMap));

        if (!TextUtils.isEmpty(mBotInfoMgr.getRobotConfigParams().getColdProtectChargerId())) {
            Float tTemp = envTempeMap.get(mBotInfoMgr.getRobotConfigParams().getColdProtectChargerId());
            if (tTemp != null && tTemp > -90 && tTemp < mBotInfoMgr.getRobotConfigParams().getColdProtectTemp()) {
                ULog.w(TAG, "外界环境温度过低，取消外出巡检");
                result.message = "环境温度过低，取消外出巡检";
                result.msgCode = MqttMsgCode.MSG_ENVIRONMENT_TEMPERATURE_LOW_CANNOT_INSPECT;

                return result;
            }
        }
//        if (environmentalTemperature != UConstants.UNKONW && environmentalTemperature > -90 && environmentalTemperature < mBotInfoMgr.getRobotConfigParams()
//                .getColdProtectTemp()) {
//        }
        if (isUpgrading()) {
            result.message = "机器人正在升级，无法巡检";
            result.msgCode = MqttMsgCode.ERROR_ROBOT_UPGRADING;
            return result;
        }


        if (!irPusher.isPushInit) {
            if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_SDK);
            }
            if (IntUtil.isNotNullOr0(getRobot().getIrCameraNum())) {
                int inspectionMode = UPreferences.getInt(mActivity, UConstants.PREFERENCES_FORCE_INSPECTION_KEY, 0);
                if (inspectionMode == 1) {
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_SDK_INITIALIZE_NOT_FINISH_YET_PLEASE_WAIT);
                    mMqttManager.broadcastShowInfo("SDK初始化未完成，请稍等");
                }
                mHandler.sendEmptyMessageDelayed(Msg.WHAT_START_INSPECTION, 3000);
                InspectManager.targetInspectLocation = UConstants.UNKONW;
                result.message = "SDK初始化未完成，请稍等";
                result.resultCode = ResultCode.ERROR;
                result.msgCode = MqttMsgCode.MSG_ROBOT_SDK_INITIALIZE_NOT_FINISH_YET_PLEASE_WAIT;

                return result;
            }
        }

        //非巡检到指定位置
        if (sensorStatusRecordMap.size() != 0 && InspectManager.targetInspectLocation == UConstants.UNKONW) {
            for (String id : sensorStatusRecordMap.keySet()) {
                //雨量超过阈值 & 1分钟内更新过数据
                ULog.d(TAG,
                        "updateSegmentSensorStatus == 巡检 " + gson.toJson(sensorStatusRecordMap.get(id)) + " " + (sensorStatusRecordMap.get(
                                id).getType() == 9) + "  " + sensorStatusRecordMap.get(id)
                                .isException() + "  " + (sensorStatusRecordMap.get(id)
                                .getUpdateTime()
                                .getTime() > (new Date().getTime() - 60_000)));
                if (sensorStatusRecordMap.get(id).getType() == 9 && sensorStatusRecordMap.get(id)
                        .isException() && sensorStatusRecordMap.get(id).getUpdateTime().getTime() > (new Date().getTime() - 60_000)) {
                    ULog.d(TAG, "检测到下雨，中止巡检");
                    result.message = "检测到下雨，中止巡检";
                    result.resultCode = ResultCode.ERROR;
                    result.msgCode = MqttMsgCode.MSG_ROBOT_DETECT_RAIN_STOP_INSPECT;

                    return result;
                }
            }
        }

        if (isNeedCheckAruco && targetInspectLocation == UConstants.UNKONW && targetInspectDirection == UConstants.UNKONW) {
            //不关推流(网络摄像头不会断电的情下)
            if (mSegment != null && mSegment.getDisconnected() != null && getSegmentPushEnable()) {
                if (inspectManager.getTasks() == null || inspectManager.getTasks().size() == 0) {
                    ULog.e(TAG, "checkInspectionCondition : allTaskNodes为空.准备回充.");
                    result.message = "机器人未获取到任务节点!准备回充.";
                    result.msgCode = MqttMsgCode.MSG_ROBOT_GOT_NO_TASK_NODES_GOTO_CHARGING;
                    AutoMoveManager.getInstance(MainApp.getInstance(), this).gotoChargerCheck("机器未获取到任务节点_回充");
                    return result;
                } else {
                    for (int i = 0; i < inspectManager.getTasks().size(); i++) {
                        if (inspectManager.getTasks().get(i).getMold() == null) {
                            ULog.e(TAG, "checkInspectionCondition :" + inspectManager.getTasks().get(i).getId() + "节点 mold为空.准备回充.");
                            result.message = "节点 ID:" + inspectManager.getTasks().get(i).getId() + "名称:" + inspectManager.getTasks()
                                    .get(i)
                                    .getName() + " mold为空.准备回充.";
                            result.msgCode = MqttMsgCode.MSG_NODE_MOLD_EMPTY_GOTO_CHARGER;
                            AutoMoveManager.getInstance(MainApp.getInstance(), this).gotoChargerCheck("mold未空_回充");
                            return result;
                        }
                    }

                }
            } else {
                ULog.e(TAG, "checkInspectionCondition : 识别Aruco码巡检不支持空检,请检查配置.准备回充.");
                result.message = "识别Aruco码巡检不支持空检,请检查配置.准备回充.";
                result.msgCode = MqttMsgCode.MSG_ARUCO_INSPECTION_DONT_SUPPORT_EMPTY_INSPECT_CHECK_CONFIG;
                AutoMoveManager.getInstance(MainApp.getInstance(), this).gotoChargerCheck("机柜不支持空检_回充");
                return result;
            }
        }

//        if(MainApp.isReclaimer){
//            //取料机巡检 检查 取料机检测视角等数据的完整性
//            if(!ReclaimerInspection.getInstance(RobotFragment.this).checkViewDevicesViews()){
//                ULog.i(TAG, "quliaoji checkInspectionCondition : 未获取料机巡检视角.");
//                result.message ="未获取料机巡检视角";
//                result.resultCode = ResultCode.ERROR;
//                return result;
//            }
//        }

        result.resultCode = ResultCode.OK;
        return result;
    }


    //继续巡检 其实为重新开始巡检
    //不要主动调用此方法，主动会导致历史数据清空 重新开始巡检
    //如需继续巡检保证MODE为巡检模式就可以 等待移动检测去触继续巡检
    private void continueInspection(int cacheRobotDirection) {
        if (!irPusher.isPushInit) {
            if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
                mHandler.sendEmptyMessage(Msg.WHAT_INIT_IR_SDK);
            }
        }
        if (!irPusher.isPushInit && ((getRobot().getIrCameraNum() != null && getRobot().getIrCameraNum() != 0))) {
            Message msg = mHandler.obtainMessage();
            msg.what = Msg.WHAT_CONTINUE_INSPECTION;
            msg.arg1 = cacheRobotDirection;
            mHandler.sendMessageDelayed(msg, 2000);
            return;
        }

        if (MODE == MODE_GOTO_CHARGER || inCharger()) {
            ULog.d(TAG, "已在充电桩，不恢复巡检");
            return;
        }

        startInspection(cacheRobotDirection,"continueInspection");
    }

    private void setRfidReadType(int type) {
        ULog.d(TAG, "stm_rfid setRfidReadType = " + type);
        StmTask.RFID_READ_TYPE = type;
        rfidReadType = type;
    }

    // TODO: 2019/4/26 开始巡检
    public CommonResult startInspection(String tag){
        return startInspection(false,tag);
    }

    /**
     * @param ignoreRgbRecognitionRepeatNumAdd 忽略 RgbRecognitionRepeatNum 不清空这个值
     *                                         加这个参数的目的是防止TakeImgInspectManager类重复掉用startInspection时 由于RgbRecognitionRepeatNum清空一直进不去巡检
     *                                         其他地方直接掉用 {@link #startInspection(String tag)}这个一个参数的方法就可以了
     */
    public CommonResult startInspection(boolean ignoreRgbRecognitionRepeatNum,String tag) {
        ULog.d(TAG,"startInspection 开始巡检1 tag:"+tag);
        cokeOvenInspectRepeatNum = 0;
        isServerStartRecognise = false;
        if(!ignoreRgbRecognitionRepeatNum){
            rgbRecognitionRepeatNum = 0;
            isServerStartRecogniseRGB = false;
        }
        recordVideoRecogRepeatNum = 0;
        isServerStartRecordVideoRecog = false;
        CommonResult checkNodeRet = autoMoveManager.checkNodeInfo();
        if (checkNodeRet.resultCode != ResultCode.OK) {
            return checkNodeRet;
        }

        autoMoveManager.setInspectionDirection();
        if (MapManager.getInstance().getRfidMapType() == RfidMapType.CIRCLE) {
            ULog.d(TAG, "环形轨道，固定向后巡检");
            setRobotDirection(MOVE_END, "环形轨道");
        }
        int recordVideoMode = UPreferences.getInt(mActivity, UConstants.PREFERENCE_RECORD_VIDEO_MODE_KEY, -1);
        if (recordVideoMode != -1) {
            ULog.d(TAG, "自动标定录视频 固定向后 mode " + recordVideoMode);
            setRobotDirection(MOVE_END, "自动标定录视频");
        }
        startInspectTime = System.currentTimeMillis();
        UPreferences.putLong(mActivity, UConstants.PREFERENCES_START_INSPECT_TIME_KEY, startInspectTime);
        return startInspection(robotDirection,"startInspection"+"_"+tag);
    }

    //定方向巡检
    private CommonResult startInspection(int direction,String tag) {
        ULog.d(TAG, "startInspection: 开始巡检2 tag:"+tag);
        MainApp.inspectIsSelf = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_INSPECT_IS_SELF, false);
        mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);

        CommonResult result = checkInspectionCondition();
        if (result.resultCode != ResultCode.OK) {
            ULog.d(TAG, "startInspection 不满足巡检条件 " + result.message);

            return result;
        }

        //真正巡检时再清除过期的消息，以免消息清除了但又不满足巡检条件
        mHandler.removeMessages(Msg.WHAT_SELF_CYCLE_CLEAN_END_HANDLE);


        if (mDistance < -0.2f
                && (RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_FB || RobotInfoManager.getInstance().getRobotType() == RobotType.CICA_MA)
                && CicadaRoomController.getInstance().haveRoom()) {
	        if (CicadaRoomController.getInstance().getControlSource() == RoomControlSource.ROBOT) {
		        boolean doorOpened = CicadaRoomController.getInstance().getCurDorState() == CicadaRoomDoorState.OPEN;
		        boolean waitingClose = RobotStatus.getIsWaitRoomDoorClose();

		        if (!doorOpened || waitingClose) {
			        RobotStatus.setIsWaitRoomDoorOpen(true);
			        setCmdAfterRoomOp(MqttCommands.createInspectionCmd("self", getRobot().getId()));
			        CicadaRoomController.getInstance().controlDoor(CicadaRoomDoorState.OPEN);
			        mMqttManager.broadcastShowInfo("Room正在开门，将在开门完成后继续巡检...");
			        mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROOM_IS_OPENING_DOOR_CONTINUE_INSPECTION_AFTER_DOOR_OPEN);

			        return result;
		        } else {
			        ObstacleController.getInstance().setObstacleOn(false,"23");
		        }
            } else {
				result.resultCode = ResultCode.ERROR;
				result.msgCode = MqttMsgCode.MSG_ROBOT_CANNOT_GET_OUT_ROOM_TO_INSPECT_WHEN_ROOM_MANUAL_CONTROL;
				result.message = getString(R.string.robot_cannot_get_out_room_inspect_when_manual_control);

				return result;
            }
        }

        setRobotDirection(direction,"固方向巡检");
        SmartRtspToRtmp.isAutoInspect = MainApp.inspectIsSelf ;
        ULog.d(TAG, "cokeOven inspectIsSelf " + MainApp.inspectIsSelf + " isCokeOvenInspect " + MainApp.isCokeOvenInspect + " ServerStart " + isServerStartRecognise + " MqttEnable " + isCokeOvenInspectMqttEnable + " RepeatNum " + cokeOvenInspectRepeatNum);
        if (MainApp.inspectIsSelf && MainApp.isCokeOvenInspect && !isServerStartRecognise && isCokeOvenInspectMqttEnable && cokeOvenInspectRepeatNum < 12) {
            String value = "{\"direction\":\"" + (direction == MOVE_END ? "TO_END" : "TO_FRONT") + "\",\"mode\":" + SmartRtspToRtmp.recognitionMode + "}";
            mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_INSPECTION_START_COKE_OVEN_RECOGNISE_ACTION, value);
            cokeOvenInspectRepeatNum++;
            ULog.d(TAG, "cokeOven 焦炉开始巡检 mqttNum = " + cokeOvenInspectRepeatNum);
            Message msg = mHandler.obtainMessage();
            msg.what = Msg.WHAT_COKE_OVEN_INSPECT;
            msg.arg1 = direction;
            if (!mHandler.hasMessages(Msg.WHAT_COKE_OVEN_INSPECT))
                mHandler.sendMessageDelayed(msg, 5000);
            result.message = "等待识别服务回应.或未收到回应稍后巡检.";
            result.resultCode = ResultCode.ERROR;
            return result;
        }
        ULog.d("TakeImgInspectManager","rgbRecognitionRepeatNum:"+rgbRecognitionRepeatNum+" isServerStartRecogniseRGB:"+isServerStartRecogniseRGB+" MODE:"+MODE +" isRgbRecognition:"+MainApp.isRgbRecognition);
        if ((MainApp.isRgbRecognition || (isNeedCheckAruco && MODE != MODE_CHECKING_STOP && MODE != MODE_INSPECTION))
                && !isServerStartRecogniseRGB && rgbRecognitionRepeatNum < 12) {
            String value = "{\"inspection_direction\":\"" + (direction == MOVE_END ? "TO_END" : "TO_FRONT") + "\",\"robot_direction\":\"" +  (direction == MOVE_END ? "TO_END" : "TO_FRONT") + "\"}";
            mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_INSPECTION_START_RGB_RECOGNISE_ACTION, value);
            rgbRecognitionRepeatNum++;
            ULog.d(TAG, "RgbRecognition rgb上传文件识别开始巡检 mqttNum = " + rgbRecognitionRepeatNum);
            Message msg = mHandler.obtainMessage();
            msg.what = Msg.WHAT_RGB_RECOGNITION_INSPECT;
            msg.arg1 = direction;
            if (!mHandler.hasMessages(Msg.WHAT_RGB_RECOGNITION_INSPECT))
                mHandler.sendMessageDelayed(msg, 5000);
            ULog.d("TakeImgInspectManager","等待检测服务回应或稍后才巡检");
            result.resultCode = ResultCode.ERROR;
            result.message = getString(R.string.robot_cannot_get_out_room_inspect_when_manual_control);
            result.message = "等待识别服务回应.或未收到回应稍后巡检.";
            return result;
        }
        int recordVideoMode = UPreferences.getInt(mActivity, UConstants.PREFERENCE_RECORD_VIDEO_MODE_KEY, -1);
        if (recordVideoMode == 2 && !isServerStartRecordVideoRecog && recordVideoRecogRepeatNum < 12) {
            mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_RECORD_VIDEO_RECOGNISE_ACTION, null);
            recordVideoRecogRepeatNum++;
            ULog.d(TAG, "recordVideoRecognition 录像自动标定 开始巡检 mqttNum = " + recordVideoRecogRepeatNum);
            Message msg = mHandler.obtainMessage();
            msg.what = Msg.WHAT_RECORD_VIDEO_RECOGNITION_INSPECT;
            msg.arg1 = direction;
            if (!mHandler.hasMessages(Msg.WHAT_RECORD_VIDEO_RECOGNITION_INSPECT))
                mHandler.sendMessageDelayed(msg, 5000);
            result.message = "等待识别服务回应.或未收到回应稍后巡检.";
            result.resultCode = ResultCode.ERROR;
            return result;
        }
        removeRetryInspectMsg();
        if (recordVideoMode != -1) {
            MainApp.isRecordVideoAutoRecognition = true;
        }

        if (inCharger()) {
            prepareLeaveCharger();
        }
        setInCharger(false,"开始巡检");

        ULog.d(TAG, "startInspection: 开始巡检 " + direction);

        if (mHandler.hasMessages(Msg.WHAT_CHECK_BATTERY_STATUS)) {
            mHandler.removeMessages(Msg.WHAT_CHECK_BATTERY_STATUS);
        }
        if (mHandler.hasMessages(Msg.WHAT_START_CHARGING)) {
            mHandler.removeMessages(Msg.WHAT_START_CHARGING);
        }
        if (mHandler.hasMessages(Msg.WHAT_START_DUSTING)) {
            mHandler.removeMessages(Msg.WHAT_START_DUSTING);
        }
        if (currentChargerControlStatus == Msg.WHAT_OPEN_HEATER) {
            mHandler.sendEmptyMessage(Msg.WHAT_CLOSE_HEATER);
        }
        if (currentChargerControlStatusCool == Msg.WHAT_OPEN_COOLER) {
            mHandler.sendEmptyMessage(Msg.WHAT_CLOSE_COOLER);
        }
        if (mHandler.hasMessages(Msg.WHAT_UPGRADE_STM_CHECK)) {
            mHandler.removeMessages(Msg.WHAT_UPGRADE_STM_CHECK);
        }
        if (mHandler.hasMessages(Msg.WHAT_START_SCHEDULED_INSPECTION)) {
            mHandler.removeMessages(Msg.WHAT_START_SCHEDULED_INSPECTION);
        }
        mHandler.sendEmptyMessage(Msg.WHAT_END_CHARGING);
        mHandler.sendEmptyMessage(Msg.WHAT_END_DUSTING);
        //        if (inCharger()) {
        //            if (inspectionCommand.equals(previousCommand)) {
        //                return;
        //            }
        //        }

        if (inspectManager.initInspectionParams(direction)) {
            UPreferences.putInt(mActivity, UConstants.PREFERENCES_IN_CHARGER_KEY, 0);
            ULog.d(TAG, "开始巡检 == inCharger set false");
            updatePushEnable("1");
            inspectManager.resetTurnAroundFlag();
            //识别码巡检前需要停3秒初始化下垂直舵机
            if (!isNeedCheckAruco || (targetInspectLocation != UConstants.UNKONW && targetInspectDirection != UConstants.UNKONW)) {
                setMode(MODE_INSPECTION, "巡检模式-startInspection");
                setStmTarget(StmTask.TARGET_CANCEL,"17");
                AutoMoveManager.setChargerTarget = false;
                //修改速度

                stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));

                //如果可以，开始巡检前重设下舵机角度
                if (inspectManager.getCurrentTaskNode() != null) {
                    if (mBotInfoMgr.isHaveSteer()) {
                        if (isInCleanDeviceArea(mDistance)) {
                            //开始巡检时，若在除尘设备范围内，则将镜头向下，防止出BY镜头被毛刷刷脏
                            SteerController.getInstance().directSetSteerAngle(mBotInfoMgr.getRobotConfigParams().getDustHorizontalAngle(),
                                    180,
                                    SteerControlTag.INSPECTION.getReason()+"除尘设备范围内，则将镜头向下，防止出BY镜头被毛刷刷脏");
                        } else {
                            float[] angles = UConstants.getAngle(inspectManager.getCurrentTaskNode().getAngleJson());
                            if (angles != null) {
                                SteerController.getInstance().setSteerAngle(angles[0], angles[1],
                                        SteerControlTag.INSPECTION.getReason()+" 开始巡检时,不在除尘设设备范围内,设置任务节点角度");
                            }
                        }
                    }


                    if (inspectManager.getCurrentTaskNode().getRobotSpeed() != null) {
                        setSpeed(inspectManager.getCurrentTaskNode().getRobotSpeed(), RobotSetSpeedLogTags.SPEELD_lOG_TAG_41);
                    }
                } else {
                    setSpeed(UConstants.DEFAULT_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_41);
                }
            } else {
                setCheckAruco(true);
            }
            ULog.d(TAG, "startInspection:  === 开始巡检 RFID_START_QUERY maxRFIDDistance " + autoMoveManager.maxRFIDDistance);

            if (autoMoveManager.maxRFIDDistance != Float.MAX_VALUE && MainApp.inspectIsSelf) {
                //在地图前半段 且向后巡检 起点加1
                if (mDistance > 0 && mDistance < autoMoveManager.maxRFIDDistance / 2 && robotDirection == MOVE_END) {
                    statisticToMapHead("startInspection");
                }
                //在地图后半段 且向前巡检 终点加1
                if (mDistance > 0 && mDistance < autoMoveManager.maxRFIDDistance / 2 && robotDirection == MOVE_FRONT) {
                    statisticToMapEnd("startInspection");
                }
            }


            batteryAutoOff = false;
            UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_BATTERY_AUTO_OFF_KEY, false);
            if (mHandler.hasMessages(Msg.WHAT_LEAVE_CHARGER)) {
                mHandler.removeMessages(Msg.WHAT_LEAVE_CHARGER);
            }
            if (mHandler.hasMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE)) {
                mHandler.removeMessages(Msg.WHAT_REPEAT_FIND_IN_PLACE);
            }
        }

        return result;
    }

    public void checkArrangeInspectionGoCharger() {
        autoMoveManager.checkArrangeInspectionGoCharger();
    }

    /**
     * @param flag
     */
    private void setCheckAruco(boolean flag) {
        if (flag) {
            if (InspectManager.targetInspectLocation == UConstants.UNKONW) {
                if (isNeedCheckAruco && !TakeImgInspectManager.isRunning) {//检测任务节点中是否需要识别Aruco码
                    Log.i(TAG, "run: jiao1234=======33333");
                    TakeImgInspectManager.getInstance(RobotFragment.this).startCheckOrClose(1, "2");
                    Log.i(TAG, "run: jiao1234=======44444");
                }
            } else if (TakeImgInspectManager.isRunning) {
                Log.i(TAG, "startInspection: targetInspectLocation=" + InspectManager.targetInspectLocation);
                TakeImgInspectManager.getInstance(RobotFragment.this).startCheckOrClose(2,"3");
            }
        } else {
            if (TakeImgInspectManager.isRunning) {
                TakeImgInspectManager.getInstance(RobotFragment.this).startCheckOrClose(2,"4");
            }
        }
    }

    /**
     * 是否需要检测温度异常
     * mSegment.getDisconnected()
     * 巡检配置 0双向实检 .
     * 1正向实检，反向空检.
     * 2正向空检，反向实检.
     * 3 检测ArUco巡检，反向不检测，不关推流 .
     * 4 检测ArUco巡检，正向不检测，不关推流 .
     * 5 检测ArUco巡检，双向不检测，不关推流 .
     * @return
     */
    public boolean isNeedCheckTemperatureException(int robotDirection) {
        if (mSegment != null && mSegment.getDisconnected() != null) {
            if ((mSegment.getDisconnected() == 1 || mSegment.getDisconnected() == 3) && robotDirection == MOVE_FRONT) {
                return false;
            }
            if ((mSegment.getDisconnected() == 2 || mSegment.getDisconnected() == 4) && robotDirection == MOVE_END) {
                return false;
            }
            if(mSegment.getDisconnected() == 5){
                return false;
            }
            if (mSegment.getDisconnected() == 6 && robotDirection == MOVE_FRONT) {
                return false;
            }
            if (mSegment.getDisconnected() == 7 && robotDirection == MOVE_END) {
                return false;
            }
        }

        if (inspectManager.mWayNumBackup == 2 && inspectManager.inspectDirectionIsUpdate &&
                ((inspectManager.inspectDirectionBackup == MOVE_END && robotDirection == MOVE_FRONT) ||
                        (inspectManager.inspectDirectionBackup == MOVE_FRONT && robotDirection == MOVE_END))) {
            return false;
        }
        return true;
    }

    public boolean getSegmentPushEnable() {
        return (mSegment.getDisconnected() == 0 || mSegment.getDisconnected() == 3 ||
                mSegment.getDisconnected() == 4 || mSegment.getDisconnected() == 5 ||
                mSegment.getDisconnected() == 6 || mSegment.getDisconnected() == 7);
    }

    /**
     * //TODO 修改 实检|空检用 并不是设置是否推流. 设置是否推流 @see #updateRobotPushEnable
     * mSegment.getDisconnected()
     * 巡检配置 0双向实检 .
     * 1正向实检，反向空检.
     * 2正向空检，反向实检.
     * 3 检测ArUco巡检，反向不检测，不关推流 .
     * 4 检测ArUco巡检，正向不检测，不关推流 .
     * 5 检测ArUco巡检，双向不检测，不关推流 .
     * 默认0 .
     */
    public void updatePushEnable(String logTag) {
        ULog.d(TAG,"updatePushEnable logTag:"+logTag);
        if (mSegment != null && mSegment.getDisconnected() != null) {
            if (getSegmentPushEnable()) {
                //网络摄像头没有上电
                if (!BoolUtil.val(getRobot().getPushEnable())) {
                    if (!isWebCameraElectrify) {
                        if (!mHandler.hasMessages(Msg.WHAT_WEB_CAMERA_CORRECT_TIME)) {
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_WEB_CAMERA_CORRECT_TIME, 100);
                        }
                    }
                    updateRobotPushEnable(true,"2");
                }
            } else if (mSegment.getDisconnected() == 1) {
                ULog.d(TAG, "updatePushEnable 方向 = " + robotDirection);
                //正向开推流，反向关推流
                if (robotDirection == MOVE_FRONT) {
                    updateRobotPushEnable(false,"3");
                    mHandler.removeMessages(Msg.WHAT_WEB_CAMERA_CORRECT_TIME);
                } else {
                    updateRobotPushEnable(true,"4");
                    if (!mHandler.hasMessages(Msg.WHAT_WEB_CAMERA_CORRECT_TIME)) {
                        mHandler.sendEmptyMessage(Msg.WHAT_WEB_CAMERA_CORRECT_TIME);
                    }
                }
            } else if (mSegment.getDisconnected() == 2) {
                //正向关推流，反向开推流
                if (robotDirection == MOVE_FRONT) {
                    updateRobotPushEnable(true,"5");
                    if (!mHandler.hasMessages(Msg.WHAT_WEB_CAMERA_CORRECT_TIME)) {
                        mHandler.sendEmptyMessage(Msg.WHAT_WEB_CAMERA_CORRECT_TIME);
                    }
                } else {
                    updateRobotPushEnable(false,"6");
                    mHandler.removeMessages(Msg.WHAT_WEB_CAMERA_CORRECT_TIME);
                }
            }
        }
    }


    private void updateRobotPushEnable(boolean pushEnable,String logTag) {
        boolean config = getRobotConfigParams().getClosePushOfSaveNetwork();
        ULog.w(TAG, "===============pusher==,updateRobotPushEnable>>" + (pushEnable ? "开启推流" : "关闭推流") +" logTag:"+logTag + " ClosePushOfSaveNetwork " + config);

        if (config) {
            ULog.d(TAG, "关闭推流节省流量");
            return;
        }
        UpdatePushEnableByRobotId request = new UpdatePushEnableByRobotId();
        request.setRobotId(getRobot().getId());
        request.setPushEnable(pushEnable);
        UOKHttp.post(UrlManager.getBaseUrl(),
                request,
                new UOKHttp.RequestCallBack<UpdatePushEnableByRobotId>(UpdatePushEnableByRobotId.class) {
                    @Override
                    public void onFailure(Call call, IOException e) {
                        ULog.e(TAG, "updateRobotPushEnable onFailure" + e);
                        //                ToastUtils.showToast(RobotControlActivity.this.getApplicationContext().getApplicationContext(), "服务器异常，请联系服务人员", ToastUtils.TYPE_WARNING);
                    }

                    @Override
                    public void onResponseOk(Call call, UpdatePushEnableByRobotId result) {
                        ULog.e(TAG, "updateRobotPushEnable onResponseOk " + result.isSuccess());
                    }

                    @Override
                    public void onResponseError(Call call, int code, String responseString) {
                        ULog.e(TAG, "updateRobotPushEnable onResponseError" + responseString);
                    }
                });
        pushDeviceControl(pushEnable,"7", true);
    }

    /**
     *
     * @param isPush
     * @param logTag
     * @param isReadConfig 是否需要读取推流断电配置
     */
    private void pushDeviceControl(boolean isPush,String logTag, boolean isReadConfig) {
        ULog.df("pushDeviceControl webCamera isWebCameraElectrify={}, isPush={} logTag={} isReadBlackoutConfig={}", isWebCameraElectrify, isPush,logTag, isReadConfig);
        boolean config = getRobotConfigParams().getClosePushOfSaveNetwork();
        if (isWebCameraElectrify == isPush) {
            if (!isPush && (!config || !isReadConfig) && !IRService.isIrClosed) {
                //关闭推流 省推流开关为关 时 红外非主动断电为false 应继续更新 不应return
            } else {
                return;
            }
        }
        if (isPush) {
            ULog.d(TAG, "pushDeviceControl webCamera 网络摄像头上电");
            //喇叭
            AudioUtil.adjustToMaxMediaVolume(MainApp.getInstance());

            //网络摄像头（给电）
            SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_USB_HOST_RESET, 1);
            //煤安网络摄像头和垂直/水平舵机一路电，网络摄像头重新上电时，需要给水平舵机矫正
            if (mRobotType.getSubType() != RobotSubType.BZ && !isInCleanDeviceArea(mDistance)) {
                SteerController.getInstance().setPowerEnable(true);
            }
            isWebCameraElectrify = true;

            //补光灯
            FillLightController.getInstance().setFillLightMode(FillLightSwitchMode.MODE_AUTO);

            frameTime = -1;
	        SerialManagerUtil.getSerialManager(BrainApplication.getInstance()).gpio_write(UConstants.GPIO_USB_RESET, 1);
            //热成像上电
            IRService.isIrClosed = false;
//            if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_ARR)) {
//                mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_ARR, 1000);
//            }
        } else {
            ULog.d(TAG, "pushDeviceControl webCamera 网络摄像头断电 isReadConfig " + isReadConfig + " ClosePushOfSaveNetwork " + config);

            if (isReadConfig && config) {
                pushCtrlAll(false);
                return;
            }
            //热成像断电
            IRService.isIrClosed = true;
            //喇叭
            AudioUtil.adjustToMinMediaVolume(MainApp.getInstance());
            //网络摄像头（断电）
            SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_USB_HOST_RESET, 0);
            SerialManagerUtil.getSerialManager(BrainApplication.getInstance()).gpio_write(UConstants.GPIO_USB_RESET, 0);

            if (mRobotType.getSubType() != RobotSubType.BZ) {
                SteerController.getInstance().setPowerEnable(false);
            }
            isWebCameraElectrify = false;
            pushCtrlAll(false);

            //补光灯
            FillLightController.getInstance().setFillLightMode(FillLightSwitchMode.FORCE_OFF);
//            PushManager.getInstance(mActivity).close();
        }
    }

    int lastUpdateHisTimeType = -1;

    public void updateHistoryTime(@TimeType int type, String tag) {
        String tt = "";
        long time = System.currentTimeMillis();
        switch (type) {
            case TimeType.CHARGER_START_CHARGING_TIME:
                tt = "充电桩开始充电";
                break;
            case TimeType.CHARGER_STOP_CHARGING_TIME:
                tt = "充电桩结束充电";
                break;
            case TimeType.ROBOT_START_INSPECTION_TIME:
                tt = "机器人开始巡检时间";
                break;
            case TimeType.ROBOT_STOP_INSPECTION_TIME:
                tt = "机器人结束巡检时间";
                break;
            case TimeType.BELT_START_TIME:
                tt = "皮带机开启时间";
                break;
            case TimeType.BELT_STOP_TIME:
                tt = "皮带机停止时间";
                break;
            case TimeType.ROBOT_START_GO_TO_CHARGER_TIME:
                tt = "机器人开始回充电桩时间";
                break;
            case TimeType.ROBOT_REACH_CHARGER_TIME:
                tt = "机器人到达充电桩时间";
                break;
        }
        ULog.d(TAG, "updateHistoryTime == type = " + type + "tag=" + tag + " tt=" + tt + " lastUpdateHisTimeType " + lastUpdateHisTimeType);
        if (getRobot() == null) {
            return;
        }
        if (lastUpdateHisTimeType == TimeType.ROBOT_START_GO_TO_CHARGER_TIME && type == TimeType.ROBOT_STOP_INSPECTION_TIME) {
            lastUpdateHisTimeType = type;
            return;
        }
        lastUpdateHisTimeType = type;
        HistoryTime hTime = new HistoryTime();
        //        if (type == TimeType.CHARGER_START_CHARGING_TIME || type == TimeType.CHARGER_STOP_CHARGING_TIME) {
        //            if (autoMoveManager.mNearestChargerNodeWrapper == null || autoMoveManager.mNearestChargerNodeWrapper.getCharger() == null) {
        //                mHandler.postDelayed(() -> {
        //                    updateHistoryTime(type, tag);
        //                }, 1000);
        //                return;
        //            }
        //            hTime.setDeviceId(autoMoveManager.mNearestChargerNodeWrapper.getCharger().getId());
        //        } else {
        hTime.setDeviceId(getRobot().getId());
        //        }
        ULog.d(TAG, "updateHistoryTime deviceId=" + hTime.getDeviceId());
        hTime.setTimeType(type);
        hTime.setTime(new Date());
        hTime.setTimeLong(time);
        if (hTime.getTimeLong() < 1616860800000L) { //小于2021-3-28则认为是错误时间
            errorHisTimeList.add(hTime);
            return;
        } else if (errorHisTimeList.size() != 0) {
            fixErrorHisTime();
        }
        updateHisTimeRequest(hTime);
    }

    ConcurrentHashMap<Long, HistoryTime> hisTimeRecords = new ConcurrentHashMap<>();
    CopyOnWriteArrayList<HistoryTime> errorHisTimeList = new CopyOnWriteArrayList<>();

    public void fixErrorHisTime() {
        long currentTime = System.currentTimeMillis();
        if (currentTime > 1616860800000L && errorHisTimeList.size() != 0) {
            List<HistoryTime> copyList = new ArrayList<>();
            copyList.addAll(errorHisTimeList);
            errorHisTimeList.clear();
            ULog.d(TAG, "updateHistoryTime fixErrorHisTime copyList = " + gson.toJson(copyList));
            //倒序排序
            copyList.sort(new Comparator<HistoryTime>() {
                @Override
                public int compare(HistoryTime t1, HistoryTime t2) {
                    return (int) (t2.getTimeLong() - t1.getTimeLong());
                }
            });
            long lastTime = -1;
            long newTime = -1;
            for (HistoryTime hisTime : copyList) {
                if (newTime == -1) {
                    newTime = currentTime - 1000;
                } else {
                    newTime = currentTime - (lastTime - hisTime.getTimeLong()) - 1000;
                }
                lastTime = hisTime.getTimeLong();
                hisTime.setTime(new Date(newTime));
                hisTime.setTimeLong(newTime);

                hisTimeRecords.put(newTime, hisTime);
            }
            ULog.d(TAG, "updateHistoryTime fixErrorHisTime hisTimeRecords = " + gson.toJson(copyList));
            StorageCenter.getRobotStorage().putString("his_time_records", gson.toJson(hisTimeRecords));
            StorageCenter.getRobotStorage().saveAsync();

            mHandler.sendEmptyMessageDelayed(Msg.WHAT_UPLOAD_HIS_TIME, 3 * 1000);
        }
    }

    public void updateHisTimeRequest(HistoryTime hTime) {
        hisTimeRecords.put(hTime.getTimeLong(), hTime);
        List<HistoryTime> records = new ArrayList<>();
        fun.unifun.library.cloud.client.inparam.historytime.Create request = new fun.unifun.library.cloud.client.inparam.historytime.Create();
        request.setHistoryTime(hTime);
        //        request.setHistoryTimeList(records);

        UOKHttp.post(UrlManager.getBaseUrl(),
                request,
                new UOKHttp.RequestCallBack(fun.unifun.library.cloud.client.inparam.historytime.Create.class) {
                    @Override
                    public void onFailure(Call call, IOException e) {
                        ULog.d(TAG, "onFailure == updateHistoryTime " + hTime.getTimeType() + " time " + hTime.getTimeLong());
                        mHandler.postDelayed(() -> {
                            updateHisTimeRequest(hTime);
                        }, 2000);
                    }

                    @Override
                    public void onResponseOk(Call call, Object o) {
                        ULog.d(TAG, "onResponseOk == updateHistoryTime " + hTime.getTimeType() + " time " + hTime.getTimeLong());
                        hisTimeRecords.remove(hTime.getTimeLong());
                    }

                    @Override
                    public void onResponseError(Call call, int i, String s) {
                        ULog.d(TAG, "onResponseError == updateHistoryTime " + hTime.getTimeType() + " time " + hTime.getTimeLong());
                        mHandler.postDelayed(() -> {
                            updateHisTimeRequest(hTime);
                        }, 2000);
                    }
                });
    }


    byte[] outputNV12;// = new byte[width_Y * 2 * height_Y * 3 / 2];

    final static Object irFrameLock = new Object();
    final static Object irFrameBackLock = new Object();
    public CopyOnWriteArrayList<Float> currentIRValue = new CopyOnWriteArrayList<>();
    public CopyOnWriteArrayList<int[]> currentIRValueXy = new CopyOnWriteArrayList<>();
    CopyOnWriteArrayList<Float> currentIRValueBack = new CopyOnWriteArrayList<>();
    CopyOnWriteArrayList<int[]> currentIRValueBackXy = new CopyOnWriteArrayList<>();
    public CopyOnWriteArrayList<Integer> currentIRObjIds = new CopyOnWriteArrayList<>();
    public CopyOnWriteArrayList<Float> currentIRValueBackup = new CopyOnWriteArrayList<>();
    public CopyOnWriteArrayList<Float> currentIRValueBackBackup = new CopyOnWriteArrayList<>();
    CopyOnWriteArrayList<Float> currentIRValueScale = new CopyOnWriteArrayList<>();
    CopyOnWriteArrayList<Float> currentIRValueScaleBack = new CopyOnWriteArrayList<>();
    byte[] h264;// = new byte[width_Y * 2 * height_Y * 3 / 2];

    public byte[] intToBytes(int value) {
        byte[] src = new byte[4];
        src[3] = (byte) ((value >> 24) & 0xFF);
        src[2] = (byte) ((value >> 16) & 0xFF);
        src[1] = (byte) ((value >> 8) & 0xFF);
        src[0] = (byte) (value & 0xFF);
        return src;
    }

    boolean isStartAudioAnalysis = false;
    /**
     * 开始音频分析
     */
    private void startAudioAnalysis() {
        if (!isStartAudioAnalysis) {
            isStartAudioAnalysis = true;
            mAudioManager = AudioManager.getInstance(mActivity.getApplication());
            AudioManager.getInstance(mActivity).init();
            mAudioManager.registerOnDecibelListener(this);
            mAudioManager.registerOnAudioDataListener(this);
            if (audioRecorder == null) {
                audioRecorder = new AudioRecorder();
            }
            getExecutorService().execute(audioRecorder);
        }
    }

    public String recordAudioFile(int taskNodeId, long timeStamp) {
        String fileName = null;
        if (audioRecorder != null) {
            fileName = taskNodeId + "_" + timeStamp + "000.pcm";
            audioRecorder.addFile(new AudioFileBean(UConstants.AUDIO_PCM_FILE_DIR + fileName));
        }
        return fileName;
    }

    public List<AudioFileBean> getAudioRecorderFileList() {
        if (audioRecorder != null)
            return audioRecorder.getFileList();
        else
            return new ArrayList<>();
    }

    public static volatile float currentDecibel, currentDecibelDisplay;
    public long decibelDisplayTime;


    private volatile long lastAudioHighAlarmTime = 0;//防止分贝超过一定阈值报警过于频繁

    //之前是android mic计算分贝 现使用分贝检测模块
    @Override
    public void onDecibelChange(double decibel) {
        //        ULog.d(TAG, "onDecibelChange:  === 分贝  ==  " + decibel);
        if (decibel > 110 || decibel < 0) {
            return;
        }
        if (getRobot() != null) {
            //ULog.d(TAG, "onDecibelChange: 111 === 分贝  ==  " + new BigDecimal(decibel).setScale(2, BigDecimal.ROUND_HALF_UP).floatValue());
            getRobot().setDecibel(new BigDecimal(decibel).setScale(2, BigDecimal.ROUND_HALF_UP).floatValue());

            float audioFixedThreshold = 80;
            if (getRobot().getThresholdAudioFixed() != null) {
                audioFixedThreshold = getRobot().getThresholdAudioFixed();
            }

            if (!MainApp.isAudioPlaying && MODE != MODE_DEVICE_CLEAN) {
                if (decibel > audioFixedThreshold) {
                    long l = System.currentTimeMillis();
                    //限1秒触发一次 通知一次服务端 防止接口访问频繁
                    if (Math.abs(lastAudioHighAlarmTime - l) > 1000) {
                        lastAudioHighAlarmTime = l;
                        //取料机巡检模式分贝处理
                        if (MainApp.isReclaimer) {
                            if (addAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_RECLAIMER) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_RECLAIMER)) {
                                ULog.i(TAG, "onDecibelChange: 分贝报警1.1:" + decibel);
                                List<String> params = new ArrayList<>();
                                params.add(FormatUtils.keepDecimals(mDistance, 2) + "");
                                params.add(FormatUtils.keepDecimals(audioFixedThreshold, 2) + "");
                                params.add(FormatUtils.keepDecimals(decibel, 2) + "");
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_RECLAIMER, params));
                                setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_RECLAIMER, true);
                            }
                        } else {
                            if (addAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION)) {
                                ULog.i(TAG, "onDecibelChange: 分贝报警1.2:" + decibel);
                                List<String> params = new ArrayList<>();
                                params.add(FormatUtils.keepDecimals(mDistance, 2) + "");
                                params.add(FormatUtils.keepDecimals(decibel, 2) + "");
                                params.add(FormatUtils.keepDecimals(audioFixedThreshold, 2) + "");
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION, params));
                                setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION, true);
                            }
                        }
                    }
                } else {
                    if (MainApp.isReclaimer) {
                        setAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_RECLAIMER, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_RECLAIMER)) {
                            ULog.i(TAG, "onDecibelChange: 分贝报警恢复1.1:" + decibel);
                            setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_RECLAIMER, false);
                        }
                    } else {
                        setAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION)) {
                            ULog.i(TAG, "onDecibelChange: 分贝报警恢复1.2:" + decibel);
                            setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION, false);
                        }
                    }

                }

                if (mBotInfoMgr.getRobotConfigParams() != null && mBotInfoMgr.getRobotConfigParams().isDecibelCheck()) {
                    //检测分贝报警 这里只根据配置如果需要检测 不区分巡检模式 (正在播放音频 或者 除尘模式 机器人不检测分贝)
                    if (isBeltConveyorStart && mBotInfoMgr.getRobotConfigParams().getBeltRuningDecibeThreshold() != null) {
                        //皮带机当前开机
                        long l = System.currentTimeMillis();
                        if (Math.abs(lastAudioHighAlarmTime - l) > 1000) {
                            if (addAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_RUNING) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_RUNING)) {
                                Integer taskNodeId = getSensorAlarmTaskNodeId();
                                ULog.i(TAG, "onDecibelChange: 分贝报警3:" + decibel + " taskNodeId:" + taskNodeId);
                                if (taskNodeId != null) {
                                    lastAudioHighAlarmTime = l;
                                    List<String> params = new ArrayList<>();
                                    params.add(getSensorAlarmFirstParam());
                                    //params.add(FormatUtils.keepDecimals(mBotInfoMgr.getRobotConfigParams().getBeltRuningDecibeThreshold(), 2) + "");
                                    params.add(FormatUtils.keepDecimals(decibel, 2) + "");
                                    AlarmEvent alarmEvent = new AlarmEvent(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_RUNING, params);
                                    alarmEvent.setTaskNodeId(taskNodeId);
                                    RxBus.getInstance().post(alarmEvent);
                                    setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_RUNING, true);
                                }
                            }
                        }
                    } else {
                        audioAlarmresume(decibel);
                    }
                } else if (!isBeltConveyorStart && mBotInfoMgr.getRobotConfigParams().getBeltNotRuningDecibeThreshold() != null) {
                    //皮带机当前未开机
                    if (decibel > mBotInfoMgr.getRobotConfigParams().getBeltNotRuningDecibeThreshold()) {
                        long l = System.currentTimeMillis();
                        if (Math.abs(lastAudioHighAlarmTime - l) > 1000) {
                            if (addAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_NOT_RUNING) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_NOT_RUNING)) {
                                Integer taskNodeId = getSensorAlarmTaskNodeId();
                                ULog.i(TAG, "onDecibelChange: 分贝报警4:" + decibel + " taskNodeId:" + taskNodeId);
                                if (taskNodeId != null) {
                                    lastAudioHighAlarmTime = l;
                                    List<String> params = new ArrayList<>();
                                    params.add(getSensorAlarmFirstParam());
                                    //params.add(FormatUtils.keepDecimals(mBotInfoMgr.getRobotConfigParams().getBeltNotRuningDecibeThreshold(), 2) + "");
                                    params.add(FormatUtils.keepDecimals(decibel, 2) + "");
                                    AlarmEvent alarmEvent = new AlarmEvent(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_NOT_RUNING, params);
                                    alarmEvent.setTaskNodeId(taskNodeId);
                                    RxBus.getInstance().post(alarmEvent);
                                    setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_NOT_RUNING, true);
                                }
                            }
                        }
                    } else {
                        audioAlarmresume(decibel);
                    }
                }
            }

            /*if ((MODE == MODE_INSPECTION)) {
                //                if (getRobot().getAudioFixedEnable()) {
                float tempAvgDecibel = getRobot().getThresholdAudioFixed() >= 80 ? getRobot().getThresholdAudioFixed() : 80;
                if (decibel >= tempAvgDecibel) {
                    decibelStatus = StmTask.EX_DECIBEL_PROBABLE_EXCEPTION;
                    if (!audioException) {
                        audioException = true;
                    }
                } else {
                    decibelStatus = StmTask.EX_DECIBEL_NORMAL;
                    if (audioException) {
                        audioException = false;
                    }
                }
                //新策略 减速不报异常
                if (audioException) {
                    ULog.d(TAG, "irAnalysis:  === 音频异常   当前节点音频是否异常 " + currentNodeAudioIsExcepted);
                    if (!currentNodeAudioIsExcepted) {
                        currentNodeAudioIsExcepted = true;
                        setSpeed(UConstants.DEFAULT_LOW_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_42);
                    }
                }
            }*/
        }
        avgDecibelNum++;
        avgDecibel += (float) decibel;
        avgDecibelNumBack++;
        avgDecibelBack += (float) decibel;
        currentDecibel = (float) decibel;
        MainApp.avgDecibel = inspectManager.getAvgDecibel();
        MainApp.avgDecibelBack = inspectManager.getAvgDecibelBack();
        if (System.currentTimeMillis() - decibelDisplayTime > 1000) {
            currentDecibelDisplay = currentDecibel;
            decibelDisplayTime = System.currentTimeMillis();
        }
    }

    private void audioAlarmresume(double decibel){
        setAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_RUNING, 0);
        if (getIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_RUNING)) {
            ULog.i(TAG, "audioAlarmresume: 分贝报警恢复3:" + decibel);
            setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_RUNING, false);
        }
        setAlarmCount(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_NOT_RUNING, 0);
        if (getIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_NOT_RUNING)) {
            ULog.i(TAG, "audioAlarmresume: 分贝报警恢复4:" + decibel);
            setIsAlarmReported(AlarmTypeEnum.AUDIO_EXCEED_THRESHOLD_EXCEPTION_BELT_NOT_RUNING, false);
        }

    }

    //    // TODO: 2019/5/1 音频数据回调
    @Override
    public void onAudioData(byte[] data, long currentTime) {
        //        if (irPusher.isPushing) {
        //            irPusher.pushAudioData(data, currentTime);
        //            //            ULog.e(TAG, "mAlivcLivePusher === AudioData:" + data.length);
        //        }
    }

    @Override
    public void onAudioPCMData(byte[] data, long currentTime) {
        if (irPusher.isPushing && (playAudio != null ? !playAudio.playSuccess : true)) {
            irPusher.pushAudioData(data, currentTime);
            //                        ULog.e(TAG, "Pusher === onAudioPCMData:" + data.length);
        }
        if (audioRecorder != null) {
            audioRecorder.putData(data);
        }
    }

    //    /**
    //     * 管理平台收不到消息，废弃不再使用
    //     * @param info
    //     * @return
    //     */
/*    @Deprecated
    public boolean sendMobileInfo(String info) {
        if (MqttManager.getInstance().isConnected() && accounts != null) {
            getExecutorService().execute(new SendMobileInfoEnable(info));
            return true;
        }
        return false;
    }*/

    @Override
    public void sendUpgradeInfo(MqttMsgCode code, Object val) {
        mMqttManager.broadcastShowInfoMsgCode(code, val);
    }

    public void sendUpgradeInfo(String info) {
        //        getExecutorService().execute(new SendUpgradeInfo(info));
        mMqttManager.broadcastShowInfo(info);
    }

    @Override
    public boolean isInitializedFinished() {
        return mIsRobotInitialized;
    }


/*
    class SendUpgradeInfo implements Runnable {
        MqttMsgCode code;
        Object val;

        public SendUpgradeInfo(String val) {
            this.val = val;
        }

        public SendUpgradeInfo(MqttMsgCode code, Object val) {
            this.code = code;
            this.val = val;
        }

        @Override
        public void run() {
            Thread.currentThread().setName("SendUpgradeInfo");
            if (upgradeInfos.size() == 0) return;
            MqttCommand command = new MqttCommand();
            command.setSource(getRobot().getId());
            command.setType(MqttCommand.ROBOT_SHOW_UPGRADE_INFO_INDEX);
            command.setCode(code);
            command.setValue(val);

            for (String accountId : upgradeInfos) {
                command.setTarget(accountId);
                mMqttManager.publishMessage(command);
                //延时0.5秒 要不然发消息有问题
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    ULog.d(TAG, "SendUpgradeInfo === e :" + e.getMessage());
                }
            }
        }
    }
*/

    /*
     */

    /**
     * 管理平台收不到消息，废弃不再使用
     *//*

    @Deprecated
    class SendMobileInfoEnable implements Runnable {
        String type;
        String action;
        String info;

        public SendMobileInfoEnable(String info) {
            this.info = info;
        }

        public SendMobileInfoEnable(String type, String action, String info) {
            this.type = type;
            this.action = action;
            this.info = info;
        }

        @Override
        public void run() {
            Thread.currentThread().setName("SendMobileInfoEnable");
            MqttCommand command = new MqttCommand();
            command.setSource(getRobot().getId());
            if (!TextUtils.isEmpty(type)) {
                command.setType(type);
            } else {
                command.setType(MqttCommand.ROBOT_SHOW_INFO_INDEX);
            }
            if (!TextUtils.isEmpty(action)) {
                command.setAction(action);
            }
            command.setValue(info);
            //            command.setTarget("U_100000044");
            //            mMqttManager.publishMessage(command);
            for (String accountId : accounts) {
                command.setTarget(accountId);
                mMqttManager.publishMessage(command);
                //延时0.5秒 要不然发消息有问题
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    ULog.d(TAG, "sendMobileInfo === e :" + e.getMessage());
                }
            }
            // 向运营平台发送位置
            if (accounts_Y != null && accounts_Y.size() != 0 && TextUtils.isEmpty(type)) {
                MqttCommand command_y = new MqttCommand();
                command_y.setSource(getRobot().getId());
                command_y.setType(MqttCommand.ROBOT_SHOW_INFO_INDEX);
                for (String accountId : accounts_Y) {
                    command_y.setTarget(accountId);
                    command_y.setValue(info);
                    if (MqttManager.getInstance().isConnected()) {
                        MqttManager.getInstance().publishMessage(command_y);
                        //延时0.1秒 要不然发消息有问题
                        try {
                            Thread.sleep(100);
                        } catch (InterruptedException e) {
                            ULog.d(TAG, "sendMobileLocation === e :" + e.getMessage());
                        }
                    }
                }
            }
        }
    }
*/
    private void quitAudioManager() {
        if (mAudioManager != null) {
            mAudioManager.unRegisterOnDecibelListener();
            mAudioManager.unRegisterOnAudioDataListener();
            mAudioManager.quit();
            mAudioManager = null;
        }
    }

    @Override
    public void onDestroy() {
        ULog.e(TAG, "onDestroy: ");
        TtsManager.getInstance().release();
        if(mqttReInitSubscribe != null && !mqttReInitSubscribe.isDisposed()){
            mqttReInitSubscribe.dispose();
        }
        if(bluetoothMqttSubscribe != null && !bluetoothMqttSubscribe.isDisposed()){
            bluetoothMqttSubscribe.dispose();
        }
        if (mHandler != null) {
            mHandler.removeCallbacksAndMessages(null);
            //            mHandler = null;
        }
        if (receiver != null) {
            mActivity.unregisterReceiver(receiver);
        }
        if (playAudio != null)
            playAudio.stop();
        quitAudioManager();
        mMqttManager.close();
        mMqttManager.unregisterMqttEventListener(this);
        stmExecute.unRegisterOnTaskListener(this);
        BaseBmsCommunicator.getInstance().unregisterDataEventListener(this);
/*        if (bmsMaExecute != null) {
            bmsMaExecute.unRegisterOnTaskListener(this);
        }*/

        if (isIrBind) {
            mActivity.unbindService(irConnection);
            isIrBind = false;
        }
        if (isRgbBind) {
            mActivity.unbindService(rgbConnection);
            isRgbBind = false;
        }
        if (isNetworkBind) {
            mActivity.unbindService(networkConnection);
            isNetworkBind = false;
        }
        pushCtrlAll(false);

        //        stopForeground(true);
        Intent intent = new Intent("fun.unifun.insbot.action.START_SERIVCE");
        mActivity.sendBroadcast(intent);
        super.onDestroy();
    }

    private void sensorRecordUpload() {
        try {
            if (getRobot() == null) return;
            Create request = new Create();
            List<SensorHistoryRecord> list = new ArrayList<>();
            SensorHistoryRecord para = new SensorHistoryRecord();
            para.setRobotId(getRobot().getId());
            para.setSegmentId(mSegment == null ? null : mSegment.getId());
            para.setMileage(BigDecimal.valueOf(mDistance));

            //烟雾  有配置单独传感器且为使用状态
            para.setSmoke(BigDecimal.valueOf(
                    (mSensorManager.cacheInfo().SMOKE_INFO != null && mSensorManager.cacheInfo().SMOKE_INFO.isEnabled())
                    ? currentHeartData.getSmokeStatus() : -10000));

            //PM2.5  有六合一器且为使用状态
            para.setPm25(BigDecimal.valueOf(
                    (mSensorManager.cacheInfo().SIX_IN_ONE_INFO != null && mSensorManager.cacheInfo().SIX_IN_ONE_INFO.isEnabled())
                    ? currentHeartData.getPm25Value() : -10000));

            //PM10  (有六合一器且为使用状态且非标准机型) 或 (有配置单独传感器且为使用状态)
            para.setPm10(BigDecimal.valueOf(
                    ((mSensorManager.cacheInfo().SIX_IN_ONE_INFO != null && mSensorManager.cacheInfo().SIX_IN_ONE_INFO.isEnabled() && mRobotType.getSubType() != RobotSubType.BZ) ||
                            (mSensorManager.cacheInfo().PM10_INFO != null && mSensorManager.cacheInfo().PM10_INFO.isEnabled()))
                    ? currentHeartData.getPm10Value() : -10000));

            //外部温度  (有六合一器且为使用状态) 或 (有温湿度传感器且为使用状态)
            para.setTemperature(BigDecimal.valueOf(
                    ((mSensorManager.cacheInfo().SIX_IN_ONE_INFO != null && mSensorManager.cacheInfo().SIX_IN_ONE_INFO.isEnabled()) ||
                            (mSensorManager.cacheInfo().TEMP_HUMIDITY_INFO != null && mSensorManager.cacheInfo().TEMP_HUMIDITY_INFO.isEnabled()))
                            ?  currentHeartData.getOutsideTempValue(): -10000));

            //外部湿度  (有六合一器且为使用状态) 或 (有温湿度传感器且为使用状态)
            para.setHumidity(BigDecimal.valueOf(
                    ((mSensorManager.cacheInfo().SIX_IN_ONE_INFO != null && mSensorManager.cacheInfo().SIX_IN_ONE_INFO.isEnabled()) ||
                            (mSensorManager.cacheInfo().TEMP_HUMIDITY_INFO != null && mSensorManager.cacheInfo().TEMP_HUMIDITY_INFO.isEnabled()))
                            ? currentHeartData.getOutsideHumidityValue(): -10000));
            //内部温度  心跳中是使能状态
            para.setInsideTemperature(BigDecimal.valueOf(currentHeartData.getInnerTempEnable() == SensorConstants.STATUS_ENABLED ?  currentHeartData.getInnerTempValue(): -10000));
            //内部湿度  心跳中是使能状态
            para.setInsideHumidity(BigDecimal.valueOf(currentHeartData.getInnerHumidityEnable() == SensorConstants.STATUS_ENABLED ? currentHeartData.getInnerHumidityValue(): -10000));


            boolean gasCollectionBoardEnabled = mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO != null &&
                    mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO.isEnabled();
            boolean gasBoardHaveChild = (gasCollectionBoardEnabled && mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO.getChildSensors() != null);

            CoSensorInfo coSensorInfoTemp = null;
            //Co2SensorInfo co2SensorInfoTemp = null;
            Ch4SensorInfo ch4SensorInfoTemp = null;
            O2SensorInfo o2SensorInfoTemp = null;
            if(gasBoardHaveChild){
                 coSensorInfoTemp = (CoSensorInfo)mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO.getChildSensors().get(SensorType.SENSOR_TYPE_CO);
                 //co2SensorInfoTemp = (Co2SensorInfo)mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO.getChildSensors().get(SensorType.SENSOR_TYPE_CO2);
                 ch4SensorInfoTemp = (Ch4SensorInfo)mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO.getChildSensors().get(SensorType.SENSOR_TYPE_CH4);
                 o2SensorInfoTemp = (O2SensorInfo)mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO.getChildSensors().get(SensorType.SENSOR_TYPE_O2);
            }

            //一氧化碳值  (有配置单独传感器且为使用状态)(有配置气体采集板且为使用状态且子传感器为使用状态)
            para.setCo(BigDecimal.valueOf((mSensorManager.cacheInfo().CO_INFO != null && mSensorManager.cacheInfo().CO_INFO.isEnabled()) ||
                    ((coSensorInfoTemp != null && coSensorInfoTemp.isEnabled()))
                            ? currentHeartData.getCoValue() : -10000));

            /*
            //TODO 二氧化碳不显示么? 改之前就没有 后面需要再加
            para.setCo2(BigDecimal.valueOf((mSensorManager.cacheInfo().CO2_INFO != null && mSensorManager.cacheInfo().CO2_INFO.isEnabled()) ||
                            ((co2SensorInfoTemp != null && co2SensorInfoTemp.isEnabled()))
                    ? currentHeartData.getCo2Value() : -10000));*/

            //甲烷  (有配置单独传感器且为使用状态)(有配置气体采集板且为使用状态且子传感器为使用状态)
            para.setCh4(BigDecimal.valueOf((mSensorManager.cacheInfo().CH4_INFO != null && mSensorManager.cacheInfo().CH4_INFO.isEnabled()) ||
                    ((ch4SensorInfoTemp != null && ch4SensorInfoTemp.isEnabled()))
                            ? currentHeartData.getCh4Value() : -10000));

            //氧气  (有配置单独传感器且为使用状态)(有配置气体采集板且为使用状态且子传感器为使用状态)
            para.setO2(BigDecimal.valueOf((mSensorManager.cacheInfo().O2_INFO != null && mSensorManager.cacheInfo().O2_INFO.isEnabled()) ||
                    ((o2SensorInfoTemp != null && o2SensorInfoTemp.isEnabled()))
                            ? currentHeartData.getO2Value(): -10000));

            //氨气  (有配置单独传感器且为使用状态)
            para.setConcentration(BigDecimal.valueOf(
                    ((mSensorManager.cacheInfo().NH3_INFO != null && mSensorManager.cacheInfo().NH3_INFO.isEnabled()))
                    ? currentHeartData.getNh3Value() : -10000));

            //氢气  (有配置单独传感器且为使用状态)
            para.setH2(BigDecimal.valueOf(
                    ((mSensorManager.cacheInfo().H2_INFO != null && mSensorManager.cacheInfo().H2_INFO.isEnabled()))
                    ? currentHeartData.getH2Value() : -10000));

            //六氟化硫  (有配置单独传感器且为使用状态)
            para.setSf6(BigDecimal.valueOf(
                    ((mSensorManager.cacheInfo().SF6_INFO != null && mSensorManager.cacheInfo().SF6_INFO.isEnabled()))
                            ? currentHeartData.getSf6Value(): -10000));

            //硫化氢  (有配置单独传感器且为使用状态)
            para.setH2s(BigDecimal.valueOf(
                    ((mSensorManager.cacheInfo().H2S_INFO != null && mSensorManager.cacheInfo().H2S_INFO.isEnabled()))
                            ? currentHeartData.getH2sValue(): -10000));

            //分贝
            para.setDecibel(BigDecimal.valueOf(getRobot().getDecibel() != null ? getRobot().getDecibel() : -10000));
            para.setRecordTime(new Date());

            list.add(para);
            ULog.d(TAG,"sensorRecordUpload list"+UGson.getGson().toJson(list));
            request.setSensorHistoryRecords(list);
            UOKHttp.post(UrlManager.getBaseUrl(), request, new UOKHttp.RequestCallBack<Create>(Create.class) {
                @Override
                public void onFailure(Call call, IOException e) {
                    e.printStackTrace();
                    ULog.d(TAG, "onFailure:  == sensorRecordUpload  e:" + e.getMessage());
                }

                @Override
                public void onResponseOk(Call call, Create result) {
                    ULog.d(TAG, "onResponseOk: == sensorRecordUpload");
                }

                @Override
                public void onResponseError(Call call, int i, String s) {
                    ULog.d(TAG, "onResponseError:  == sensorRecordUpload " + s);
                }
            });
        } catch (Exception e) {
            ULog.w(TAG, "sensorRecordUpload error", e);
            CrashReport.postCatchedException(e, Thread.currentThread());
            e.printStackTrace();
        }
    }

    /**
     * 服务器心跳
     */
    private void connectTest() {
        final long startTime = System.currentTimeMillis();

        ConnectTest connectRequest = new ConnectTest();
        connectRequest.setRobotId(getRobot().getId());
        ULog.d(TAG, "ConnectTest === UrlManager.getBaseUrl() = " + UrlManager.getBaseUrl() +
                ", getNetWorkType = " + UrlManager.getNetWorkType() +
                ", getServerAddr = " + UrlManager.getServerAddr() +
                " connectTest" +
                ".getRobotId=" + connectRequest.getRobotId() + ", time:" + startTime);

        RobotServiceImpl.getInstance().getRobotService()
                .connectTest(connectRequest)
                .observeOn(Schedulers.io())
                .subscribe(new NextErrorObserver<CommonRetWrapper<ConnectTest>>() {
                    @Override
                    public void onNext(@NonNull CommonRetWrapper<ConnectTest> resultWrapper) {
                        ConnectTest ret = resultWrapper.getData();
                        networkErrorNum = 0;
                        if (mHandler.hasMessages(Msg.WHAT_IFCONFIG_EXCEPTION)) {
                            mHandler.removeMessages(Msg.WHAT_IFCONFIG_EXCEPTION);
                        }

                        boolean robotIsCache = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_ROBOT_FROM_CACHE_KEY, false);
                        ULog.d(TAG, "onResponseOk: == ConnectTest . startTime:" + startTime + ", delay:" + (System.currentTimeMillis() - startTime) + " robotIsCache " + robotIsCache);
                        if (robotIsCache) {
                            long lastKillOneselfTime = UPreferences.getLong(mActivity, UConstants.PREFERENCES_KILL_ONESELF_TIME_KEY, -1);
                            boolean isKill = lastKillOneselfTime == -1;
                            if (lastKillOneselfTime != -1 && System.currentTimeMillis() - lastKillOneselfTime > 60_000) {
                                isKill = true;
                                UPreferences.putLong(mActivity, UConstants.PREFERENCES_KILL_ONESELF_TIME_KEY, System.currentTimeMillis());
                            }
                            ULog.d(TAG, "机器人数据是从缓存读取机器人数据的，3秒后重启程序，重新获取最新数据 lastKillOneselfTime " + lastKillOneselfTime + " diffTime " + (System.currentTimeMillis() - lastKillOneselfTime) + " isKill " + isKill);
                            if (isKill) {
                                mHandler.postDelayed(() -> {
                                    URootCmd.execRootCmdSilent("kill -9 " + android.os.Process.myPid());
                                }, 3000);
                            }
                        }
/*                        Map<String, Object> connectTestMap = new HashMap<>();
                        connectTestMap.put("connectTest", "success");
                        MainApp.from(mActivity).pushLogMap(connectTestMap);*/
/*                        if (!serverHeartNormal) { // && isMove) {
                            MainApp.from(mActivity).pushLog("网络恢复");
                        }*/
                        serverHeartNormal = true;
                        serverHeartNormalTime = System.currentTimeMillis();

                        if (resultWrapper.getTime() != null) {
                            long diff = resultWrapper.getTime() - System.currentTimeMillis();
                            if (Math.abs(diff) > TimeUnit.SECONDS.toMillis(5)) {
                                ULog.w(TAG, "time diff between system and server larger than 5 minutes, correct again");
                                mBotInfoMgr.calibrateSystemTime(resultWrapper.getTime().toString());
                            }
                        }

                        mHandler.removeMessages(Msg.WHAT_SERVER_HEART_STOP_TIMEOUT);
                    }

                    @Override
                    public void onError(@NonNull Throwable e) {
                        ULog.d(TAG, "onResponseError:  == ConnectTest , isReConnect=" + isReConnect + " , resultMsg=" + e.getMessage());
                        mHandler.sendEmptyMessageDelayed(Msg.WHAT_SERVER_HEART_STOP_TIMEOUT,
                                mBotInfoMgr.getRobotConfigParams().getHeartStopTimeoutSeconds() * 1000L);
                        //TODO  (临时) 如果是和林机器人 RK_10000112 && 电梯类型 && 移动方向是向尾端行驶  则不停止机器人继续走 && 节点的 ordernum在 某---某之间
                        if (!mHandler.hasMessages(Msg.WHAT_IFCONFIG_EXCEPTION)) {
                            mHandler.sendEmptyMessageDelayed(Msg.WHAT_IFCONFIG_EXCEPTION, 8000);
                        }
                        String ifconfig = URootCmd.execRootCmd("ifconfig");
                        if (ifconfig == null || ifconfig.length() < 180) {
                            if (mHandler.hasMessages(Msg.WHAT_IFCONFIG_EXCEPTION)) {
                                mHandler.removeMessages(Msg.WHAT_IFCONFIG_EXCEPTION);
                            }
                            ifconfigException(ifconfig);
                            ULog.d(TAG, "ifconfig error:" + ifconfig);
                        } else {
                            if (mHandler.hasMessages(Msg.WHAT_IFCONFIG_EXCEPTION)) {
                                mHandler.removeMessages(Msg.WHAT_IFCONFIG_EXCEPTION);
                            }
                            ULog.d(TAG, "ifconfig === " + ifconfig);
                        }
       /*                 if (isOfflineLocation(mDistance)) {

                        } else {
                            if (!isReConnect) {
                                //如果AP重连不累加到结果
                                serverHeartStopHandle();
                            }
                        }*/
                    }
                });
        ;
    }

    private void ifconfigException(String ifconfig) {
        ULog.d(TAG, "ifconfigException === " + networkErrorNum);
        networkErrorNum++;
        if (networkErrorNum >= 3) {
            ULog.d(TAG, "ifconfig error 重启板子");
            String timeStr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.CHINA).format(new Date());
            StorageCenter.getRobotStorage().putString(KeyConstant.Storage.LAST_REBOOT_REASON, "ifconfig error: " + ifconfig);
            StorageCenter.getRobotStorage().putString(KeyConstant.Storage.LAST_REBOOT_TRIGGER_TIME, timeStr);
            StorageCenter.getRobotStorage().save();
            try {
                Thread.sleep(1500);
            } catch (InterruptedException e1) {
                e1.printStackTrace();
            }
            URootCmd.execRootCmdSilent("reboot");
        }
    }

    public void setRobotDirection(int robotDirection ,String logTag) {
        ULog.dtf(TAG,
                "setRobotDirection = {}; TakeImgInspectManager.isRunning = {}; MODE = {}; " +
                        "mOnInspectionTurnAroundListener == null >{} logTag:{}",
                robotDirection,
                TakeImgInspectManager.isRunning,
                MODE,
                mOnInspectionTurnAroundListener == null,
                logTag);
        UPreferences.putInt(mActivity, UConstants.PREFERENCES_DIRECTION_KEY, robotDirection);
        if (RobotFragment.robotDirection != robotDirection ) {
            if (isInspectionMode()) {
                MainApp.turnAroundDate = System.currentTimeMillis();
                UPreferences.putLong(mActivity, UConstants.PREFERENCES_TURN_AROUND_DATE_KEY, MainApp.turnAroundDate);
            }
            if(TakeImgInspectManager.isRunning && (MODE == MODE_INSPECTION || MODE == MODE_CHECKING_STOP)){
                if (mOnInspectionTurnAroundListener != null) {
                    RobotFragment.robotDirection = robotDirection;
                    mOnInspectionTurnAroundListener.onInspectionTurnAround();
                }
            }

            if(onTurnaroundListener != null){
                RobotFragment.robotDirection = robotDirection;//这里先多改下,防止 onTurnaround 的相关其他逻辑使用 RobotFragment.robotDirection 时出错
                onTurnaroundListener.onTurnaround(robotDirection);
            }


            if (MODE == MODE_INSPECTION && MainApp.isRecordVideoAutoRecognition && robotDirection == MOVE_FRONT) {
                ULog.d(TAG, "标定录像模式下 切换方向为向前，可能已经到达尾端，停止移动 停止录像");
                mHandler.postDelayed(() -> {
                    stmExecute.executeTaskNonQueue(new StmTask().stopMove("标定录像模式下 切换方向为向前，可能已经到达尾端，停止移动 停止录像 69"));
                    setMode(MODE_UN_KNOW, "正常模式-标定录像模式下,切换方向为向前,可能已经到达尾端,停止移动,停止录像");
                }, 1000);
            }
            //修改逻辑机器人巡检时走正常任务节点的巡检 TODO remove
            /*if(MainApp.isReclaimer && MODE == MODE_INSPECTION){
                ReclaimerInspectionUtil.getInstance(RobotFragment.this).onInspectionTurnAround();
            }*/
        }

        ULog.d(TAG, " setRobotDirection robotDirection=>" + robotDirection);
        RobotFragment.robotDirection = robotDirection;
        MainApp.mRobotDirection = robotDirection;
    }
    long modeUnknowTime;
    public static Date startInspectionTime = new Date(0); //开始巡检的时间
    private boolean isCacheStartInspectTime;
    private boolean isCacheTurnAroundDate;

    /**
     * 注意 tag为   recover_mode 是恢复异常情况之前mode
     */
    public void setMode(int mode, String tag) {
        changeModeCalendar = Calendar.getInstance();   //记录修改时间
        int lastMode;
        if (MODE == MODE_UN_KNOW) {
            lastMode = UPreferences.getInt(mActivity, UConstants.PREFERENCES_MODE_KEY);
        } else {
            lastMode = MODE;
        }
        MainApp.MODE = mode;
        if(mode != MODE_MOVE_TO_TARGET){
            tgtLocation = UConstants.UNKONW;
            tgtDirection = UConstants.UNKONW;
        }
        MainApp.inspectIsSelf = UPreferences.getBoolean(mActivity, UConstants.PREFERENCES_INSPECT_IS_SELF, false);
        ULog.i(TAG, "setMode: mode=" + mode + " currentMode = " + MODE + ", tag=" + tag + " lastMode=" + lastMode + " inspectIsSelf " + MainApp.inspectIsSelf);
        if (needOpenDusting && lastMode == MODE_UN_KNOW & mode != lastMode) {
            needOpenDusting = false;
        }

        //进入巡检模式 记录下时间(非巡检到指定点)
        if (mode == MODE_INSPECTION && lastMode != MODE_INSPECTION && lastMode != MODE_CHECKING_STOP && !isTargetInspection()) {
            updateHistoryTime(TimeType.ROBOT_START_INSPECTION_TIME, "5");
            if (!isCacheStartInspectTime || startInspectionTime == null) {
                startInspectionTime = new Date();
            }
            UPreferences.putLong(mActivity, UConstants.PREFERENCES_INSPECTION_START_DATE_KEY, startInspectionTime.getTime());
        }

        //退出巡检模式 记录下时间(非巡检到指定点)
        if ((mode != MODE_INSPECTION && mode != MODE_CHECKING_STOP) && (lastMode == MODE_INSPECTION || lastMode == MODE_CHECKING_STOP) &&
                !isTargetInspection()) {
            updateHistoryTime(TimeType.ROBOT_STOP_INSPECTION_TIME, "6");
        }

        //从闲置状态进入到检测托辊状态
        if ((mode == MODE_INSPECTION || mode == MODE_GOTO_CHARGER) &&
                (lastMode != MODE_INSPECTION && lastMode != MODE_GOTO_CHARGER && lastMode != MODE_CHECKING_STOP) &&
                !isTargetInspection()) {
            if (!isCacheTurnAroundDate || MainApp.turnAroundDate == 0) {
                MainApp.turnAroundDate = System.currentTimeMillis();
                UPreferences.putLong(mActivity, UConstants.PREFERENCES_TURN_AROUND_DATE_KEY, MainApp.turnAroundDate);
            } else {
                isCacheTurnAroundDate = false;
            }
        }
        //从巡检状态退出
        if ((lastMode == MODE_INSPECTION || lastMode == MODE_GOTO_CHARGER || lastMode == MODE_CHECKING_STOP) &&
            (mode != MODE_INSPECTION && mode != MODE_GOTO_CHARGER && mode != MODE_CHECKING_STOP) &&
                !isTargetInspection()) {
            ULog.d(TAG, "exit_inspection 从巡检状态退出");
            RecordIrData.enableRange(false);
            inspectManager.avgDecibelReset();
            RecordIrData.enableRangeBack(false);
            inspectManager.avgDecibelBackReset();
        }
        if (MainApp.inspectIsSelf && (lastMode == MODE_INSPECTION || lastMode == MODE_CHECKING_STOP) && mode != MODE_INSPECTION) {
            //自动触发巡检中退出巡检 巡检次数统计
            if (mode == MODE_GOTO_CHARGER && AutoMoveManager.mTargetChargerNodeW != null) { //自动巡检切回充
                int goChargerDirection = 0;
                if (AutoMoveManager.mTargetChargerNodeW.getNode() != null && AutoMoveManager.mTargetChargerNodeW.getNode().getDistance() != null) {
                    goChargerDirection = MapManager.getInstance().computeNearDir(mDistance, AutoMoveManager.mTargetChargerNodeW.getNode().getDistance());
                    ULog.d(TAG, "退出巡检模式切回充 正常回充 目标" + AutoMoveManager.mTargetChargerNodeW.getNode().getDistance());
                } else {
                    goChargerDirection = MapManager.getInstance().computeNearDir(mDistance, AutoMoveManager.getTargetChargerLocation());
                    ULog.d(TAG, "退出巡检模式切回充 指定位置回充 目标" + AutoMoveManager.getTargetChargerLocation());
                }

                if (robotDirection != goChargerDirection) { //和巡检方向不一致
                    if (AutoMoveManager.maxRFIDDistance != Float.MAX_VALUE) {
                        float inspectMile = Math.abs(mDistance - startStatisticLocation);
                        if (inspectMile >= AutoMoveManager.maxRFIDDistance / 2) {
                            if (robotDirection == MOVE_END) {
                                statisticToMapEnd("切回充中止巡检");
                            } else {
                                statisticToMapHead("切回充中止巡检");
                            }
                            if (InspectManager.getHeadEndReportFlag()) { //头尾条件都已达成，只差偏差计算
                                InspectManager.handledVarianceFlag();
                            }
                        }
                    }
                } else { //和巡检方向一致 待回充结束后再说
                    UPreferences.putInt(mActivity, "stop_inspect_statistic", 1);
                    UPreferences.putInt(mActivity, "stop_inspect_statistic_dir", robotDirection);
                }
            } else {
                float inspectMile = Math.abs(mDistance - startStatisticLocation);
                if (inspectMile >= AutoMoveManager.maxRFIDDistance / 2) {
                    if (robotDirection == MOVE_END) {
                        statisticToMapEnd("退出中止巡检_" + mode);
                    } else {
                        statisticToMapHead("退出中止巡检_" + mode);
                    }
                    if (InspectManager.getHeadEndReportFlag()) { //头尾条件都已达成，只差偏差计算
                        InspectManager.handledVarianceFlag();
                    }
                }
            }
        }

        if (mode != MODE_INSPECTION && isTargetInspection()) {
            inspectManager.clearInspectTargetInfo();
        }
        if (mode != MODE_GOTO_CHARGER
                && AutoMoveManager.mTargetChargerNodeW != null
                && AutoMoveManager.mTargetChargerNodeW.getChargerNodeType() == ChargerNodeType.TARGET_LOCATION) {
            AutoMoveManager.mTargetChargerNodeW = null;
        }
        if (TakeImgInspectManager.isRunning && mode != MODE_INSPECTION && mode != MODE_CHECKING_STOP) {
            ULog.d(TAG, "isRuning =" + TakeImgInspectManager.isRunning + " mode=" + mode);
            getExecutorService().execute(() -> {
                TakeImgInspectManager.getInstance(RobotFragment.this).startCheckOrClose(2,"5");
            });
        }
        if (MainApp.isReclaimer && lastMode == MODE_RECLAIMER && mode != MODE_RECLAIMER) {
            ULog.d(TAG, "reclaimer 退出取料机巡检");
            ReclaimerInspection.getInstance(this).stopRecognise();
        }

        //廊道巡检
        if (isCorridorInspection) {
            if (mode != MODE_INSPECTION) {
                setCorridorInspection(false);
            }
        }

        //这个目前只是针对Rgb拍照巡检的情况下 非检测模式和巡检模式 通知检测服务停止检测
        if(isNeedCheckAruco
                && (lastMode == MODE_INSPECTION || lastMode == MODE_CHECKING_STOP)
                && (mode != MODE_INSPECTION && mode != MODE_CHECKING_STOP)){
            isServerStartRecogniseRGB = false;
            mHandler.removeMessages(Msg.WHAT_RGB_RECOGNITION_INSPECT);
            mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_INSPECTION_STOP_RGB_RECOGNISE_ACTION, "STOP");
        }

        MODE = mode;
        UPreferences.putInt(mActivity, UConstants.PREFERENCES_MODE_KEY, mode);
        if (MODE == MODE_RECLAIMER) {
            ReclaimerInspection.startIng = false;
        }
        if (MODE == MODE_UN_KNOW) {
            modeUnknowTime = System.currentTimeMillis();
        }
        if (MODE == MODE_INSPECTION) {
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_INSPECT_ALARM, 1000);
        }
        if (MODE != MODE_INSPECTION && MODE != MODE_CHECKING_STOP) {
            int recordVideMode = UPreferences.getInt(mActivity, UConstants.PREFERENCE_RECORD_VIDEO_MODE_KEY, -1);
            UPreferences.putInt(mActivity, UConstants.PREFERENCE_RECORD_VIDEO_MODE_KEY, -1);
            if (lastMode == MODE_INSPECTION) {
                removeRetryInspectMsg();
                if (MainApp.isRecordVideoAutoRecognition) {
                    ULog.d(TAG, "recordVideo 退出 录制视频自动标定 记录当前里程 " + mDistance);
                    MainApp.isRecordVideoAutoRecognition = false;
                    isServerStartRecordVideoRecog = false;
                    StorageCenter.getRobotStorage().putFloat(UConstants.PREFERENCES_RECORD_VIDEO_CONTINUE_MILEAGE_KEY, mDistance);
                    StorageCenter.getRobotStorage().saveAsync();
                    if (recordVideMode == 2) mMqttManager.sendMessage("INSPECTION-" + UrlManager.getServerIp(), MqttCommand.ROBOT_INSPECTION_INDEX_TYPE, MqttCommand.ROBOT_RECORD_VIDEO_RECOGNISE_STOP_ACTION, "STOP");
                }
            }
        }
        if (getRobot() != null) {
            getRobot().setMode(mode);
            isUpdateRobot = true;
            robotStatusUpload(4);
        }
        if(onRobotModeChangeListener != null){
            onRobotModeChangeListener.robotModeChange(lastMode,mode,tag);
        }
        //回充过程中空检关闭摄像头
        if (MODE == MODE_GOTO_CHARGER) {
            mHandler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    if (MODE == MODE_GOTO_CHARGER) {
                        updatePushEnable("2");
                    }
                }
            }, 5000);
        }
    }
    private OnRobotModeChangeListener onRobotModeChangeListener;

    public void setOnRobotModeChangeListener(OnRobotModeChangeListener onRobotModeChangeListener) {
        this.onRobotModeChangeListener = onRobotModeChangeListener;
    }

    public interface OnRobotModeChangeListener{
        void robotModeChange(int previousMode,int mode,String tag);
    }

    public boolean isTargetInspection() {
        return (InspectManager.targetInspectLocation != UConstants.UNKONW || targetInspectDirection != UConstants.UNKONW);
    }
    /**
     * 将mode设置回原来的值
     * 只有mode未被其他状况修改时才允许恢复
     * <p>
     * 可能发生的问题：若有多个状况先后调用 {@link #setTempMode}，同时没有其他状况直接调用 {@link #setMode}
     * 此时某个状况调用本函数时便会出现问题，因为mode已被其他状况通过#setTempMode 进行了修改，而本函数的时间差检测并不能发现这种修改。
     * <p>
     * mode的修改是小概率事件，该问题可暂时忽略
     */
    private void recoverMode() {
        if (changeTempModeCalendar == null || changeModeCalendar == null) {
            return;   //从未设置无从恢复
        }

        /**
         * 当 {@link setModeCalendar} 和 {@linkplain setTempModeCalendar}
         * 时间差足够小时才认定mode未被其他状况修改，并允许恢复
         */
        long timeDifference = changeTempModeCalendar.getTimeInMillis()
                - changeModeCalendar.getTimeInMillis();  //时差
        timeDifference = Math.abs(timeDifference);                  //取绝对值
        if (timeDifference > 100) {
            ULog.w(TAG, "time diff > 100 , cannot recover mode");
            return;                                    //时差超过100毫秒，可以认定已被其他状况修改，不便恢复
        }

        ULog.d(TAG, "recover mode:" + originalMode);
        setMode(originalMode, "recover_mode");      //允许恢复
    }

    /**
     * 设置临时MODE
     * 即可能需要恢复原MODE，恢复使用{@link #recoverMode}
     *
     * @param mode mode
     */
    private void setTempMode(int mode) {
        //记录
        originalMode = MODE;                     //记录原MODE值
        changeTempModeCalendar = Calendar.getInstance();   //记录修改时间

        setMode(mode, "temp-setTempMode");
    }

    public void continueMove() {
        if (RobotActionCode.isHindranceCode(mBotInfoMgr.getRobotActionCode())) {
            ULog.w(TAG, "continueMove 正在执行运动阻碍相关逻辑");
            return;
        }
        stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
    }

    public void continueInspectionMove() {
        if (RobotActionCode.isHindranceCode(mBotInfoMgr.getRobotActionCode())) {
            ULog.w(TAG, "continueInspectionMove 正在执行运动阻碍相关逻辑");
            return;
        }
        if (MODE == MODE_INSPECTION || MODE == MODE_CHECKING_STOP) {
            stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
        }
    }

    public void executeStmCommand(StmTask stmCommand) {
        stmExecute.executeTask(stmCommand);
    }


    public void executeStmCommandNonQueue(StmTask stmCommand) {
        stmExecute.executeTaskNonQueue(stmCommand);
    }

    //记录上一次掉头的时间
    private long mLastTurnAroundTime = 0L;

    public void initInspectionParams(int direction) {
        inspectManager.initInspectionParams(direction);
    }
    public void switchToNextNode() {
        inspectManager.switchToNextNode();
    }

    //是否处于检测状态
    public boolean isInspectionMode() {
        return MODE == MODE_GOTO_CHARGER || MODE == MODE_INSPECTION || MODE == MODE_CHECKING_STOP;
    }
    //是否在执行巡检到指定位置
    public boolean isInspectToLocation() {
        return inspectManager.isInspectToLocation();
    }
    //巡检调头
    public void inspectionTurnAround(int targetDirection) {
        if (robotDirection != targetDirection) {
            ULog.d(TAG, "inspectionTurnAround == 换方向 " + targetDirection);
            setRobotDirection(targetDirection,"23");
            new Thread(new Runnable() {
                @Override
                public void run() {
                    Thread.currentThread().setName("updatePushEnable");
                    updatePushEnable("3");
                }
            }).start();
            //换方向时 甲乙皮带启动有变化 重新开始巡检
            if (inspectManager.inspectDirection != inspectManager.inspectDirectionBackup) {
                inspectManager.initInspectionParams(targetDirection);
            }
        }
        //防止边界堵转时高频调用
        if (System.currentTimeMillis() - mLastTurnAroundTime >= 3000) { // && !MainApp.isReclaimer
            mLastTurnAroundTime = System.currentTimeMillis();
            stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
            if (MODE != MODE_DEVICE_CLEAN) {
                if (Math.abs(getRobot().getSpeed()) > UConstants.DEFAULT_SPEED)
                    setSpeed(UConstants.DEFAULT_SPEED, RobotSetSpeedLogTags.SPEELD_lOG_TAG_43);
            }
            //            autoMoveManager.lastRealRFID = "";
            inspectManager.resetTurnAroundFlag();
        }
    }

    private long speedTime;
    private long speedStopTime;
    private float lastSpeed;
    private String lastSpeedTag;
    private volatile boolean setSpeedInterrupt;

    @Override
    public void setSpeed(float target, String logTag) {
        if (mRobotType == null) {
            return;
        }

        if (!NumberUtil.isInRange(target, getRobot().getSpeedMin(), MainApp.getRobotMaxSpeed())) {
            target = NumberUtil.cropInRange(target, getRobot().getSpeedMin(), MainApp.getRobotMaxSpeed());
        }

        if(getRobotConfigParams() != null){
            if(getRobotConfigParams().isHaveSwitchTrack() && SwitchTrackController.ST_DEVICE_NEAR && (target > UConstants.DEFAULT_ELEVATOR_NEAR_SPEED)){
                ULog.d(TAG,"setSpeed SwitchTrackController 变轨设附近 设置的速度大于变轨设备附近速度"+UConstants.DEFAULT_ELEVATOR_NEAR_SPEED +"已自动修正");
                target = UConstants.DEFAULT_ELEVATOR_NEAR_SPEED;
            }

            if (getRobotConfigParams().isHaveElevator() &&  (MainApp.elevatorDeviceNear || MainApp.nnnNodeisElevator) && (target > UConstants.DEFAULT_ELEVATOR_NEAR_SPEED)) {
                ULog.d(TAG,"setSpeed ElevatorController 电梯设附近 设置的速度大于电梯设备附近速度"+UConstants.DEFAULT_ELEVATOR_NEAR_SPEED +"已自动修正");
                target = UConstants.DEFAULT_ELEVATOR_NEAR_SPEED;
            }
        }

        if ((BigDecimal.valueOf(target).compareTo(BigDecimal.valueOf(lastSpeed)) == 0) && (System.currentTimeMillis() - speedTime) < 5000) {
            return;
        }
        if ((System.currentTimeMillis() - speedTime) < 2000 && !logTag.contains("cokeOven_") && !logTag.contains("motorBackwardResumeMove") && !lastSpeedTag.contains("cokeOven_") &&
                !logTag.contains("elevatorNear_") && !lastSpeedTag.contains("elevatorNear_"))
        {
            ULog.d(TAG, "setSpeed 修改速度过于频繁，拒绝 " + target + " logTag= " + logTag);
            return;
        }
        if ((System.currentTimeMillis() - speedTime) < 6000 && RobotActionCode.isHindranceCode(RobotInfoManager.getInstance().getRobotActionCode()) && !logTag.contains("motorBackwardResumeMove")) {
            ULog.d(TAG, "setSpeed 修改速度 运动阻碍准备加速通过 6s内，拒绝 " + target + " logTag= " + logTag);
            return;
        }
        lastSpeedTag = logTag;

        ULog.d(TAG, "setSpeed: target=" + target + " logTag= " + logTag);
        setSpeedInterrupt = true;
        boolean isTy = mRobotType.getSubType() == RobotSubType.TY;
        lastSpeed = target;
        speedTime = System.currentTimeMillis();
        float finalTarget = target;
        if (robotIsStop()) {
            stmExecute.executeTask(new StmTask().setSpeed(finalTarget));
            return;
        }
        getExecutorService().execute(() -> {
            Thread.currentThread().setName("setSpeed");
            if (getRobot() != null) {
                float current = Math.abs(getRobot().getSpeed());
                //TODO 关键:------- 判断煤安版设置速度代码 请勿删除 ↓
                if (mRobotType.getSubType() == RobotSubType.FB || mRobotType.getSubType() == RobotSubType.MA) {
                    stmExecute.executeTask(new StmTask().setSpeed(finalTarget));
                } else {
                    if (finalTarget >= current && !isTy) {
                        stmExecute.executeTask(new StmTask().setSpeed(finalTarget));
                    } else {
                        setSpeedInterrupt = false;
                        boolean isLosing = Math.abs(getRobot().getSpeed()) > Math.abs(finalTarget);
                        float dValue = Math.abs(Math.abs(getRobot().getSpeed()) - Math.abs(finalTarget));
                        float temp = current;
                        while (dValue > 0.1) {
                            temp = isLosing ? temp - 0.1f : temp + 0.1f;
                            speedTime = System.currentTimeMillis();
                            stmExecute.executeTask(new StmTask().setSpeed(temp));
                            dValue = Math.abs(temp - finalTarget);
                            if (setSpeedInterrupt) return;
                            try {
                                Thread.sleep(200);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            if (setSpeedInterrupt) return;
                        }
                        if (setSpeedInterrupt) return;
                        stmExecute.executeTask(new StmTask().setSpeed(finalTarget));
                    }
                }
            }
        });
    }
    public static long setSpeedDelay = 700;
    public void setSpeedDecrement(float target, String logTag) {
        if (mRobotType == null) {
            return;
        }

        if (!NumberUtil.isInRange(target, getRobot().getSpeedMin(), MainApp.getRobotMaxSpeed())) {
            target = NumberUtil.cropInRange(target, getRobot().getSpeedMin(), MainApp.getRobotMaxSpeed());
        }

        if ((BigDecimal.valueOf(target).compareTo(BigDecimal.valueOf(lastSpeed)) == 0) && (System.currentTimeMillis() - speedTime) < 5000) {
            return;
        }
        if ((System.currentTimeMillis() - speedTime) < 2000 && !logTag.contains("cokeOven_") && !lastSpeedTag.contains("cokeOven_")) {
            ULog.d(TAG, "修改速度过于频繁，拒绝 " + target + " logTag= " + logTag);
            return;
        }
        lastSpeedTag = logTag;
        ULog.d(TAG, "setSpeed: target=" + target + " logTag= " + logTag);
        setSpeedInterrupt = true;
        float tempLastSpeed = lastSpeed;
        lastSpeed = target;
        speedTime = System.currentTimeMillis();
        float finalTarget = target;
        getExecutorService().execute(() -> {
            Thread.currentThread().setName("setSpeed");
            if (getRobot() != null) {
                float current = Math.abs(getRobot().getSpeed());
                setSpeedInterrupt = false;
                //根据上次速度减速，焦炉场景，防止没加速直接减到最低
                float dValue = Math.abs(tempLastSpeed) - finalTarget;
                float temp = tempLastSpeed;
                while (dValue > 0.07) {
                    temp -= 0.07;
                    speedTime = System.currentTimeMillis();
                    stmExecute.executeTask(new StmTask().setSpeed(temp));
                    dValue = temp - finalTarget;
                    if (setSpeedInterrupt) return;
                    try {
                        Thread.sleep(setSpeedDelay);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (setSpeedInterrupt) return;
                }
                if (setSpeedInterrupt) return;
                stmExecute.executeTask(new StmTask().setSpeed(finalTarget));
            }
        });
    }

    long combineFrameHandleTime;
    int pushType;
    boolean isPush;

    class CombineFrameHandle implements Runnable {
        @Override
        public void run() {
            Thread.currentThread().setName("CombineFrameHandle");
            ULog.d(TAG, "pushir CombineFrameHandle start");
            while (!isCombineStop) {
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //                ULog.d(TAG, "run:  ===fuck alivcpush =  1`111111111111======  =  " + (System.currentTimeMillis() - combineFrameHandleTime) + "   ir  = " + irBuffer.size() + "   rgb  " + rgbBuffer.size());
                combineFrameHandleTime = System.currentTimeMillis();
                irBuffUseIndexTemp = (irBuffUseIndex + 1) % irBuff.length;
                rgbBuffUseIndexTemp = (rgbBuffUseIndex + 1) % rgbBuff.length;
                if (irBuff[irBuffUseIndexTemp].isReadyToFill || rgbBuff[rgbBuffUseIndexTemp].isReadyToFill) {
                    continue;
                }
                //                    ULog.d(TAG, "run:  ===fuck alivcpush = 222222222 ir " + irBuffer.size() + " " + (irFrame == null) + " rgb " + rgbBuffer.size() + " " + (rgbFrame == null) + "   ===  " + (System.currentTimeMillis() - combineFrameHandleTime));
                VideoUtils.TwoImageCombine(irBuff[irBuffUseIndexTemp].buff,
                        pushWidthIr,
                        pushHeightIr,
                        rgbBuff[rgbBuffUseIndexTemp].buff,
                        pushWidthRgb,
                        pushHeightRgb,
                        4,
                        21,
                        outputFrame);
                //              ULog.d(TAG, "run:  === alivcpush = 5555555 " + (outMain == null ? "null" : outMain.length) + " isPushing = " + isPushing);


                irBuffUseIndex = irBuffUseIndexTemp;
                irBuff[irBuffUseIndex].isReadyToFill = true;
                rgbBuffUseIndex = rgbBuffUseIndexTemp;
                rgbBuff[rgbBuffUseIndex].isReadyToFill = true;

                if (isPush) {
                    pushBuffIndexTemp = (pushBuffIndex + 1) % pushBuff.length;
                    if (pushBuff[pushBuffIndexTemp].isReadyToFill) {
                        System.arraycopy(outputFrame, 0, pushBuff[pushBuffIndexTemp].buff, 0, pushBuff[pushBuffIndexTemp].buff.length);
                        pushBuffIndex = pushBuffIndexTemp;
                        pushBuff[pushBuffIndex].isReadyToFill = false;
                        //                        ULog.d(TAG, "run: ==pushbuffer===填充数据");
                    }
                }
                //                if (isIrRecordFile) {
                //                    recordBuffIndexTemp = (recordBuffIndex + 1) % recordBuff.length;
                //                    if (recordBuff[recordBuffIndexTemp].isReadyToFill) {
                //                        System.arraycopy(outputFrame, 0, recordBuff[recordBuffIndexTemp].buff, 0, recordBuff[recordBuffIndexTemp].buff.length);
                //                        recordBuffIndex = recordBuffIndexTemp;
                //                        recordBuff[recordBuffIndex].isReadyToFill = false;
                //                    }
                //                }
                //            ULog.d(TAG, "run:  ===fuck alivcpush = 4444444 ==== " +  (System.currentTimeMillis() - combineFrameHandleTime));

            }
            ULog.d(TAG, "pushir CombineFrameHandle end");
        }

    }

    long pushFrameHandleTime;

    class PushFrameHandle implements Runnable {
        @Override
        public void run() {
            Thread.currentThread().setName("PushFrameHandle");
            ULog.d(TAG, "run: =pushir = PushFrameHandle =pushbuffer===开始取 isPush=" + isPush);
            while (isPush) {
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //                ULog.d(TAG, "run: pushManager ===fuck PushFrameHandle = 1111111 ==== " + (System.currentTimeMillis() - pushFrameHandleTime));

                if (isCombine) {
                    pushBuffUseIndexTemp = (pushBuffUseIndex + 1) % pushBuff.length;
                    if (!pushBuff[pushBuffUseIndexTemp].isReadyToFill && pushBuff[pushBuffUseIndexTemp].buff.length == pushFrame.length) {
                        System.arraycopy(pushBuff[pushBuffUseIndexTemp].buff, 0, pushFrame, 0, pushFrame.length);
                        pushBuffUseIndex = pushBuffUseIndexTemp;
                        pushBuff[pushBuffUseIndex].isReadyToFill = true;
                        //                        ULog.d(TAG, "run: ==pushbuffer===取数据");
                    } else {
                        continue;
                    }
                } else {
                    irBuffUseIndexTemp = (irBuffUseIndex + 1) % irBuff.length;
                    if (!irBuff[irBuffUseIndexTemp].isReadyToFill && irBuff[irBuffUseIndexTemp].buff.length == pushFrame.length) {
                        System.arraycopy(irBuff[irBuffUseIndexTemp].buff, 0, pushFrame, 0, pushFrame.length);

                        //                        if (getRobot().getType().toUpperCase().contains(RobotType.CICADA.toUpperCase())) {
                        //                            ULog.d(TAG, "run:  ===fuck alivcpush = 222222222 isIrRecordFile " + isIrRecordFile + "  index " + ((recordBuffIndex + 1) % recordBuff.length) + " isReadyToFill " + recordBuff[recordBuffIndexTemp].isReadyToFill + "   length  " + irBuff[irBuffUseIndexTemp].buff.length + "  "  + recordBuff[recordBuffIndexTemp].buff.length );
                        //                            if (isIrRecordFile) {
                        //                                recordBuffIndexTemp = (recordBuffIndex + 1) % recordBuff.length;
                        //                                if (recordBuff[recordBuffIndexTemp].isReadyToFill) {
                        //                                    System.arraycopy(irBuff[irBuffUseIndexTemp].buff, 0, recordBuff[recordBuffIndexTemp].buff, 0, recordBuff[recordBuffIndexTemp].buff.length);
                        //                                    recordBuffIndex = recordBuffIndexTemp;
                        //                                    recordBuff[recordBuffIndex].isReadyToFill = false;
                        //                                }
                        //                            }
                        //                        }
                        irBuffUseIndex = irBuffUseIndexTemp;
                        irBuff[irBuffUseIndex].isReadyToFill = true;
                    } else {
                        continue;
                    }
                }
                //                ULog.d("================PushFrameHandle>>irPusher.isPushing = " + irPusher.isPushing);
                if (irPusher.isPushing) {
                    irPusher.pushRgbData(pushFrame, width, height);
                }
//                                ULog.d(TAG, "run:  ===fuck PushFrameHandle = 22222222 ==== " + (System.currentTimeMillis() - pushFrameHandleTime) + "  ====   size " + pushFrame.length);
//                pushFrameHandleTime = System.currentTimeMillis();
            }
            ULog.d(TAG, "run: =pushir = PushFrameHandle == end =" + isPush);
        }
    }

    /**
     * 删除文件夹以及目录下的文件
     *
     * @param filePath 被删除目录的文件路径
     *
     * @return 目录删除成功返回true，否则返回false
     */
    public static boolean deleteDirectory(String filePath) {
        boolean flag = false;
        //如果filePath不以文件分隔符结尾，自动添加文件分隔符
        if (!filePath.endsWith(File.separator)) {
            filePath = filePath + File.separator;
        }
        File dirFile = new File(filePath);
        if (!dirFile.exists() || !dirFile.isDirectory()) {
            return false;
        }
        flag = true;
        File[] files = dirFile.listFiles();
        //遍历删除文件夹下的所有文件(包括子目录)
        for (File file : files) {
            if (file.isFile()) {
                //删除子文件
                flag = deleteFile(file.getAbsolutePath());
                if (!flag) {
                    break;
                }
            } else {
                //删除子目录
                flag = deleteDirectory(file.getAbsolutePath());
                if (!flag) {
                    break;
                }
            }
        }
        if (!flag) {
            return false;
        }
        //删除当前空目录
        return dirFile.delete();
    }


    public String readableFileSize(long size) {
        if (size <= 0) {
            return "0";
        }
        final String[] units = new String[]{"B", "KB", "MB", "GB", "TB"};
        int digitGroups = (int) (Math.log10(size) / Math.log10(1024));
        return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];
    }

    //    long recordTime;

    //    class RecordFrameHandle implements Runnable {
    //        @Override
    //        public void run() {
    //            Thread.currentThread().setName("RecordFrameHandle");
    //            while (isIrRecordFile) {
    //                try {
    //                    Thread.sleep(1);
    //                } catch (InterruptedException e) {
    //                    e.printStackTrace();
    //                }
    //                ULog.v(TAG, "run:  ===fuck RecordFrameHandle = 1111111 ==== " + (System.currentTimeMillis() - recordTime));
    //                recordTime = System.currentTimeMillis();
    ////                ULog.d(TAG, "run:  ===== fuck == " + width + " h =" + height);
    ////                    Arrays.fill(outputNV12, (byte)0);
    //
    //                recordBuffUseIndexTemp = (recordBuffUseIndex + 1) % recordBuff.length;
    //                if (recordBuff[recordBuffUseIndexTemp].isReadyToFill) {
    //                    continue;
    //                }
    //
    //                VideoUtils.RGBByteArray2YUV(recordBuff[recordBuffUseIndexTemp].buff, width, height, 4, VideoUtils.RGBA2NV12TYPE, outputNV12);
    //                recordBuffUseIndex = recordBuffUseIndexTemp;
    //                recordBuff[recordBuffUseIndex].isReadyToFill = true;
    //
    //                //把摄像头的数据传给编码器
    //                long time = System.currentTimeMillis();
    //                int ret = avcCodec.offerEncoder(outputNV12, h264);
    //                ULog.v(TAG, "run:  ======fuck ==RecordFrameHandle offerEncoder 111 ====  " + (System.currentTimeMillis() - time));
    //
    //                if (ret > 0) {
    //                    try {
    //                        byte[] length_bytes = intToBytes(ret);
    //                        fileOutput.write(length_bytes);
    //                        fileOutput.write(h264, 0, ret);
    //                    } catch (IOException e) {
    //                        ULog.d("ws", "exception: " + e.toString());
    //                    }
    //                }
    //            }
    //            synchronized (avcLock) {
    //                avcLock.notify();
    //            }
    //        }
    //
    //    }

    public void reset(int type) {
        if (type == 1 && System.currentTimeMillis() - MainApp.mUpdateMotorTime < 1000) {
            ULog.d(TAG, "reset stm gpio_stm_reset_75 电机心跳正常，不执行复位");
            return;
        }
        stmExecute.executeTaskNonQueue(new StmTask().stopMove("reset stm 70"));
        if (System.currentTimeMillis() - MainApp.mUpdateMotorTime < 1000) {
            ULog.d(TAG, "reset stm gpio_stm_reset_75 电机心跳正常，不执行复位，通过指令重启");
            stmExecute.executeTask(new StmTask().stmReset(1000));
        } else {
            mHandler.postDelayed(() -> {
                SerialManagerUtil.resetGpio(UConstants.GPIO_STM_RESET, 2000);
            }, 200);
        }
        resetStmHeartCheck();
        lastCheckSerialPortTime = System.currentTimeMillis();
    }

    @Override
    public void onPushError() {
        ULog.d("alivc ====  onPushURLAuthenticationOverdue 鉴权错误 重新初始化");
        reInitIr();
    }

    @Override
    public void onAdjustBitRate() {
        irExceptionNum = 0;
        rgbExceptionNum = 0;
        pushAdjustBitRateNum++;
    }

    public void reInitIr() {
        pushCtrlIr(false);
        if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_ARR)) {
            mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_ARR, 1000);
        }
    }


    /********************************方法******************************/


    /**
     * 获取对应报警类型是否已发送报警
     *
     * @param alarmType
     *
     * @return
     */
    public boolean getIsAlarmReported(AlarmTypeEnum alarmType) {
        return mIsAlarmReported.get(alarmType) != null ? mIsAlarmReported.get(alarmType) : false;
    }

    /**
     * 设置报警是否已上报
     *
     * @param alarmType
     * @param isReported
     */
    public void setIsAlarmReported(AlarmTypeEnum alarmType, boolean isReported) {
        ULog.d(TAG, "setIsAlarmReported == alarmType " + alarmType.name() + " isReported " + isReported);
        mIsAlarmReported.put(alarmType, isReported);
    }

    //是否需要上报传感器掉线报警
    private boolean isNeedAlarmSensorDrop(AlarmTypeEnum alarmType) {
        return (addAlarmCount(alarmType) >= mAlarmManager.getAlarmTriggerCount(alarmType) && !getIsAlarmReported(alarmType));
    }

    /**
     * 获取对应报警类型的触发次数
     *
     * @param alarmType
     *
     * @return
     */
    private int getAlarmCount(AlarmTypeEnum alarmType) {
        return mAlarmCount.get(alarmType) != null ? mAlarmCount.get(alarmType) : 0;
    }

    /**
     * 设置报警的记录的触发次数
     *
     * @param alarmType
     */
    private void setAlarmCount(AlarmTypeEnum alarmType, int count) {
        mAlarmCount.put(alarmType, count);
    }

    /**
     * 增加报警次数
     *
     * @param alarmType
     */
    private int addAlarmCount(AlarmTypeEnum alarmType) {
        int count = getAlarmCount(alarmType);
        mAlarmCount.put(alarmType, ++count);
        return count;
    }

    /**
     * 报警恢复，重置报警次数
     *
     * @param alarmType
     */
    private void alarmResume(AlarmTypeEnum alarmType) {
        mAlarmCount.put(alarmType, 0);
        mIsAlarmReported.put(alarmType, false);
    }

    /**
     * 清楚所有异常统计，重置报警触发次数和报警是否上报记录
     */
    private void clearAllAlarmStatistics() {
        mAlarmCount.clear();
        mIsAlarmReported.clear();
    }


    /**
     * 修改 productionClientId
     */
    private void setProductionClientId(Object value) {
        ULog.d(TAG, "onMessageReceived:  ====== 设置量产测试的手机端MQTT的id ");
        //id检查
        if (value == null) {
            return;
        }
        String productionClientId = (String) value;
        if (UString.isEmpty(productionClientId)) {
            return;
        }

        //修改
        RobotFragment.productionClientId = productionClientId;
    }

    private void getSegmentFromCache() {
        try {
            //属于开机断网的状况，采用本地初始化
            String segmentStr = UPreferences.getString(mActivity, UConstants.PREFERENCES_SEGMENT_KEY);
            ULog.d(TAG, "从缓存读取segmentStr === " + segmentStr);
            if (!UString.isEmpty(segmentStr)) {
                mSegment = JSONObject.parseObject(segmentStr, Segment.class);
                if (mSegment != null) {
                    ULog.d(TAG, "从缓存读取mSegment === " + mSegment.getId());
                    parseSegment();
                } else {
                    mSequenceInitializer.unregisterInitKey("FIND_CHARGERS");
                    mSequenceInitializer.unregisterInitKey("CONFIG_CHARGER_SENSOR_FINISH");
                    RxBus.getInstance().post(new SegmentEvent(SegmentEvent.ACTION_NO_BIND_SEGMENT));
                }
            }
        } catch (Exception e) {
            ULog.d(TAG, "从缓存读取Segment出错", e);
        }
    }

    private void registerDelayLeaveChargerObserver() {
        if (mRobotChargeEventObserver == null) {
            mRobotChargeEventObserver = robotChargeEvent -> {
                if (robotChargeEvent.getAction() == RobotEventConstants.EVENT_CLOSE_CHARGER_SUCCESS) {

                    ULog.d(TAG, "充电已关闭，准备延迟离开充电桩");
                    int delayTimeLeaveCharger = getRobot().getEndChargeInterval() != null ? getRobot().getEndChargeInterval() : 10;
                    try {
                        Thread.sleep(delayTimeLeaveCharger * 1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (!mIsWaitToLeaveCharger) {
                        return;
                    }
                    mIsWaitToLeaveCharger = false;
                    onMessageReceived(mCommandBeforeLeaveCharger);
                }
            };

            RxBus.getInstance().toObservable(RobotChargeEvent.class)
                    .subscribeOn(Schedulers.computation())
                    .observeOn(Schedulers.computation())
                    .subscribe(mRobotChargeEventObserver);
        }
    }

    /**
     * 监听Connect事件，以便在连接上网络、断线重连后第一时间通知服务器在线状态
     */
    private void registerConnectTestObserver() {
        RxBus.getInstance().toObservable(RobotHeartEvent.class)
                .subscribeOn(Schedulers.trampoline())
                .observeOn(Schedulers.io())
                .subscribe(robotHeartEvent -> {
                    ULog.d(TAG, "connect test event");
                    if (robotHeartEvent.getAction() == RobotEventConstants.EVENT_SEND_CONNECT_TEST) {
                        connectTest();
                    }
                });
    }


    /**
     * @param targertDistance 标定的距离
     * @param robotDistance   机器人所在的距离
     *
     * @return
     */
    private static BigDecimal caculDefaultRotate(BigDecimal targertDistance, BigDecimal
            robotDistance) {
        BigDecimal calDistance = new BigDecimal("0"); //标定的距离和机器人的距离  默认0m
        BigDecimal rotorCircle = new BigDecimal("0");//轮子转动的圈数  默认为0m
        calDistance = targertDistance.subtract(robotDistance).abs();//计算间隔距离
        rotorCircle = calDistance.divide(new BigDecimal(UConstants.DISTANCE_TWO_ROUND), BigDecimal.ROUND_HALF_UP)
                .multiply(new BigDecimal(2));
        if (rotorCircle.multiply(new BigDecimal(40000)).subtract(new BigDecimal(Math.pow(16, 7) - 1)).longValue() > 0) {//超出了目前的电机圈数
            rotorCircle = new BigDecimal(Math.pow(16, 7) - 1).divide(new BigDecimal(40000), BigDecimal.ROUND_HALF_UP); //置最远距离
        }
        return rotorCircle;
    }


    class LowPowerGotoChargerEnable implements Runnable {
        @Override
        public void run() {
            Thread.currentThread().setName("LowPowerGotoChargerEnable");
            MqttCommand lowPowerCommand = new MqttCommand();
            lowPowerCommand.setSource(getRobot().getId());
            lowPowerCommand.setType(MqttCommand.ROBOT_LOW_POWER_GO_TO_CHARGE_TYPE);
            for (String accountId : accounts) {
                lowPowerCommand.setTarget(accountId);
                mMqttManager.publishMessage(lowPowerCommand);
                //延时0.1秒 要不然发消息有问题
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    ULog.d(TAG, "sendMobileLocation === e :" + e.getMessage());
                }
            }
        }
    }

    class OpenChargeSuccessEnable implements Runnable {
        @Override
        public void run() {
            Thread.currentThread().setName("OpenChargeSuccessEnable");
            MqttCommand closeChargingCommand = new MqttCommand();
            closeChargingCommand.setSource(getRobot().getId());
            closeChargingCommand.setType(MqttCommand.ROBOT_FORCE_OFF_CHARGING_TYPE);
            closeChargingCommand.setValue(false);
            for (String accountId : accounts) {
                closeChargingCommand.setTarget(accountId);
                mMqttManager.publishMessage(closeChargingCommand);
                //延时0.1秒 要不然发消息有问题
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    ULog.d(TAG, "sendMobileLocation === e :" + e.getMessage());
                }
            }
        }

    }


    // TODO: 2021/7/16 和林需要区分甲乙皮带
    public String getBeltPosition() {
        String beltPos = "皮带机";
        if (inspectionUseAngleType == 0) {
            if (robotDirection == MOVE_END) {
                beltPos = "皮带乙";
            } else {
                beltPos = "皮带甲";
            }
        } else if (inspectionUseAngleType == 1) {
            beltPos = "皮带甲";
        } else if (inspectionUseAngleType == 2) {
            beltPos = "皮带乙";
        }

        return beltPos;
    }


    /**
     * 更新传感器数据值
     *
     * @param sensorType      传感器类型
     * @param value           传感器值
     * @param installPosition 传感器安装位置
     * @param sensorState     传感器状态
     * @param type            传感器type，参照supported_sensors_config.json中定义的类型的type
     */
    private void updateSensorData(@NonNull String sensorType, @NonNull String value, @androidx.annotation.NonNull String installPosition,
                                  String sensorState, String type) {
        updateSensorData(sensorType, value, installPosition, sensorState, type, null);
    }


    private void updateSensorData(@NonNull String sensorType, @NonNull String value,
                                  @androidx.annotation.NonNull String installPosition, String sensorState,
                                  String type, Map<String, String> valuesMap) {
        List<SensorData> sensorDatas = mSensorsData.get(sensorType);
        if (sensorDatas == null) {
            sensorDatas = new ArrayList<>();
            SensorData sensorData = new SensorData(sensorType, value, installPosition, sensorState, type, valuesMap);
            sensorDatas.add(sensorData);
            mSensorsData.put(sensorType, sensorDatas);
        } else {
            SensorData targetSd = null;
            for (SensorData sd : sensorDatas) {
                if (installPosition.equals(sd.getInstallPosition())) {
                    targetSd = sd;
                }
            }

            if (targetSd == null) {
                SensorData sensorData = new SensorData(sensorType, value, installPosition, sensorState, type, valuesMap);
                sensorDatas.add(sensorData);
            } else {
                targetSd.setSensorState(sensorState);
                targetSd.setValue(value);
                targetSd.setValuesMap(valuesMap);
            }
        }

        //todo 设置到机器人字段
        updateRobotSensorData();
    }


    public void executeStmTask(StmTask task) {
        stmExecute.executeTask(task);
    }


    private void updateRobotSensorData() {
        String dataStr = JSON.toJSONString(mSensorsData);
        getRobot().setSensorDatas(dataStr);
    }

    private void printRobotSensorData() {
        String dataStr = JSON.toJSONString(mSensorsData);
        ULog.i(TAG, "传感器数据：" + dataStr);
    }

    /**
     * 清除电机过流策略的标志位
     */
    public void clearMotorOverCurrentFlags() {
        mIsBackwardToAvoidStilling = false;
        //        mIsBackwardToAvoidMotorSlip = false;
    }

    public RobotFragment.onDistanceInfoListener mOnDistanceInfoListener;
    public RobotFragment.onInspectionTurnAroundListener mOnInspectionTurnAroundListener;
    public OnTurnaroundListener onTurnaroundListener;
    public OnDistanceListener4SwitchTrack onDistanceListener4SwitchTrack;

    public void setonDistanceInfoListener(RobotFragment.onDistanceInfoListener listener) {
        this.mOnDistanceInfoListener = listener;
    }
    public void setOnDistanceListener4SwitchTrack(OnDistanceListener4SwitchTrack listener) {
        this.onDistanceListener4SwitchTrack = listener;
    }

    public void setonInspectionTurnAroundListener(RobotFragment.onInspectionTurnAroundListener listener) {
        this.mOnInspectionTurnAroundListener = listener;
    }

    public interface OnDistanceListener4SwitchTrack {
        void onDistanceBack(float distance);
    }

    public interface onInspectionTurnAroundListener {
        void onInspectionTurnAround();
    }

    public interface OnTurnaroundListener {
        void onTurnaround(int robotDirection);
    }

    public interface onDistanceInfoListener {
        void onDistanceInfo(float distance);
    }

    public void setOnTurnaroundListener(OnTurnaroundListener onTurnaroundListener) {
        this.onTurnaroundListener = onTurnaroundListener;
    }

    public AlarmManager getAlarmManager() {
        return mAlarmManager;
    }


    public long getLastMotorHeartTime() {
        return mLastMotorHeartTimeInMills;
    }


    /**
     * @param priorityFlag 优先选择正常模式的参数还是夜间模式的参数
     * @param args
     */
    public void settingWebCameraArgument(boolean priorityFlag, WebCameraArgumentBean args) {
        if (priorityFlag) {
            if (args.getFocuspos() != null && args.getZoompos() != null) {
                WebCamManager.getInstance()
                        .setZoomAndFocus(args.getZoompos(), args.getFocuspos())
                        .subscribe(ObserverFactory.createDefaultObserver());
            } else if (args.getNightVisionFocuspos() != null && args.getNightVisionZoompos() != null) {
                WebCamManager.getInstance()
                        .setZoomAndFocus(args.getNightVisionZoompos(), args.getNightVisionFocuspos())
                        .subscribe(ObserverFactory.createDefaultObserver());
            }
        } else {
            if (args.getNightVisionFocuspos() != null && args.getNightVisionZoompos() != null) {
                WebCamManager.getInstance()
                        .setZoomAndFocus(args.getNightVisionZoompos(), args.getNightVisionFocuspos())
                        .subscribe(ObserverFactory.createDefaultObserver());
            } else if (args.getFocuspos() != null && args.getZoompos() != null) {
                WebCamManager.getInstance()
                        .setZoomAndFocus(args.getZoompos(), args.getFocuspos())
                        .subscribe(ObserverFactory.createDefaultObserver());
            }
        }
    }

    /**
     * 是否时后退防堵转状态
     *
     * @return
     */
    public boolean getIsBackwardToAboidStilling() {
        return mIsBackwardToAvoidStilling;
    }

    ////////////////////// 推流相关功能处理 start ////////////////////////////////////////////////////////////////////////

    boolean isUpdateIrPusherIng = false;

    /**
     * 更新推流功能统一入口（当推流相关数据没有变化时，不更新推流）
     */
    private synchronized void updatePusher(int tag) {
        ULog.d(TAG, "updatePusher " + tag);
        updateIrPusher(3);
        updateRgbPusher(1);
    }

    /**
     * 更新红外视频推流
     */
    private synchronized void updateIrPusher(int tag) {
        long time = System.currentTimeMillis();
        ULog.df("=============pusher==>>>updateIrPusher={}; irPusher.isPushing={};  irPusher.isENABLE={}; libIniting = {} ; irPusher.isPushInit = {}; tag = {}",
                isUpdateIrPusherIng,
                irPusher.isPushing,
                irPusher.isENABLE(),
                libIniting,
                irPusher.isPushInit,
                tag);
        final Robot robot = getRobot();
        pushCtrlIr(getRobot().getPushEnable());
        if (!robot.getPushEnable()) return;
        if (isUpdateIrPusherIng || libIniting || !irPusher.isPushInit) {
            return;
        }
        isUpdateIrPusherIng = true;
        boolean isChange = irPusher.isPushUrlChange(robot.getCameraDomain());
        ULog.d(TAG, "updatePusher updateIrPusher ir == " + isChange + " doMain " + robot.getCameraDomain());
        if (isChange) {
            //            ULog.d("=============pusher==>>>updateIrPusher>>启动推流");
            //            if (!mHandler.hasMessages(Msg.WHAT_INIT_IR_SDK)) {
            //                mHandler.sendEmptyMessageDelayed(Msg.WHAT_INIT_IR_SDK, 100);
            //            }
            getUpdatePusherThreadPool().execute(new Runnable() {
                @Override
                public void run() {
                    Thread.currentThread().setName("resetIrUrl");
                    getIrPusher().resetIrUrl(getPushIrUrl());
                    ULog.d(TAG, "updatePuher_ir " + tag + " time " + (System.currentTimeMillis() - time));
                }
            });
        }
        isUpdateIrPusherIng = false;
    }

    private ExecutorService updatePusherExecutorService;

    public synchronized ExecutorService getUpdatePusherThreadPool() {
        if (updatePusherExecutorService == null) {
            updatePusherExecutorService = Executors.newFixedThreadPool(3);
        }
        return updatePusherExecutorService;
    }

    /**
     * 更新网络视频推流
     */
    private synchronized void updateRgbPusher(int tag) {
        long time = System.currentTimeMillis();
        ULog.df("=============pusher==>>>updateRgbPusher  webPusher.isPushing={};  webPusher.isEnable={} tag = {}",
                webPusher.isPushing,
                webPusher.isEnable(),
                tag);
        if (mSensorManager.cacheInfo().WEBCAM_INFO == null) {
            ULog.w(TAG, "=============pusher==>>>updateRgbPusher no webcam configed");
            return;
        }

        Robot robot = getRobot();
        pushCtrlRgb(getRobot().getPushEnable());
        if (BoolUtil.val(robot.getPushEnable())) {
            pushDeviceControl(true,"8", false);
        } else {
            return;
        }
        boolean isResolutionChange = webPusher.isNetworkCameraResolutionChange(robot.getNetworkCameraResolution());
        boolean isUrlChange = webPusher.isPushUrlChange(robot.getCameraDomain());

        //分辨率变化或者推流地址变化
        if (isResolutionChange) {
            if (getRobot().getNetworkCameraResolution() != null) {
                if (getRobot().getNetworkCameraResolution() == 1) {
                    WebCamManager.getInstance().setStreamType(1);
                } else if (getRobot().getNetworkCameraResolution() == 2) {
                    WebCamManager.getInstance().setStreamType(0);
                }
            }
        }
        getUpdatePusherThreadPool().execute(new Runnable() {
            @Override
            public void run() {
                Thread.currentThread().setName("updateRgbPusher");
                if (!WebCameraPusher.isPushing) {
                    getWebCameraPusher().setStreamUrl(WebCamManager.getInstance().getRtspStreamUrl());
                    SmartRtspToRtmp.pullUrlMain = WebCamManager.getInstance().getRtspMainStreamUrl();
                    getWebCameraPusher().setWebCameraPushParams(robot.getPushStreamType(), getPushWebUrl());
                    getWebCameraPusher().startPush();
                } else if (isResolutionChange || isUrlChange) {
                    ULog.d(TAG, "updatePusher updateRgbPusher isResolutionChange " + isResolutionChange + " isUrlChange " + isUrlChange);
                    getWebCameraPusher().setStreamUrl(WebCamManager.getInstance().getRtspStreamUrl());
                    SmartRtspToRtmp.pullUrlMain = WebCamManager.getInstance().getRtspMainStreamUrl();
                    getWebCameraPusher().resetPushUrl(getPushWebUrl());
                }
                ULog.d(TAG, "updatePuher_rgb " + tag + " time " + (System.currentTimeMillis() - time));
            }
        });
    }

    private void pushCtrlAll(boolean enable) {
        pushCtrlRgb(enable);
        pushCtrlIr(enable);
    }
    private void pushCtrlRgb(boolean enable) {
        boolean config = getRobotConfigParams().getClosePushOfSaveNetwork();
//        if (config) ULog.d(TAG, "pushCtrlRgb ClosePushOfSaveNetwork true");
        WebCameraPusher.setEnable(!config && enable);
    }
    private void pushCtrlIr(boolean enable) {
        boolean config = getRobotConfigParams().getClosePushOfSaveNetwork();
//        if (config) ULog.d(TAG, "pushCtrlIr ClosePushOfSaveNetwork true");
        PushManager.setENABLE(!config && enable);
    }

    /**
     * 获取红外摄像头的推流地址（自动判断网络类型）
     * @return
     */
    private String getPushIrUrl() {
        Robot robot = getRobot();
        String pushIrUrl = "";
        if (robot != null) {
            //判断是否有红外摄像头（也有可能是没有设置时）
            if (IntUtil.isNullOr0(robot.getIrCameraNum())) {
                ULog.e(TAG, "==============获取推流地址:没有红外摄像头（也有可能是没有设置时）");
                return pushIrUrl;
            }
            switch (robot.getPushStreamType()) {
                case PushManager.PUSH_WAN:
                    pushIrUrl = UrlManager.getPushUrl(robot);
                    break;
                case PushManager.PUSH_LAN:
                    //                    pushIrUrl = StrUtil.getValNoBlank(mLocalPushIrUrl, robot.getLocalPushIrUrl());
                    if (!TextUtils.isEmpty(robot.getPushLocalIp())) {
                        if(robot.getPushLocalIp().contains("://")){
                            String format = "{}/hls/{}";
                            pushIrUrl = StrUtil.format(format,
                                    robot.getPushLocalIp(),
                                    robot.getId());
                            mLocalPushIrUrl = pushIrUrl;
                        }else{
                            String format = "rtmp://{}:{}/hls/{}";
                            pushIrUrl = StrUtil.format(format,
                                    robot.getPushLocalIp(),
                                    UrlManager.PUSH_STREAM_PORT_LOCAL,
                                    robot.getId());
                            mLocalPushIrUrl = pushIrUrl;
                        }

                    } else {
                        ULog.d(TAG, "initLib: 局域网 推流地址为空 getPushLocalIp = null");
                    }
                    break;
            }
        }
        ULog.d("========推流地址IrUrl>>" + pushIrUrl);
        return pushIrUrl;
    }

    /**
     * 获取网络摄像头的推流地址（自动判断网络类型）
     * @return
     */
    private String getPushWebUrl() {
        ULog.d("==============获取推流地址 getPushWebUrl>>>");
        Robot robot = getRobot();
        String pushWebCameraUrl = "";
        if (robot != null) {
            //判断是否有RGB摄像头（也有可能是没有设置或在传感器中没有设置时）
            if (mSensorManager.cacheInfo().WEBCAM_INFO == null) {
                ULog.d(TAG, "==============获取推流地址:没有Web摄像头（也有可能是没有设置或在传感器中没有设置时）");
                return pushWebCameraUrl;
            }
            switch (robot.getPushStreamType()) {
                case PushManager.PUSH_WAN:
                    pushWebCameraUrl = UrlManager.getPushUrlToWeb(robot);
                    break;
                case PushManager.PUSH_LAN:
                    if (!TextUtils.isEmpty(robot.getPushLocalIp())) {
                        if(robot.getPushLocalIp().contains("://")){
                            String format = "{}/hls/{}{}";
                            pushWebCameraUrl = StrUtil.format(format,
                                    robot.getPushLocalIp(),
                                    robot.getId(),
                                    UrlManager.PUSH_SUFFIX_WEB);
                        }else{
                            String  format = "rtmp://{}:{}/hls/{}{}";
                            pushWebCameraUrl = StrUtil.format(format,
                                    robot.getPushLocalIp(),
                                    UrlManager.PUSH_STREAM_PORT_LOCAL,
                                    robot.getId(),
                                    UrlManager.PUSH_SUFFIX_WEB);
                        }

                    } else {
                        ULog.d(TAG, "initLib: 局域网 推流地址为空 getPushLocalIp = null");
                    }
                    break;
            }
        }
        ULog.d("========推流地址WebUrl>>" + pushWebCameraUrl);
        return pushWebCameraUrl;
    }

    private WebCameraPusher getWebCameraPusher() {
        if (webPusher != null) return webPusher;
        webPusher = WebCameraPusher.getInstance(mActivity);
        webPusher.setOnWebCameraPushListener(new WebCameraPusher.OnWebCameraPushListener() {
            @Override
            public void onPushFinish() {
                ULog.d("====>OnWebCameraPushListener>>onPushFinish");
            }

            @Override
            public void onPushProgress(int progress, long progressTime) {
                ULog.df("====>OnWebCameraPushListener>>onPushProgress>>progress={}, progressTime={}", progress, progressTime);
            }

            @Override
            public void onPushCancel() {
                ULog.d("====>OnWebCameraPushListener>>onPushCancel");
            }

            @Override
            public void onPushError(String message) {
                ULog.d("====>OnWebCameraPushListener>>onPushError==>>" + message);
            }
        });
        return webPusher;
    }

    private PushManager getIrPusher() {
        if (irPusher != null) return irPusher;
        irPusher = PushManager.getInstance(mActivity);
        //推流初始化回调
        irPusher.setOnPushInitCallbackListener(new PushManager.onPushInitCallbackListener() {
            MqttCommand command = new MqttCommand();

            @Override
            public void onInitSuccess() {
                ULog.i("onPushInitCallbackListener>>onInitSuccess: =============>onInitSuccess");
            }

            @Override
            public void onStartPush() {
                ULog.d("onPushInitCallbackListener>>onStartPush: =============pushType>" + pushType);
                mHandler.postDelayed(() -> {
                    switch (pushType) {
                        case 1:
                            sendMqttResult(command, MqttCommand.ROBOT_PUSH_STREAM_FRONT_INDEX_SUCCEED_ACTION, null);
                            break;
                        case 2:
                            sendMqttResult(command, MqttCommand.ROBOT_PUSH_STREAM_BEHIND_INDEX_SUCCEED_ACTION, null);
                            break;
                        case 0:
                            sendMqttResult(command, MqttCommand.ROBOT_PUSH_STREAM_NORMAL_INDEX_SUCCEED_ACTION, null);
                            break;
                        default:
                            break;
                    }
                }, 1000);

            }

            @Override
            public void onInitFail(String msg) {
                ULog.i("onPushInitCallbackListener>>onInitFail: =============>onInitFail>" + msg);
                switch (pushType) {
                    case 1:
                        sendMqttResult(command, MqttCommand.ROBOT_PUSH_STREAM_FRONT_INDEX_FAILED_ACTION, null);
                        break;
                    case 2:
                        sendMqttResult(command, MqttCommand.ROBOT_PUSH_STREAM_BEHIND_INDEX_FAILED_ACTION, null);
                        break;
                    case 0:
                        sendMqttResult(command, MqttCommand.ROBOT_PUSH_STREAM_NORMAL_INDEX_FAILED_ACTION, null);
                        break;
                    default:
                        break;
                }
                ULog.i("onPushInitCallbackListener>>onMessageReceived", "onInitFail: =============");
            }
        });
        return irPusher;
    }
    ////////////////////// 推流相关功能处理 end ////////////////////////////////////////////////////////////////////////


    /**
     * 根据RobotEvent的Action获取电机报警的原因
     *
     * @param action
     *
     * @return
     */
    private String getMotorAlarmReasonStr(int action) {
        switch (action) {
            case RobotEvent.EVENT_MOTOR_OVER_CURRENT:

                return "OVER_CURRENT";

            case RobotEvent.EVENT_MOTOR_SPEED_LOW_THAN_ONE_THIRD:

                return "SPEED_LOW";

            case RobotEvent.EVENT_STM_REPORT_MOVEMENT_HINDRANCE:

                return "STM_REPORT";

            case RobotEvent.EVENT_MOTOR_MANAGE_BOARD_ALARM:

                return "MOTOR_MANAGER_REPORT";

            default:
                return "UNKNOWN";
        }
    }


    /**
     * 检测网络摄像头是否在线 处理因网络摄像头没有通电的情况下给摄像头先通电再进行
     *
     * @param error
     * @param runnable
     */
    private boolean checkWebCameraIsOnLine(String error, Runnable runnable) {
        ULog.e(TAG, "checkWebCameraIsOnLine: " + error);
        if (StrUtil.isBlank(error) || isWebCameraElectrify) {
            return false;
        }
        if (StrUtil.contains(error,
                "Failed to connect to /192.168.1.160",
                StrUtil.format("Failed to connect to /{}", WebCameraPusher.webCameraIp))) {
            boolean isOpen = true;
            if (mSegment != null && mSegment.getDisconnected() != null) {
                isOpen = (mSegment.getDisconnected() == 1 && robotDirection != MOVE_FRONT) || (mSegment.getDisconnected() == 2 && robotDirection == MOVE_FRONT);
            }
            ULog.d(TAG, "网络摄像头 === onFindFailure ===111=== isOpen:" + isOpen);
            if (isOpen) {
                //向网络摄像头供电
                pushDeviceControl(true,"9", false);
                if (runnable != null) {
                    runnable.run();
                }
                return true;
            }
        }
        return false;
    }


    private void motorBackwardResumeMove() {
        //如果是防电机过流堵转
        float speed = MainApp.getRobotMaxSpeed() * 0.8f;
        ULog.d(TAG, "运动阻碍/电机过流后退完成，开始恢复原移动方向, 当前里程：" + mDistance + "，当前方向：" + robotDirection + " maxSpeed " + MainApp.getRobotMaxSpeed() + " setSpeed " + speed);

//        if (mIsNeedToSpeedUp) {
            setSpeed(speed, "motorBackwardResumeMove");
//            mIsNeedToSpeedUp = false;
//        }
        setRobotDirection(robotDirection == MOVE_FRONT ? MOVE_END : MOVE_FRONT,"24");
        //可能和回充逻辑有关，改为6秒后再修改状态
//        mBotInfoMgr.setRobotActionCode(robotDirection == MOVE_FRONT ? RobotActionCode.MOVE_FRONT :
//                RobotActionCode.MOVE_END);
        mHandler.sendEmptyMessageDelayed(Msg.WHAT_QUIT_MOVE_HINDER_STATUS, 6500);
        clearMotorOverCurrentFlags();

        Observable.just(1)
                .subscribeOn(Schedulers.io())
                .subscribe(t -> {
                    Thread.sleep(TIME_SLEEP_BEFORE_MOVE_BACKWARD);
                    //电机过流保护
                    stmExecute.executeTask(new StmTask().move(robotDirection, defaultRotate, DEFAULT_DISTANCE));
                });
    }

    public boolean isCheckingRfidLost() {
        return mIsCheckingRfidLost;
    }

    public void setIsCheckingRfidLost(boolean isChecking) {
        mIsCheckingRfidLost = isChecking;
    }

    /**
     * 使用mqtt消息的方式启动回充流程
     */
    private void gotoChargerWithSelfMqttCommand() {
        ULog.d(TAG, "firstBoot 开机回充 gotoChargerWithSelfMqttCommand");
        MqttCommand chargingCommand = new MqttCommand();
        chargingCommand.setSource(getRobot().getId());
        chargingCommand.setTarget(getRobot().getId());
        chargingCommand.setType(ROBOT_INSPECTION_INDEX_TYPE);
        chargingCommand.setAction(MqttCommand.ROBOT_INSPECTION_CHARGING_ACTION);
        onMessageReceived(chargingCommand);
    }

    int rfidErrorNum = 0;
    long lastResetRfidGpioTime;
    public void resetRfidGpio(int type) {
        if (type == 1) { //rfid模块
            ULog.d(TAG, "resetRfidGpio rfid模块重启 inCharger " + inCharger() + " mCurrent " + mCurrent + " robotIsStop " + robotIsStop());
            if (inCharger()) { lastResetRfidGpioTime = System.currentTimeMillis() - 240_000; return;}
            if (mCurrent >= 0) { lastResetRfidGpioTime = System.currentTimeMillis() - 240_000; return;}
            if (robotIsStop()) { lastResetRfidGpioTime = System.currentTimeMillis() - 240_000; return;}
            lastResetRfidGpioTime = System.currentTimeMillis();
        } else if (type == 2) { //4g/5g模块
            ULog.d(TAG, "resetRfidGpio 4g/5h模块重启");
        }
        Observable.just(1)
                .observeOn(Schedulers.io())
                .subscribe(t -> {
                    ULog.d("GPIO", "拉低 gpio:" + UConstants.GPIO_RFID);
                    //rfid断电 4g/5g断电
                    SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_RFID, 1);
                    try {
                        Thread.sleep(3500);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //rfid上电
                    SerialManagerUtil.getSerialManager(MainApp.getInstance()).gpio_write(UConstants.GPIO_RFID, 0);
                    ULog.d("GPIO", "拉高 gpio:" + UConstants.GPIO_RFID + " rfid上电，然后重启下位机，重新初始化rfid模块");
                    RxBus.getInstance().post(new Stm32Event(Stm32Event.STM_REBOOT, Stm32RebootReason.RFID_ERROR_REBOOT));
                    reset(0);
                });
    }

    public void setCmdAfterRoomOp(MqttCommand command) {
        mCmdAfterRoomOp = command;
    }


    //删除文件夹及里面的所有文件
    public static void deleteDir(File files) {
        //获取File对象中的所有文件，并将其放在数组中
        File[] listFiles = files.listFiles();
        //循环遍历数组
        for (File file : listFiles) {
            //如果是目录文件，则递归调用删除方法
            if (file.isDirectory()) {
                deleteDir(file);
            } else if (file.isFile()) {
                //如果是文件，则删除
                file.delete();
            }
        }
        //删除文件夹内所有文件后，再删除文件夹
        files.delete();
    }

    public void removeHindranceRetryMsg() {
        mHandler.removeMessages(Msg.WHAT_RETRY_MOVE_AFTER_STALLING);
    }

    /**
     * 当下位机复位时检查必要的配置
     */
    private void checkWhenStmReset() {
        if (mIsHaveNewCleanDevice) {
            boolean inCleanDevice = isInCleanDeviceArea(mDistance);

            if (mBotInfoMgr.getRobotMainType() != RobotMainType.LADYBUG) {
                ObstacleController.getInstance().setObstacleOn(!inCleanDevice,"24");
                if (!mBotInfoMgr.getRobotConfigParams().getEnableControlSteerInCleanDevice()) {
                    if (!inCleanDevice && isWebCameraElectrify) {
                        SteerController.getInstance().setPowerEnable(true);
                    }
                }
            }
        }

        //无缓存或非电梯机器，读新的方向，否则读缓存方向
        int cacheRfidDir = UPreferences.getInt(mActivity, UConstants.ACTION_ROBOT_RFID_DIRECTION_ACTION, -1);
        if (cacheRfidDir != -1) {
            rfidDirection = cacheRfidDir;

            ULog.d(TAG, "checkWhenStmReset update rfidDirection=" + rfidDirection);
            if (rfidDirection == 0) {
                stmExecute.executeTask(new StmTask().setRFIDDirection(-1,"下位机复位1"));
            } else if (rfidDirection == 1) {
                stmExecute.executeTask(new StmTask().setRFIDDirection(1,"下位机复位2"));
            }
            StmTask.updateDirection(rfidDirection,"q5");
        }
    }

    /**
     * 重设电机心跳
     */
    @Override
    public void resetStmHeart() {
        if (taskComputeMile != null) {
            taskComputeMile.cancel(true);
        }
        if (taskReadMotorInfo != null) {
            taskReadMotorInfo.cancel(true);
        }

        taskComputeMile = getScheduledExecutor().scheduleAtFixedRate(() -> {
            Thread.currentThread().setName("setAvailableMileage");
            if (getRobot().getBatteryPerHour() != 0) {
                //可用里程(m) = 剩余电量(mA) / 每小时耗电量(mA) * 3600 * 速度(m/s)
                float available = (float) (getRobot().getRemainBattery() / (getRobot().getBatteryPerHour() * 1.0) * 3600 * 1.0 * 0.13f); //UConstants.DEFAULT_SPEED);
                getRobot().setAvailableMileage((float) (((int) (available * 100)) / 100.0));
            }
        }, 1000, 1000, TimeUnit.MILLISECONDS);
        //handler发心跳 初始化摄像头时会中断一会
        // 使用子线程发送解决
        taskReadMotorInfo = getScheduledExecutor().scheduleAtFixedRate(() -> {
            Thread.currentThread().setName("readMotorInfo");
            stmExecute.executeTaskNonQueue(new StmTask().readMotorInfo());
        }, 50, 200, TimeUnit.MILLISECONDS);
    }

    public void resetIrTicks() {
        ULog.d(TAG, "yolov7 resetIrTicks");
        if (taskIrTicks != null) {
            taskIrTicks.cancel(true);
        }
        taskIrTicks = getScheduledExecutor().scheduleAtFixedRate(() -> {
            Thread.currentThread().setName("IrTicks");
            inspectManager.onIrTicks();
        }, 50, 37, TimeUnit.MILLISECONDS); //按27帧-37ms处理
    }

    /**
     * 解析下位机标准心跳
     * @param data 接收到的心跳帧
     */
    public void parseStandardHeartData(byte[] data) {
        try {
            long startTime = System.currentTimeMillis();
            StmStandardHeartData heartData = new StmStandardHeartData();
            //开关类传感器使能表占用字节数
            int switchEnableTableByteSize = data[2] & 0xff;
            //数组类传感器使能表占用字节数
            int valueEnableTableByteSize = data[3] & 0xff;

            //开关类传感器使能表
            int[] switchEnableTable = UByte.convertByteBitToIntArrLF(data, 4, switchEnableTableByteSize);
            int[] switchStatus = UByte.convertByteBitToIntArrLF(data, 4 + switchEnableTableByteSize, switchEnableTableByteSize);
            ULog.v(TAG,"标准心跳 == 开关类 使能表占用" + switchEnableTableByteSize + "字节，使能表：" + Arrays.toString(switchEnableTable) + ", 状态； " + Arrays.toString(
                    switchStatus));
            for (int tableIndex = switchEnableTable.length - 1; tableIndex >= 0; tableIndex--) {
                int sensorIndex = switchEnableTable.length - 1 - tableIndex;
                heartData.setSwitchStatus(sensorIndex, switchEnableTable[tableIndex], switchStatus[tableIndex]);
            }

            //数值类传感器数据
            int valueDataStartIndex = 4 + switchEnableTableByteSize * 2;
            int[] valueEnableTable = UByte.convertByteBitToIntArrLF(data, valueDataStartIndex,
                    valueEnableTableByteSize);
            int[] valueStatus = UByte.convertByteBitToIntArrLF(data, valueDataStartIndex + valueEnableTableByteSize, valueEnableTableByteSize);

//              01 1A 01 02 2F 0E 1F 44 1F 44 5B 30 07 26 00 24 0F 5A 00 20 DC A8 00 00 B6 2D
//                    01 开关类传感器使能表占用字节数
//                    02 数值类传感器使能表占用字节数
//                    2F 开关类传感器使能表
//                    0E 开关类传感器状态表
//                    1F 44 数值类传感器使能表 低位在前 高位在后 实际应为 0x441F 0100010000011111 7个使能
//                    1F 44 数值类传感器状态表 低位在前 高位在后 实际应为 0x441F
//                    5B 30 | 07 26 | 00 24 | 0F 5A | 00 20 | DC A8 | 00 00
//                       1      2       3       4       5       6       7
//                    B6 2D 校验位

            boolean isOldHeart = false;
            int valueEnableNum = 0;
            for (int i = 0; i < valueEnableTable.length; i++) {
                if (valueEnableTable[i] == UConstants.VALUE_SWITCH_STATUS_ON) valueEnableNum++;
            }
            int newHeartLength = valueDataStartIndex + valueEnableTableByteSize * 2 + valueEnableNum * 4 + 2;
            if (data.length < newHeartLength) {
                isOldHeart = true;
            }
            ULog.v(TAG,
                    "标准心跳 == 数值类 使能表占用" + valueEnableTableByteSize + "字节，使能表：" + Arrays.toString(valueEnableTable) + ", 状态； " + Arrays.toString(valueStatus) + " isOldHeart " + isOldHeart + " dataLength " + data.length + " " + newHeartLength);
            int t = 0;
            for (int tableIndex = valueEnableTable.length - 1; tableIndex >= 0; tableIndex--) {
                int sensorIndex = valueEnableTable.length - 1 - tableIndex;
                if (valueEnableTable[tableIndex] == UConstants.VALUE_SWITCH_STATUS_ON) {
                    int curStatus = valueStatus[tableIndex];
                    int highByteIndex = valueDataStartIndex + valueEnableTableByteSize * 2 + t * 4;
                    if (isOldHeart) highByteIndex = valueDataStartIndex + valueEnableTableByteSize * 2 + t * 2;
                    int lowByteIndex = highByteIndex + 1;
                    int intBits = (data[highByteIndex] & 255) << 24 | (data[highByteIndex + 1] & 255) << 16 | (data[highByteIndex + 2] & 255) << 8 | (data[highByteIndex + 3] & 255);
//                    ULog.d(TAG, "标准心跳 == " + sensorIndex + " value " + Integer.toHexString(intBits));
                    float curValue = FormatUtils.keepDecimals(Float.intBitsToFloat(intBits), 2);
                    t++;
                    if (isOldHeart) {
                        int curValueInt = UByte.twoByteToUnsignedInt(data[highByteIndex], data[lowByteIndex]);
                        if (sensorIndex == 2 || sensorIndex == 3 || sensorIndex == 8) { //温度数据解析为有符号数据
                            curValueInt = UByte.twoByteToInt(data[highByteIndex], data[lowByteIndex]);
                        }
                        heartData.setValueStatusOld(sensorIndex, SensorConstants.STATUS_ENABLED, curStatus, curValueInt);
                    } else {
                        heartData.setValueStatus(sensorIndex, SensorConstants.STATUS_ENABLED, curStatus, curValue);
                    }
                } else {
                    heartData.setValueStatus(sensorIndex, SensorConstants.STATUS_DISABLED, 0, 0);
                }
            }

            if (heartData.getInnerTempStatus() == 1 && heartData.getInnerTempValue() > lowTempThreshold) {
                long dustInterval = System.currentTimeMillis() - lastStartDustSuccessTime;
                ULog.d(TAG, "lowTempThreshold 内部温度过高，应开始除尘降温 间隔：" + dustInterval);
                if (MODE == MODE_UN_KNOW && dustInterval > 30 * 60_000 && inCharger()) {
                    if (!mHandler.hasMessages(Msg.WHAT_START_DUSTING)) {
                        mHandler.sendEmptyMessage(Msg.WHAT_START_DUSTING);
                    }
                }
            }

            mStmHeartDataQueue.addLast(heartData);
            synchronized (mStmHeartLock) {
                mStmHeartLock.notify();
            }
            long endTime = System.currentTimeMillis();
            ULog.v(TAG, "标准心跳解析 耗时" + (endTime - startTime) + "ms");
        } catch (Exception e) {
            ULog.e(TAG, "标准心跳解析出错", e);
        }
    }


    /**
     * 下位机心跳处理线程，从队列中依次取数据
     */
    private final class StmHeartDataProcessThread extends Thread {
        public StmHeartDataProcessThread() {
            super("STM_HEART_P");
        }

        @Override
        public void run() {
            while (true) {
                try {
                    if (mStmHeartDataQueue.isEmpty()) {
                        synchronized (mStmHeartLock) {
                            mStmHeartLock.wait();
                        }
                    } else {
                        StmStandardHeartData heartData = mStmHeartDataQueue.poll();
                        if (heartData != null) {
                            long startTime = System.currentTimeMillis();
                            ULog.i(TAG, "标准心跳：" + heartData);
                            processStandardHeartData(heartData);
                            long endTime = System.currentTimeMillis();
                            if (endTime - startTime >= 20) {
                                ULog.w(TAG, "标准心跳处理时间较长 " + (endTime - startTime) + "ms");
                            }
                        }
                    }
                } catch (Exception e) {
                    ULog.e(TAG, "标准心跳处理出错", e);
                }
            }
        }
    }
    static StmStandardHeartData currentHeartData;
    /**
     * 实际处理下位机心跳
     * @param heartData
     */
    private void processStandardHeartData(@androidx.annotation.NonNull StmStandardHeartData heartData) {
        if(!sensorEnableStatus){
            processSensorNotEnableValue(heartData);
        }
        if (heartData.getOutsideTempValue() != 0 && heartData.getOutsideHumidityValue() != 0) {
            StorageCenter.getRobotStorage().putFloat(UConstants.PREFERENCES_OUTSIDE_TEMP_KEY, heartData.getOutsideTempValue());
            StorageCenter.getRobotStorage().putFloat(UConstants.PREFERENCES_OUTSIDE_HUMIDITY_KEY, heartData.getOutsideHumidityValue());
        }
        currentHeartData = heartData;
        //ULog.d(TAG, " 处理后标准心跳：" + heartData);
        //开关类传感器
        processObstacleStatusChange(heartData.getObstacleEnable(), heartData.getObstacleStatus());
        processMircoSwitchStatusChange(heartData.getFrontMicroSwitchEnable(), heartData.getFrontMicroSwitchStatus(),
                heartData.getBackMicroSwitchEnable(), heartData.getBackMicroSwitchStatus());
        processEmergencyButtonStatusChange(heartData.getEmergencyButtonSwitchEnable(), heartData.getEmergencyButtonSwitchStatus());
        processSmokeStatusChange(heartData.getSmokeEnable(), heartData.getSmokeStatus());
        processInPlaceSwitchStatusChange(heartData.getInPlaceEnable(), heartData.getInPlaceStatus());

        //数值类传感器
        processObstacleDistanceChange(heartData.getFrontObstacleEnable(), heartData.getFrontObstacleStatus(),
                heartData.getFrontObstacleDistance(),
                heartData.getBackObstacleEnable(), heartData.getBackObstacleStatus(), heartData.getBackObstacleDistance());
        processStm32TemperatureChange(heartData.getStmTempEnable(), heartData.getStmTempStatus(), heartData.getStmTempValue());
        processInnerTemperatureChange(heartData.getInnerTempEnable(), heartData.getInnerTempStatus(), heartData.getInnerTempValue());
        processLeakDataChange(heartData.getLeak1Enable(), heartData.getLeak1Status(), heartData.getLeak1Value(),
                heartData.getLeak2Enable(), heartData.getLeak2Status(), heartData.getLeak2Value(),
                heartData.getLeak3Enable(), heartData.getLeak3Status(), heartData.getLeak3Value(),
                heartData.getLeak4Enable(), heartData.getLeak4Status(), heartData.getLeak4Value());
        processOutsideTemperatureChange(heartData.getOutsideTempEnable(), heartData.getOutsideTempStatus(),
                heartData.getOutsideTempValue());
        processOutsideHumidityChange(heartData.getOutsideHumidityEnable(),
                heartData.getOutsideHumidityStatus(),
                heartData.getOutsideHumidityValue());
        processCoDataChange(heartData.getCoEnable(), heartData.getCoStatus(), heartData.getCoValue());
        processCo2DataChange(heartData.getCo2Enable(), heartData.getCo2Status(), heartData.getCo2Value());
        processCh4DataChange(heartData.getCh4Enable(), heartData.getCh4Status(), heartData.getCh4Value());
        processH2sDataChange(heartData.getH2sEnable(), heartData.getH2sStatus(), heartData.getH2sValue());
        processNh3DataChange(heartData.getNh3Enable(), heartData.getNh3Status(), heartData.getNh3Value());
        processO2DataChange(heartData.getO2Enable(), heartData.getO2Status(), heartData.getO2Value());
        processSf6DataChange(heartData.getSf6Enable(), heartData.getSf6Status(), heartData.getSf6Value());
        processPm25DataChange(heartData.getPm25Enable(), heartData.getPm25Status(), heartData.getPm25Value());
        processPm10DataChange(heartData.getPm10Enable(), heartData.getPm10Status(), heartData.getPm10Value());
        processH2DataChange(heartData.getH2Enable(), heartData.getH2Status(), heartData.getH2Value());
        processGasBoardDataChange(heartData.getCoEnable(), heartData.getCoStatus(), heartData.getCoValue(), heartData.getCh4Value(),
                heartData.getO2Value());
        processSixInOneDataChange(heartData.getPm25Enable(), heartData.getPm25Status(), heartData.getPm25Value(), heartData.getPm10Value(),
                heartData.getOutsideTempValue(), heartData.getOutsideHumidityValue());
        processOutsideTempHumidityDataChange(heartData.getOutsideTempEnable(), heartData.getOutsideTempStatus(),
                heartData.getOutsideTempValue(), heartData.getOutsideHumidityValue());
        processInternalHumidityDataChange(heartData.getInnerHumidityEnable(), heartData.getInnerTempStatus(), heartData.getInnerHumidityValue());

        printOtherInfoLog();
        updateRobotDataDetailFromStmHeart(heartData);
        robotStatusUpload(1);
    }

    /**
     * {@link #sensorEnableStatus} 为false 的时候将对应的传感器的值设置成0
     * @param heartData
     */
    private void processSensorNotEnableValue(StmStandardHeartData heartData) {
        heartData.setOutsideTempValue(0);//外部温度
        heartData.setOutsideHumidityValue(0);//外部湿度
        heartData.setCoValue(0);//一氧化碳
        heartData.setCo2Value(0);//二氧化碳
        heartData.setCh4Value(0);//甲烷
        heartData.setH2sValue(0);//硫化氢
        heartData.setNh3Value(0);//氨气
        heartData.setO2Value(0);//氧气
        heartData.setSf6Value(0);//六氟化硫
        heartData.setPm25Value(0);//PM2.5
        heartData.setPm10Value(0);//PM10
        heartData.setH2Value(0);//氢气
        heartData.setSmokeStatus(1);//烟雾 1无烟 0有烟
    }


    /**
     * 从心跳数据中，更新机器人数据状态
     * @param heartData
     */
    private void updateRobotDataDetailFromStmHeart(StmStandardHeartData heartData) {
        getRobot().setSmokeSensorStatus(heartData.getSmokeStatus());
        getRobot().setStm32Temperature(heartData.getStmTempValue());
        getRobot().setRobotTemperature(heartData.getInnerTempValue());
        getRobot().setObstacle(heartData.getObstacleStatus() == UConstants.VALUE_SWITCH_STATUS_ON);
        getRobot().setSmoke(heartData.getSmokeStatus());
        getRobot().setCo(heartData.getCoValue());
        getRobot().setO2((double) heartData.getO2Value());
        getRobot().setCo2((double) heartData.getCo2Value());
        getRobot().setCoMa((double) heartData.getCoValue());
        getRobot().setCh4(heartData.getCh4Value() * 1.0d);
        getRobot().setDust(heartData.getPm25Value());
        getRobot().setHumidity((int) heartData.getOutsideHumidityValue());
        getRobot().setH2s(heartData.getH2sValue());
        getRobot().setH2sStatus(heartData.getH2sStatus());
        getRobot().setNh3(heartData.getNh3Value());
        getRobot().setNh3Status(heartData.getNh3Status());

        updateRobotSensorData();
    }

    /**
     * 打印状态信息
     */
    private void printOtherInfoLog() {
        StringBuilder logBuilder = new StringBuilder();

        logBuilder.append("状态信息 === ")
                .append(mRobotType)
                .append(", 分贝=")
                .append(getRobot().getDecibel())
                .append(", 报警代码=")
                .append(Integer.toHexString(getRobot().getAlarm()))
                .append(", 电机温度=")
                .append(getRobot().getMotorTemperature())
                .append(", 剩余里程=")
                .append(getRobot().getAvailableMileage())
                .append("米, 电机电压=")
                .append(getRobot().getMotorVoltage())
                .append(", 电机电流=")
                .append(mMotorCurrent)
                .append(", ")
                .append(mMotorCurrent2)
                .append(", 电机速度=")
                .append(getRobot().getSpeed())
                .append(", 绝对位置=")
                .append(mDistance)
                .append(", recoveryNum=")
                .append(recoveryNum)
                .append(", mode_===")
                .append(MODE)
                .append(", 电量=")
                .append(getRobot().getPowerPercent())
                .append(", 充电=")
                .append(getRobot().getCharging())
                .append(", inCharger=")
                .append(inCharger())
                .append(", isBeltConveyorStart=")
                .append(isBeltConveyorStart)
                .append(", 单次采样温度值=")
                .append(fT)
                .append(", robotDirection=")
                .append(robotDirection)
                .append(", 待机状态=")
                .append(isSleep)
                .append(", 软件急停状态=")
                .append(isSoftEmergencyStop)
                .append(", 巡检前端尾端 = Head ")
                .append(inspectManager.isInspectHead)
                .append(" Tail ")
                .append(inspectManager.isInspectTail)
                .append(", 前端红外=")
                .append(currentIRValue)
                .append(", 占比=")
                .append(currentIRValueScale)
                .append(", chargerControlStatus=")
                .append(chargerControlStatus)
                .append(", chargerControlStatusCool=")
                .append(chargerControlStatusCool)
                .append(", currentChargerControlStatus=")
                .append(currentChargerControlStatus)
                .append(", currentChargerControlStatusCool=")
                .append(currentChargerControlStatusCool);

        if (mBotInfoMgr.getRobotMainType() == RobotMainType.LADYBUG) {
            logBuilder.append(", 后端红外=");
            logBuilder.append(currentIRValueBack);
            logBuilder.append(", 占比=");
            logBuilder.append(currentIRValueScaleBack);
        }

        ULog.i(TAG, logBuilder.toString());
    }


    /**
     * ****************************************************************************************************************
     * ************************************** 开关类传感器数据处理  start    ********************************************
     * ****************************************************************************************************************
     */

    int obstacleTriggerNum = 0;
    /**
     * 避障状态处理
     * @param enable 避障使能
     * @param obstacleStatus 避障状态
     */
    private void processObstacleStatusChange(int enable, int obstacleStatus) {
        if (enable != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }

        if (obstacleStatus == 1) {
            obstacleTriggerNum ++;
            //每三次触发 通知下用户 防止太频繁
            if(obstacleTriggerNum == 1 || obstacleTriggerNum % 3 == 0){
                ULog.d(TAG,"processObstacleStatusChange 障碍物触发 通知用户...");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_OBSTACLE_TRIGGER);
                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_obstacle_trigger));
            }

            //遇到障碍物
            if (getRobotConfigParams() == null || !getRobotConfigParams().isHaveElevator() || !MainApp.elevatorDeviceNear) {
                if (addAlarmCount(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION)) {
                        List<String> params = new ArrayList<>();
                        params.add(getSensorAlarmFirstParam());

                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION,
                                params));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION, true);
                }
            }
        } else {
            //恢复时matt通知下用户
            if(obstacleTriggerNum != 0){
                ULog.d(TAG,"processObstacleStatusChange 障碍物恢复 通知用户...");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_OBSTACLE_RECOVER);
                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_obstacle_recover));
            }
            obstacleTriggerNum = 0;

            setAlarmCount(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION, 0);
            if (getIsAlarmReported(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION)) {
                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION_RESUME));
                setIsAlarmReported(AlarmTypeEnum.ROBOT_OBSTACLE_EXCEPTION, false);
            }
        }

    }


    //int microsWitchTriggerNum = 0;

    /**
     * 微动开关状态处理
     * @param frontEnable 前微动使能
     * @param frontStatus 前微动状态
     * @param backEnable 后微动使能
     * @param backStatus 后微动状态
     */
    private void processMircoSwitchStatusChange(int frontEnable, int frontStatus, int backEnable, int backStatus) {
        if (frontEnable != UConstants.VALUE_SWITCH_STATUS_ON || backEnable != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }
        frontMicrosWitch = frontStatus;
        behindMicrosWitch = backStatus;

       /* if(frontMicrosWitch == 0 || behindMicrosWitch == 0){
            microsWitchTriggerNum ++;
            ULog.d(TAG,"processMircoSwitchStatusChange 微动开关触发 num:"+microsWitchTriggerNum);
            //每三次触发 通知下用户 防止太频繁
            if(microsWitchTriggerNum == 1 || microsWitchTriggerNum % 3 == 0){
                ULog.d(TAG,"processMircoSwitchStatusChange 微动开关触发 通知用户...");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_MICRO_SWITCH_TRIGGER);
                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_micro_switch_trigger));
            }
        }else{
            //恢复时通知下用户
            if(microsWitchTriggerNum != 0){
                ULog.d(TAG,"processMircoSwitchStatusChange 微动开关触发恢复");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_MICRO_SWITCH_RECOVER);
                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_micro_switch_recover));
            }
            microsWitchTriggerNum = 0;
        }*/


        /*if (getRobotConfigParams() != null && getRobotConfigParams().isHaveElevator()) {
            if (frontMicrosWitch == 0 || behindMicrosWitch == 0) {

            }
        }*/

    }

    /**
     * 急停开关状态处理
     * @param enable 是否使能
     * @param status 状态
     */
    private void processEmergencyButtonStatusChange(int enable, int status) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        MainApp.emergencyStopButton = status; //0:按下 1:弹出
        getRobot().setEmergencyStopButton(MainApp.emergencyStopButton);

        if (emergencyStopButtonLast == MainApp.emergencyStopButton) {
            recoveryNum = 0;
        }
        //上次是弹出状态 本次是按下
        if (emergencyStopButtonLast == 1 && MainApp.emergencyStopButton == 0) {
            recoveryNum++;
            ULog.d(TAG,"processEmergencyButtonStatusChange 上次是弹出状态 本次是按下 recoveryNum:"+recoveryNum +" recoveryThreshold:"+recoveryThreshold);
        }
        if (recoveryNum >= recoveryThreshold) {
            //执行刷机
            MainApp.recoverySystem();
        }
        MqttCommand commandStop = null;
        if (emergencyStopButtonLast == -1) {
            if (MainApp.emergencyStopButton == 0) {
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_EMERGENCY_BUTTON_PRESSED);
                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.stop_button_pressed));
                MainApp.emergencyStopButton = -1;

                //                            stopRecord();
                if (MODE == MODE_BATCH_PRODUCTION_TEST && !batch_production_test_emergency_stop && getRobot() != null) {
                    commandStop = new MqttCommand();
                    commandStop.setSource(getRobot().getId());
                    commandStop.setTarget(productionClientId);
                    commandStop.setType(MqttCommand.ROBOT_BATCH_PRODUCTION_INDEX_TYPE);
                    commandStop.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_5_ACTION);
                }
            }
        } else {
            if (emergencyStopButtonLast != MainApp.emergencyStopButton) {
                if (MainApp.emergencyStopButton == 0) {
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_EMERGENCY_BUTTON_PRESSED);
                    mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.stop_button_pressed));
                    if (MODE == MODE_BATCH_PRODUCTION_TEST && !batch_production_test_emergency_stop && getRobot() != null) {
                        commandStop = new MqttCommand();
                        commandStop.setSource(getRobot().getId());
                        commandStop.setTarget(productionClientId);
                        commandStop.setType(MqttCommand.ROBOT_BATCH_PRODUCTION_INDEX_TYPE);
                        commandStop.setAction(MqttCommand.ROBOT_BATCH_PRODUCTION_STEP_5_ACTION);
                    }
                } else if (MainApp.emergencyStopButton == 1) {
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_EMERGENCY_BUTTON_RELEASED);
                    mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.stop_button_normal));
                }
            }
        }
        emergencyStopButtonLast = MainApp.emergencyStopButton;
        if (commandStop != null && MqttManager.getInstance().isConnected()) {
            MqttManager.getInstance().publishMessage(commandStop);
        }

    }

    /**
     * 烟雾传感器
     * @param enable 使能
     * @param status 状态
     */
    private void processSmokeStatusChange(int enable, int status) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //烟雾传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().SMOKE_INFO != null) {
            SmokeSensorInfo smokeSensorInfo = mSensorManager.cacheInfo().SMOKE_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_SMOKE, String.valueOf(status),
                    smokeSensorInfo.getInstallPosition(), String.valueOf(UConstants.VALUE_SWITCH_STATUS_ON), smokeSensorInfo.getType());

            //有烟雾报警器
            if (true) {
                //烟雾传感器正常
                setAlarmCount(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION, 0);
                if (getIsAlarmReported(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION)) {
                    //烟雾报警器掉线异常恢复
                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION_RESUME));
                    setIsAlarmReported(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION, false);
                }

                if ("1".equals(smokeSensorInfo.getType())) {
                    //新款烟雾传感器
                    if (status == 1) {
                        setAlarmCount(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD, 0);
                    } else {
                        addAlarmCount(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD);
                    }
                }

                if (!isInCleanDeviceArea(mDistance) && getAlarmCount(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD) >= mAlarmManager.getAlarmTriggerCount(
                        AlarmTypeEnum.SMOKE_ALARM_THRESHOLD)) {
                    ULog.w(TAG,
                            "烟雾值传感器 值异常次数：" + getAlarmCount(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD) + "," +
                                    "mCurrentNode " + (inspectManager.mCurrentTaskNode == null ? "null" : inspectManager.mCurrentTaskNode.getName()));
                    //烟雾值超出阈值

                    //烟雾值超过阈值异常，超过容错次数，且未报警
//                    if (inspectManager.mCurrentTaskNode != null && !TextUtils.isEmpty(inspectManager.mCurrentTaskNode.getName())) {
                        AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD);
                        List<String> params = new ArrayList<>();
                        params.add(getSensorAlarmFirstParam());
                        alertEvent.setParams(params);
                        alertEvent.setSensorException(true);
                        alertEvent.setSensorHis(getSensorHisData());
                        long smokeTime = System.currentTimeMillis();
                        alertEvent.setPicIr(getAlarmIrImgFileName(smokeTime));
                        alertEvent.setPicRgb(getAlarmRgbImgFileName(smokeTime));
                        alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                        //通知报警
                        RxBus.getInstance().post(alertEvent);
                        setIsAlarmReported(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD, true);
//                    }

//                    mIsSmokeExceptionStop = true;
//                    //自动建图模式机器人烟雾值异常不停止移动
//                    if (MODE != MODE_AUTO_BUILD_MAP && MODE != MODE_UN_KNOW) {
//                        //停止移动，修改MODE
//                        //记录异常前的模式
//                        mRobotModeBeforeSmokeException = getRobot().getMode();
//                        stmExecute.executeTaskNonQueue(new StmTask().stopMove("烟雾值超出阈值 80"));   //停止移动
//                        setTempMode(MODE_UN_KNOW);                          //设置临时MODE，便于下次修改
//                    }

                } else if (getIsAlarmReported(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD)) {
                    AlarmEvent alarmEvent = new AlarmEvent(AlarmTypeEnum.SMOKE_ALARM_EXCEPTION_RESUME);
                    //通知报警
                    RxBus.getInstance().post(alarmEvent);
                    setIsAlarmReported(AlarmTypeEnum.SMOKE_ALARM_THRESHOLD, false);
                    mIsSmokeExceptionStop = false;
                    //自动建图模式机器人烟雾值异常恢复不更新mode
                    ULog.d(TAG, "烟雾异常恢复，恢复原作业模式 originalMode" + originalMode);
//                    if (MODE != MODE_AUTO_BUILD_MAP) {
//                        //恢复原MODE
//                        ULog.i(TAG, "originalMode:" + originalMode);
//                        recoverMode();
//                    }
                    //异常恢复后继续巡检  //此次不要主动调用，等移动检测去触发继续任务
                    //                                if (mRobotModeBeforeSmokeException == MODE_INSPECTION) {
                    //                                    continueInspection(robotDirection);
                    //                                }
                }

            } else {
                //烟雾传感器掉线
                ULog.e(TAG, "烟雾传感器掉线 : " + getAlarmCount(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION));
                if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION)) {
                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION));
                    setIsAlarmReported(AlarmTypeEnum.ROBOT_SMOKE_SENSOR_DROP_EXCEPTION, true);
                }

            }


        }

    }

    /**
     *
     * @param enable
     * @param status
     */
    private void processInPlaceSwitchStatusChange(int enable, int status) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //do nothing
    }

    /**
     * ****************************************************************************************************************
     * ************************************** 开关类传感器数据处理  end    **********************************************
     * ****************************************************************************************************************
     */

    /**
     * ****************************************************************************************************************
     * ************************************** 数值类传感器数据处理  start    ********************************************
     * ****************************************************************************************************************
     */


    //int obstacleDistanceTriggerNum = 0;

    /**
     * 避障距离
     * @param frontEnable
     * @param frontStatus
     * @param frontDistance
     * @param backEnable
     * @param backStatus
     * @param backDistance
     */
    private void processObstacleDistanceChange(int frontEnable,int frontStatus, int frontDistance,
                                               int backEnable, int backStatus,int backDistance) {
       /* if (frontEnable != UConstants.VALUE_SWITCH_STATUS_ON || backEnable != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }

        if(frontStatus == 0 || backStatus == 0){
            obstacleDistanceTriggerNum ++;
            //遇到障碍物
            ULog.d(TAG,"processObstacleDistanceChange 激光避障 遇到障碍物 num:"+obstacleDistanceTriggerNum);
            if(obstacleDistanceTriggerNum == 1 || obstacleDistanceTriggerNum % 3 == 0){
                ULog.d(TAG,"processObstacleDistanceChange 激光避障触发 通知用户...");
                //mqtt广播 通知下用户
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_OBSTACLE_DISTANCE_TRIGGER);
                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_obstacle_distance_trigger));
            }
        }else{
            //恢复时通知下用户
            if(obstacleDistanceTriggerNum != 0){
                ULog.d(TAG,"processObstacleDistanceChange 激光避障触发恢复");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_OBSTACLE_DISTANCE_RECOVER);
                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.robot_obstacle_distance_recover));
            }
            obstacleDistanceTriggerNum = 0;
        }*/

    }

    /**
     * STM32温度数据处理
     * @param enable 使能使能
     * @param status 状态
     * @param stm32Temp 温度值
     */
    private void processStm32TemperatureChange(int enable, int status,float stm32Temp) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }
        mBotInfoMgr.getStm32ChipTemperature().postValue((int) stm32Temp);
    }

    /**
     * 机器人内部温度数据处理
     * @param enable 使能
     * @param status 状态
     * @param innerTemp 内部温度值
     */
    private void processInnerTemperatureChange(int enable,int status, float innerTemp) {
        if (enable != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }

        if (innerTemp > -90) {
            robotTemperature = innerTemp;
        }

        int robotTemperatureExceptionState = getRobot().getException() >> 1 & 0x1;
        temperatureSensorState = status;

        //机器人内部温度处理
        if (temperatureSensorState == 1) {

            //温控逻辑
//            {
//                if (status == 1) {
//                    int tempChargerControlStatus = chargerControlStatus;
//                    int tempChargerControlStatusCool = chargerControlStatusCool;
//                    if (inCharger() && tempChargerControlStatus == 0) {
//                        if (innerTemp <= getRobotConfigParams().getByTempControlOpenHeater()) {
//                            tempChargerControlStatus = Msg.WHAT_OPEN_HEATER;
//                        } else if (innerTemp >= getRobotConfigParams().getByTempControlCloseHeater()) {
//                            tempChargerControlStatus = Msg.WHAT_CLOSE_HEATER;
//                        }
//                    }
//                    if (inCharger() && environmentalTemperature != UConstants.UNKONW && environmentalTemperature < 0) {
//                        //环境温度低于0度，开始加热
//                        if (tempChargerControlStatus == 0) {
//                            tempChargerControlStatus = Msg.WHAT_OPEN_HEATER;
//                        }
////                        //满电状态下 如果是加热状态，关闭加热      先不加
////                        if (isFullBattery && currentChargerControlStatus == Msg.WHAT_OPEN_HEATER) {
////                            tempChargerControlStatus = Msg.WHAT_CLOSE_HEATER;
////                        }
//                    }
//                    if (inCharger() && tempChargerControlStatusCool == 0) {
//                        if (innerTemp >= getRobotConfigParams().getByTempControlOpenCooler()) {
//                            tempChargerControlStatusCool = Msg.WHAT_OPEN_COOLER;
//                        } else if (innerTemp <= getRobotConfigParams().getByTempControlCloserCooler()) {
//                            tempChargerControlStatusCool = Msg.WHAT_CLOSE_COOLER;
//                        }
//                    }
////            ULog.d(TAG, "温控处理 tempChargerControlStatus " + tempChargerControlStatus + " currentChargerControlStatus " + currentChargerControlStatus + " outsideTemp " + outsideTemp +  " OpenHeater " + getRobotConfigParams().getByTempControlOpenHeater() + " closeHeater " + getRobotConfigParams().getByTempControlCloseHeater() + " OpenCooler " + getRobotConfigParams().getByTempControlOpenCooler() + " CloserCooler " + getRobotConfigParams().getByTempControlCloserCooler());
//                    if (tempChargerControlStatus != 0 && currentChargerControlStatus != tempChargerControlStatus) {
//                        if (tempChargerControlStatus == Msg.WHAT_CLOSE_HEATER && currentChargerControlStatus != Msg.WHAT_OPEN_HEATER) {
////                            return;
//                        } else {
//                            chargerControlStatus = tempChargerControlStatus;
//                            mHandler.sendEmptyMessage(chargerControlStatus);
//                        }
//                    }
//                    if (tempChargerControlStatusCool != 0 && currentChargerControlStatusCool != tempChargerControlStatusCool) {
//                        if (tempChargerControlStatus == Msg.WHAT_CLOSE_COOLER && currentChargerControlStatus != Msg.WHAT_OPEN_COOLER) {
////                            return;
//                        } else {
//                            chargerControlStatusCool = tempChargerControlStatusCool;
//                            mHandler.sendEmptyMessage(chargerControlStatusCool);
//                        }
//                    }
//                }
//            }



            //机器人内部温度传感器状态正常
            setAlarmCount(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION, 0);
            if (getIsAlarmReported(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION)) {
                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION_RESUME));
                setIsAlarmReported(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION, false);
            }

            float robotTempMax = getRobot().getThresholdRobotTemperatureMax() != null ?
                    getRobot().getThresholdRobotTemperatureMax() : 30;
            float robotTempMin = getRobot().getThresholdRobotTemperatureMin() != null ?
                    getRobot().getThresholdRobotTemperatureMin() : 5;

            if (robotTemperature >= robotTempMin && robotTemperature <= robotTempMax) {
                //内部温度正常
                setAlarmCount(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_HIGH_EXCEPTION, 0);
                setAlarmCount(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_LOW_EXCEPTION, 0);

                if (getIsAlarmReported(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_HIGH_EXCEPTION)) {
                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_EXCEPTION_RESUME));
                    setIsAlarmReported(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_HIGH_EXCEPTION, false);
                    stmExecute.executeTask(new StmTask().setTemperatureException(false));
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_INNER_TEMPERATURE_RESUME_TO_NORMAL);
                    mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.temperature_normal));
                }

                if (getIsAlarmReported(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_LOW_EXCEPTION)) {
                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_EXCEPTION_RESUME));
                    setIsAlarmReported(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_LOW_EXCEPTION, false);
                    stmExecute.executeTask(new StmTask().setTemperatureException(false));
                    mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_INNER_TEMPERATURE_RESUME_TO_NORMAL);
                    mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.temperature_normal));
                }

                getRobot().setRobotTemperatureException(false);

                if (robotTemperatureExceptionState == 1) {
                    getRobot().setException(getRobot().getException() - 0b10);
                }

            } else if (robotTemperature > robotTempMax) {
                //内部温度过高
                getRobot().setRobotTemperatureException(true);
                stmExecute.executeTask(new StmTask().setTemperatureException(true));
                if (robotTemperatureExceptionState == 0) {
                    getRobot().setException(getRobot().getException() + 0b10);
                }

                if (addAlarmCount(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_HIGH_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                        AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_HIGH_EXCEPTION)) {
                    List<String> alertParams = new ArrayList<String>();
                    alertParams.add(String.valueOf(robotTempMax));
                    alertParams.add(String.valueOf(FormatUtils.keepDecimals(robotTemperature, 1)));
                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_HIGH_EXCEPTION,
                            alertParams, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                    setIsAlarmReported(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_HIGH_EXCEPTION, true);
                }

                mMqttManager.broadcastShowInfo(mRes.getString(fun.unifun.library.android.R.string.temperature_high) + " " + FormatUtils.keepDecimals(robotTemperature, 1) + "℃");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_INNER_TEMPERATURE_TOO_HIGH, FormatUtils.keepDecimals(robotTemperature, 1));
            } else if (robotTemperature < robotTempMin) {
                //内部温度过低
                getRobot().setRobotTemperatureException(true);
                stmExecute.executeTask(new StmTask().setTemperatureException(true));
                if (robotTemperatureExceptionState == 0) {
                    getRobot().setException(getRobot().getException() + 0b10);
                }

                if (addAlarmCount(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_LOW_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                        AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_LOW_EXCEPTION)) {
                    List<String> alertParams = new ArrayList<String>();
                    alertParams.add(String.valueOf(robotTempMin));
                    alertParams.add(String.valueOf(FormatUtils.keepDecimals(robotTemperature, 1)));
                    RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_LOW_EXCEPTION,
                            alertParams, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                    setIsAlarmReported(AlarmTypeEnum.ROBOT_INNER_TEMPERATURE_LOW_EXCEPTION, true);
                }

                mMqttManager.broadcastShowInfo("机器人温度过低" + " " + FormatUtils.keepDecimals(robotTemperature, 1) + "℃");
                mMqttManager.broadcastShowInfoMsgCode(MqttMsgCode.MSG_ROBOT_INNER_TEMPERATURE_TOO_LOW, FormatUtils.keepDecimals(robotTemperature, 1));
            }


        } else {
            //机器人内部温度传感器掉线
            ULog.e(TAG,
                    "机器人内部温度传感器掉线 : " + getAlarmCount(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION));

            if (isNeedAlarmSensorDrop(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION)) {
                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION));
                setIsAlarmReported(AlarmTypeEnum.INNER_TEMPERATURE_SENSOR_DROP_EXCEPTION, true);
            }
        }


    }

    /**
     * 漏水传感器数据处理
     * @param leak1Enable 漏水1使能
     * @param leak1Status 漏水1状态
     * @param leak1Value 漏水1值
     * @param leak2Enable 漏水2使能
     * @param leak2Status 漏水2状态
     * @param leak2Value 漏水2值
     * @param leak3Enable 漏水3使能
     * @param leak3Status 漏水3状态
     * @param leak3Value 漏水3使能
     * @param leak4Enable 漏水4使能
     * @param leak4Status 漏水4状态
     * @param leak4Value 漏水4值
     */
    private void processLeakDataChange(int leak1Enable, int leak1Status, int leak1Value,
                                       int leak2Enable, int leak2Status, int leak2Value,
                                       int leak3Enable, int leak3Status, int leak3Value,
                                       int leak4Enable, int leak4Status, int leak4Value) {
        if (mSensorManager != null && mSensorManager.isHaveSensorAndEnabled(SensorType.SENSOR_TYPE_LEAK)) {
            List<Sensor> leakSensors = mSensorManager.findConfigedAndEnabledSensors(SensorType.SENSOR_TYPE_LEAK);
            for (int i = 0; i < leakSensors.size(); i++) {
                LeakSensorInfo leakSensorInfo = (LeakSensorInfo) leakSensors.get(i);

                if (!leakSensorInfo.isEnabled()) {
                    continue;
                }


                int leakValue = 0;

                switch (leakSensorInfo.getInstallPosition()) {
                    case LeakSensorConfigConstants.InstallPosition.POSITION_FRONT_LEFT:
                        leakValue = leak1Value;
                        getRobot().setLeftFrontLeak(leakValue);
                        mBotInfoMgr.getLeakageValue0().postValue(leakValue);
                        break;

                    case LeakSensorConfigConstants.InstallPosition.POSITION_FRONT_RIGHT:
                        leakValue = leak2Value;
                        getRobot().setRightFrontLeak(leakValue);
                        mBotInfoMgr.getLeakageValue1().postValue(leakValue);
                        break;

                    case LeakSensorConfigConstants.InstallPosition.POSITION_BEHIND_LEFT:
                        leakValue = leak3Value;
                        getRobot().setLeftBehindLeak(leakValue);
                        mBotInfoMgr.getLeakageValue2().postValue(leakValue);
                        break;

                    case LeakSensorConfigConstants.InstallPosition.POSITION_BEHIND_RIGHT:
                        leakValue = leak4Value;
                        getRobot().setRightBehindLeak(leakValue);
                        mBotInfoMgr.getLeakageValue3().postValue(leakValue);
                        break;

                    default:
                        break;
                }

                updateSensorData(SensorType.SENSOR_TYPE_LEAK, String.valueOf(leakValue),
                        leakSensorInfo.getInstallPosition(), "1", leakSensorInfo.getType());
            }
        }


    }
    private void sendMessageToCharger(int msgWhat) {
        if (mHandler.hasMessages(msgWhat)) {
            mHandler.removeMessages(msgWhat);
        }
        if (msgWhat == Msg.WHAT_START_DUSTING && !needOpenDusting) {
            ULog.d(TAG, "开始除尘 当前不应除尘，结束任务");
            return;
        }
        if (msgWhat == Msg.WHAT_END_DUSTING && needOpenDusting) {
            ULog.d(TAG, "关闭除尘/结束除尘 当前应除尘，结束任务");
            return;
        }
        if (AutoMoveManager.mTargetChargerNodeW == null || AutoMoveManager.mTargetChargerNodeW.getCharger() == null) {
            AutoMoveManager.mTargetChargerNodeW =
                    ChargerNodeManager.getInstance().computeNearestChargerNodeWrapper(mDistance,"6");
        }
        //获取当前节点所在充电桩id
        if (AutoMoveManager.mTargetChargerNodeW != null && AutoMoveManager.mTargetChargerNodeW.getCharger() != null) {
            ULog.d(TAG,
                    "handleMessage: === sendChargerMessage WHAT = " + msgWhat + " nearestCharger：" + autoMoveManager.mTargetChargerNodeW);
            nearestChargerId = autoMoveManager.mTargetChargerNodeW.getCharger().getId();
            checkChargerOnline(nearestChargerId, msgWhat);
        } else {
            ULog.w(TAG, "handleMessage: === sendChargerMessage WHAT = " + msgWhat + " == 节点数据错误 " + AutoMoveManager.mTargetChargerNodeW);
        }

        if (ChargerNodeManager.getInstance().getAllBindChargers() == null
                || ChargerNodeManager.getInstance().getBindActiveChargers().size() > 0) {
            mHandler.sendEmptyMessageDelayed(msgWhat, 3000);
        }
    }
    /**
     * 充电桩控制状态
     */
    private int chargerControlStatus;
    private int chargerControlStatusCool;
    //当前充电桩控制状态
    private int currentChargerControlStatus;
    private int currentChargerControlStatusCool;
    /**
     * 暂不支持
     * 外部温度传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param outsideTemp 外部温度值
     */
    private void processOutsideTemperatureChange(int enable,int status, float outsideTemp) {
    }

    /**
     * 暂不支持
     * 外部湿度传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param humidity 湿度
     */
    private void processOutsideHumidityChange(int enable,int status, float humidity) {
        //not supported yet

    }

    /**
     * 一氧化碳传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processCoDataChange(int enable, int status,int value) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //一氧化碳传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().CO_INFO != null) {
            CoSensorInfo coSensorInfo = mSensorManager.cacheInfo().CO_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_CO,
                    String.valueOf(value),
                    coSensorInfo.getInstallPosition(),
                    String.valueOf(status),
                    coSensorInfo.getType());

            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == 0) {
                    //co报警器掉线异常
                    ULog.e(TAG, "一氧化碳传感器掉线 : " + getAlarmCount(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION));
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION, true);
                    }
                } else {
                    //co报警器掉线异常恢复
                    setAlarmCount(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION)) {
                        ULog.i(TAG, "一氧化碳传感器掉线恢复");
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_CO_SENSOR_DROP_EXCEPTION, false);
                    }

                    if (value >= coSensorInfo.getHigherThreshold()) {
                        ULog.e(TAG,
                                "一氧化碳传感器报警 ，上报：" + getIsAlarmReported(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE) + " coExceptionNum " + getAlarmCount(
                                        AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE) +
                                        " threshold " + getRobot().getCoThreshold());
                        if (addAlarmCount(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE)) {
                            //一氧化碳值超过阈值异常

                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE);
                            List<String> params = new ArrayList<String>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(coSensorInfo.getHigherThreshold()));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE, true);
                        }
                    } else {
                        setAlarmCount(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE, 0);

                        if (getIsAlarmReported(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE)) {
                            //一氧化碳值超过阈值异常恢复
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.CO_ALARM_RESUME));
                            //cancelAlertSms(smsContentOfCoException, OPERATION);
                            setIsAlarmReported(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE, false);
                        }
                    }
                }
            }

        }

    }

    /**
     * 暂不支持的传感器
     * 二氧化碳传感器数据处理
     *
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processCo2DataChange(int enable,int status, int value) {
        //not supported yet
    }

    /**
     * 甲烷传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processCh4DataChange(int enable,int status, float value) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //甲烷传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().CH4_INFO != null) {
            Ch4SensorInfo ch4SensorInfo = mSensorManager.cacheInfo().CH4_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_CH4, String.valueOf(value),
                    ch4SensorInfo.getInstallPosition(), String.valueOf(status),
                    ch4SensorInfo.getType());
            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == 0) {
                    //甲烷报警器掉线异常
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION, true);
                    }
                    ULog.e(TAG,
                            "甲烷传感器掉线 ，上报： " + getIsAlarmReported(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION) + ",次数:" + getAlarmCount(
                                    AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION));
                } else {
                    //甲烷传感器掉线异常恢复
                    setAlarmCount(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_CH4_SENSOR_DROP_EXCEPTION, false);
                    }

                    if (value >= ch4SensorInfo.getHigherThreshold()) {
                        if (addAlarmCount(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE) > mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE)) {
                            //甲烷值超过阈值异常
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE);
                            List<String> params = new ArrayList<String>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(ch4SensorInfo.getHigherThreshold()));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE, true);

                            ULog.e(TAG,
                                    "甲烷传感器超出阈值 ，上报： " + getIsAlarmReported(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE) + " ，次数： " + getAlarmCount(
                                            AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE) + " " +
                                            "threshold " + getRobot().getCh4Thershold());
                            if (mCurrent >= 0) {
                                ULog.d(TAG, "ch4ExceptionNum run: 甲烷超标断电 甲烷闭锁 电池充电中，不触发关机 ");
                            } else if (!getRobotConfigParams().getCloseCH4PowerOff()) {
                                //甲烷超标断电
                                mHandler.postDelayed(new Runnable() {
                                    @Override
                                    public void run() {
                                        ULog.d(TAG, "ch4ExceptionNum run: 甲烷超标断电");
                                        if (mRobotType.getSubType() != RobotSubType.BZ) {
                                            BaseBmsCommunicator.getInstance().enterPowerSaveMode(65535,
                                                    "CH4-Over-Threshold_" + value);
//                                        stmExecute.executeTask(new StmTask().powerOff());
                                        }
                                    }
                                }, 500);
                            }
                        }

                    } else {
                        //甲烷值正常
                        setAlarmCount(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE, 0);

                        //甲烷值超过阈值异常恢复
                        if (getIsAlarmReported(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.CH4_ALARM_RESUME));
                            //cancelAlertSms("机器人" + getRobot().getId() +", "+ smsContentOfCh4Exception, OPERATION);
                            setIsAlarmReported(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE, false);
                        }
                    }
                }
            }
        }
    }

    /**
     * 硫化氢传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processH2sDataChange(int enable,int status, float value) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //硫化氢传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().H2S_INFO != null) {
            H2sSensorInfo h2sSensorInfo = mSensorManager.cacheInfo().H2S_INFO;
            //更新传感器数据
            updateSensorData(SensorType.SENSOR_TYPE_H2S, String.valueOf(value),
                    h2sSensorInfo.getInstallPosition(), String.valueOf(status), h2sSensorInfo.getType());

            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == UConstants.SENSOR_STATUS_NORMAL) {
                    //硫化氢传感器正常
                    if (value >= h2sSensorInfo.getHigherThreshold()) {
                        //硫化氢传感器超出阈值
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            List<String> params = new ArrayList<String>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(h2sSensorInfo.getHigherThreshold()));
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION,
                                    params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
                        }
                    } else {
                        //硫化氢传感器值正常
                        setAlarmCount(AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
                        if (getAlarmCount(AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION) == 0 && getIsAlarmReported(
                                AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            RxBus.getInstance()
                                    .post(new AlarmEvent(AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_H2S_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
                        }
                    }

                } else {
                    //硫化氢传感器掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.H2S_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.H2S_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.H2S_SENSOR_DROP_EXCEPTION, true);
                    }

                }
            }

        }
    }

    /**
     * 氨气传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processNh3DataChange(int enable,int status, float value) {
        //ULog.d(TAG,"氨气传感器 1 enable:"+enable+" status:"+status+" value:"+value);
        if (enable != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }

        //氨气传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().NH3_INFO != null) {
            Nh3SensorInfo nh3SensorInfo = mSensorManager.cacheInfo().NH3_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_NH3, String.valueOf(value),
                    nh3SensorInfo.getInstallPosition(), String.valueOf(status), nh3SensorInfo.getType());
            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == UConstants.SENSOR_STATUS_NORMAL) {
                    //氨气传感器正常
                    setAlarmCount(AlarmTypeEnum.NH3_SENSOR_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.NH3_SENSOR_DROP_EXCEPTION)) {
                        ULog.d(TAG,"氨气传感器 恢复连接---");
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.NH3_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.NH3_SENSOR_DROP_EXCEPTION, false);
                    }

                    if (value >= nh3SensorInfo.getHigherThreshold()) {
                        //氨气值高于阈值
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_NH3_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.ROBOT_NH3_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(nh3SensorInfo.getHigherThreshold()));
                            ULog.d(TAG,"氨气传感器 数值超阈值常---");
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_NH3_HIGHER_THAN_THRESHOLD_EXCEPTION,
                                    params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_NH3_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
                        }
                    } else {
                        //氨气值正常
                        setAlarmCount(AlarmTypeEnum.ROBOT_NH3_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_NH3_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            ULog.d(TAG,"氨气传感器 数值恢复正常---");
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_NH3_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_NH3_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
                        }
                    }

                } else {
                    //氨气传感器掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.NH3_SENSOR_DROP_EXCEPTION)) {
                        ULog.d(TAG,"氨气传感器 掉线---");
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.NH3_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.NH3_SENSOR_DROP_EXCEPTION, true);
                    }

                }
            }

        }

    }

    /**
     * 氧气传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processO2DataChange(int enable,int status, float value) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }
        //氧气传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().O2_INFO != null) {
            O2SensorInfo o2SensorInfo = mSensorManager.cacheInfo().O2_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_O2, String.valueOf(value),
                    o2SensorInfo.getInstallPosition(), String.valueOf(status), o2SensorInfo.getType());

            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == UConstants.SENSOR_STATUS_NORMAL) {
                    setAlarmCount(AlarmTypeEnum.OXYGEN_SENSOR_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.OXYGEN_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.OXYGEN_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.OXYGEN_SENSOR_DROP_EXCEPTION, false);
                    }

                    //氧气浓度高阈值判断
                    if (value >= o2SensorInfo.getHigherThreshold()) {
                        //氧气浓度高于阈值
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            List<String> params = new ArrayList<String>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(o2SensorInfo.getHigherThreshold()));
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION,
                                    params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
                        }
                    } else {
                        setAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
                        }
                    }

                    //氧气浓度低阈值判断
                    if (value <= o2SensorInfo.getLowerThreshold()) {
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION)) {
                            List<String> params = new ArrayList<String>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(o2SensorInfo.getLowerThreshold()));
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION,
                                    params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION, true);
                        }
                    } else {
                        setAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION, false);
                        }
                    }
                } else {
                    //氧气传感器掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.OXYGEN_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.OXYGEN_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.OXYGEN_SENSOR_DROP_EXCEPTION, true);
                    }
                }
            }


        }

    }
    public String getCurrentTaskNodeName() {
        return (inspectManager.mCurrentTaskNode != null && !TextUtils.isEmpty(inspectManager.mCurrentTaskNode.getName())) ? inspectManager.mCurrentTaskNode.getName() : "未知节点";
    }
    public static String getSensorAlarmFirstParam() {
        if (InspectManager.mCurrentTaskNode != null) {
            return InspectManager.mCurrentTaskNode.getName() + " " + FormatUtils.keepDecimals(mDistance, 2);
        } else {
            return String.valueOf(FormatUtils.keepDecimals(mDistance, 2));
        }
    }
    public static Integer getSensorAlarmTaskNodeId() {
        if (InspectManager.mCurrentTaskNode != null) {
            return InspectManager.mCurrentTaskNode.getId();
        } else {
            return null;
        }
    }
    public static TSensorHistoryRecordException getSensorHisData() {
        TSensorHistoryRecordException sensorHis = new TSensorHistoryRecordException();
        sensorHis.setSegmentId(mSegment.getId());
        sensorHis.setRobotId(getRobot().getId());
        sensorHis.setRobotName(getRobot().getName());
        sensorHis.setMileage(BigDecimal.valueOf(mDistance));
        sensorHis.setDecibel(BigDecimal.valueOf(getRobot().getDecibel()));
        if (currentHeartData != null) {
            sensorHis.setSmoke(BigDecimal.valueOf(currentHeartData.getSmokeStatus()));
            sensorHis.setPm25(BigDecimal.valueOf(currentHeartData.getPm25Value()));
            sensorHis.setPm10(BigDecimal.valueOf(currentHeartData.getPm10Value()));
            sensorHis.setO2(BigDecimal.valueOf(currentHeartData.getO2Value()));
            sensorHis.setCo(BigDecimal.valueOf(currentHeartData.getCoValue()));
            sensorHis.setCh4(BigDecimal.valueOf(currentHeartData.getCh4Value()));
            sensorHis.setSf6(BigDecimal.valueOf(currentHeartData.getSf6Value()));
            sensorHis.setH2s(BigDecimal.valueOf(currentHeartData.getH2sValue()));
            sensorHis.setInsideTemperature(BigDecimal.valueOf(currentHeartData.getInnerTempValue()));
            sensorHis.setInsideHumidity(BigDecimal.valueOf(currentHeartData.getInnerHumidityValue()));
            if (currentHeartData.getOutsideTempValue() == 0 && currentHeartData.getOutsideHumidityValue() == 0) {
                float temp = StorageCenter.getRobotStorage().getFloat(UConstants.PREFERENCES_OUTSIDE_TEMP_KEY, 0f);
                float humidity = StorageCenter.getRobotStorage().getFloat(UConstants.PREFERENCES_OUTSIDE_HUMIDITY_KEY, 0f);
                if (temp == 0) {
                    temp = currentHeartData.getInnerTempValue() - 8;
                }
                sensorHis.setTemperature(BigDecimal.valueOf(temp));
                sensorHis.setHumidity(BigDecimal.valueOf(humidity));
            } else {
                sensorHis.setTemperature(BigDecimal.valueOf(currentHeartData.getOutsideTempValue()));
                sensorHis.setHumidity(BigDecimal.valueOf(currentHeartData.getOutsideHumidityValue()));
            }
            sensorHis.setConcentration(BigDecimal.valueOf(currentHeartData.getNh3Value())); //氨气
            sensorHis.setH2(BigDecimal.valueOf(currentHeartData.getH2Value()));
        }
        return sensorHis;
    }
    /**
     * 六氟化硫传感器数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processSf6DataChange(int enable,int status, int value) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //SF6 传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().SF6_INFO != null) {
            Sf6SensorInfo sf6SensorInfo = mSensorManager.cacheInfo().SF6_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_SF6, String.valueOf(value),
                    sf6SensorInfo.getInstallPosition(), String.valueOf(status), sf6SensorInfo.getType());

            //使能状态处理及报警
            if (sensorEnableStatus) {
                if (status == UConstants.SENSOR_STATUS_NORMAL) {
                    //SF6传感器状态正常
                    setAlarmCount(AlarmTypeEnum.SF6_SENSOR_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.SF6_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.SF6_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.SF6_SENSOR_DROP_EXCEPTION, false);
                    }

                    if (value < sf6SensorInfo.getHigherThreshold()) {
                        //sf6 值正常
                        setAlarmCount(AlarmTypeEnum.SF6_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.SF6_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.SF6_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.SF6_EXCEPTION, false);
                        }

                    } else {
                        //SF6高于出阈值
                        if (addAlarmCount(AlarmTypeEnum.SF6_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.SF6_EXCEPTION)) {
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(sf6SensorInfo.getHigherThreshold()));
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.SF6_EXCEPTION, params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                            setIsAlarmReported(AlarmTypeEnum.SF6_EXCEPTION, true);
                        }
                    }

                } else {
                    //SF6传感器掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.SF6_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.SF6_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.SF6_SENSOR_DROP_EXCEPTION, true);
                    }
                }
            }
        }

    }

    /**
     * pm2.5 传感器值处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processPm25DataChange(int enable,int status, int value) {
        //暂没有独立的pm2.5传感器

    }

    /**
     * pm10 传感器值处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processPm10DataChange(int enable,int status, int value) {
        if (enable != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }
        if (mSensorManager != null && mSensorManager.cacheInfo().PM10_INFO != null) {
            Pm10SensorInfo pm10SensorInfo = mSensorManager.cacheInfo().PM10_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_PM10, String.valueOf(value),
                    pm10SensorInfo.getInstallPosition(), String.valueOf(status), pm10SensorInfo.getType());
            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == UConstants.SENSOR_STATUS_NORMAL) {
                    //pm10掉线恢复
                    setAlarmCount(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION, 0);

                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION, false);
                    }
                    //pm10传感器正常
                    if (value >= pm10SensorInfo.getHigherThreshold()) {
                        //pm10高于阈值
                        if (!isInCleanDeviceArea(mDistance) && addAlarmCount(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            //粉尘值超过阈值异常
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(pm10SensorInfo.getHigherThreshold()));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
                        }
                    } else {
                        //pm10正常
                        setAlarmCount(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
                        }
                    }

                } else {
                    //pm10传感器掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION, true);
                    }
                }
            }
        }
    }


    /**
     * h2 传感器值处理
     * @param enable 是否使能
     * @param status 状态
     * @param value 值
     */
    private void processH2DataChange(int enable,int status, int value) {
        if (enable != UConstants.VALUE_SWITCH_STATUS_ON) {
            return;
        }

        //氢气传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().H2_INFO != null) {
            H2SensorInfo h2SensorInfo = mSensorManager.cacheInfo().H2_INFO;
            updateSensorData(SensorType.SENSOR_TYPE_H2, String.valueOf(value),
                    h2SensorInfo.getInstallPosition(), String.valueOf(status), h2SensorInfo.getType());

            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == UConstants.SENSOR_STATUS_NORMAL) {
                    //氢气传感器正常
                    setAlarmCount(AlarmTypeEnum.ROBOT_H2_SENSOR_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_H2_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_H2_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_H2_SENSOR_DROP_EXCEPTION, false);
                    }
                    if (value >= h2SensorInfo.getHigherThreshold()) {
                        //氢气值高于阈值
                        if (addAlarmCount(AlarmTypeEnum.ROBOT_H2_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.ROBOT_H2_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(value, 1)));
                            params.add(String.valueOf(h2SensorInfo.getHigherThreshold()));
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_H2_HIGHER_THAN_THRESHOLD_EXCEPTION,
                                    params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_H2_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
                        }
                    } else {
                        //氢气值正常
                        setAlarmCount(AlarmTypeEnum.ROBOT_H2_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_H2_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_H2_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_H2_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
                        }
                    }
                } else {
                    //氢气传感器掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_H2_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_H2_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_H2_SENSOR_DROP_EXCEPTION, true);
                    }
                }
            }
        }

    }

    /**
     * 气体采集板数据处理
     * @param enable 是否使能
     * @param status 状态
     * @param coValue 一氧化碳值
     * @param ch4Value 甲烷值
     * @param o2Value 氧气值
     */
    private void processGasBoardDataChange(int enable, int status, int coValue, float ch4Value, float o2Value) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //气体采集板
        if (mSensorManager != null && mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO != null) {
            GasCollectionBoardSensorInfo gasboardSensorInfo = mSensorManager.cacheInfo().GAS_COLLECTION_BOARD_INFO;
            CoSensorInfo coSensorInfo =
                    (CoSensorInfo) gasboardSensorInfo.getChildSensors().get(SensorType.SENSOR_TYPE_CO);
            Ch4SensorInfo ch4SensorInfo = (Ch4SensorInfo) gasboardSensorInfo.getChildSensors()
                    .get(SensorType.SENSOR_TYPE_CH4);
            O2SensorInfo o2SensorInfo = (O2SensorInfo) gasboardSensorInfo.getChildSensors()
                    .get(SensorType.SENSOR_TYPE_O2);

            Map<String, String> valuesMap = new HashMap<>();
            if (coSensorInfo != null) {
                valuesMap.put(SensorType.SENSOR_TYPE_CO,
                        JSON.toJSONString(new SensorData(SensorType.SENSOR_TYPE_CO, String.valueOf(coValue),
                                coSensorInfo.getInstallPosition(), String.valueOf(status),
                                coSensorInfo.getType())));
            }
            if (ch4SensorInfo != null) {
                valuesMap.put(SensorType.SENSOR_TYPE_CH4,
                        JSON.toJSONString(new SensorData(SensorType.SENSOR_TYPE_CH4, String.valueOf(ch4Value),
                                ch4SensorInfo.getInstallPosition(), String.valueOf(status),
                                ch4SensorInfo.getType())));
            }
            if (o2SensorInfo != null) {
                valuesMap.put(SensorType.SENSOR_TYPE_O2,
                        JSON.toJSONString(new SensorData(SensorType.SENSOR_TYPE_O2, String.valueOf(o2Value),
                                o2SensorInfo.getInstallPosition(), String.valueOf(status),
                                o2SensorInfo.getType())));
            }
            if (gasboardSensorInfo != null) {
                updateSensorData(SensorType.SENSOR_TYPE_GAS_COLLECTION_BOARD, "",
                        gasboardSensorInfo.getInstallPosition(), String.valueOf(status),
                        gasboardSensorInfo.getType(), valuesMap);
            }

            //使能状态处理及报警
            if(sensorEnableStatus){
                if (status == 1) {
                    //气体采集板状态正常
                    setAlarmCount(AlarmTypeEnum.ROBOT_GAS_SENSOR_BOARD_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_GAS_SENSOR_BOARD_DROP_EXCEPTION)) {
                        RxBus.getInstance()
                                .post(new AlarmEvent(AlarmTypeEnum.ROBOT_GAS_SENSOR_BOARD_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_GAS_SENSOR_BOARD_DROP_EXCEPTION, false);
                    }

                    //气体采集板-一氧化碳传感器
                    if (coSensorInfo.isEnabled()) {
                        if (coValue >= coSensorInfo.getHigherThreshold()) {
                            if (addAlarmCount(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE) >= mAlarmManager.getAlarmTriggerCount(
                                    AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE)) {
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE);
                                List<String> params = new ArrayList<String>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(String.valueOf(FormatUtils.keepDecimals(coValue, 1)));
                                params.add(String.valueOf(coSensorInfo.getHigherThreshold()));
                                alertEvent.setParams(params);
                                alertEvent.setSensorException(true);
                                alertEvent.setSensorHis(getSensorHisData());
                                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                                RxBus.getInstance().post(alertEvent);

                                setIsAlarmReported(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE, true);
                            }
                        } else {
                            setAlarmCount(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE, 0);
                            if (getIsAlarmReported(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE)) {
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.CO_ALARM_RESUME));
                                setIsAlarmReported(AlarmTypeEnum.CO_ALARM_THRESHOLD_HAVE_VALUE, false);
                            }
                        }
                    }

                    //气体采集板-甲烷传感器
                    if (ch4SensorInfo.isEnabled()) {
                        if (ch4Value >= ch4SensorInfo.getHigherThreshold()) {
                            if (addAlarmCount(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE) >= mAlarmManager.getAlarmTriggerCount(
                                    AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE)) {
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE);
                                List<String> params = new ArrayList<String>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(String.valueOf(FormatUtils.keepDecimals(ch4Value, 1)));
                                params.add(String.valueOf(ch4SensorInfo.getHigherThreshold()));
                                alertEvent.setParams(params);
                                alertEvent.setSensorException(true);
                                alertEvent.setSensorHis(getSensorHisData());
                                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                                RxBus.getInstance().post(alertEvent);
                                setIsAlarmReported(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE,
                                        true);
                                if (mCurrent >= 0) {
                                    ULog.d(TAG, "ch4ExceptionNum run: 甲烷超标断电 甲烷闭锁 电池充电中，不触发关机 ");
                                } else if (!getRobotConfigParams().getCloseCH4PowerOff()) {
                                    mHandler.postDelayed(new Runnable() {
                                        @Override
                                        public void run() {
                                            ULog.d(TAG, "ch4ExceptionNum run: 甲烷超标断电");
                                            if (mRobotType.getSubType() != RobotSubType.BZ) {
                                                BaseBmsCommunicator.getInstance().enterPowerSaveMode(65535,
                                                        "CH4-Over-Threshold_" + ch4Value);
//                                            stmExecute.executeTask(new StmTask().powerOff());
                                            }
                                        }
                                    }, 500);
                                }
                            }
                        } else {
                            setAlarmCount(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE, 0);
                            if (getIsAlarmReported(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE)) {
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.CH4_ALARM_RESUME));
                                setIsAlarmReported(AlarmTypeEnum.CH4_ALARM_THRESHOLD_HAVE_VALUE, false);
                            }
                        }
                    }

                    if (o2SensorInfo.isEnabled()) {
                        //气体采集板-氧气传感器
                        //氧气浓度高阈值判断
                        if (o2Value >= o2SensorInfo.getHigherThreshold()) {
                            //氧气浓度高于阈值
                            if (addAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                    AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                                List<String> params = new ArrayList<String>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(String.valueOf(FormatUtils.keepDecimals(o2Value, 1)));
                                params.add(String.valueOf(o2SensorInfo.getHigherThreshold()));
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION,
                                        params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
                            }
                        } else {
                            setAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
                            if (getIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_EXCEPTION_RESUME));
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
                            }
                        }

                        //氧气浓度低阈值判断
                        if (o2Value <= o2SensorInfo.getLowerThreshold()) {
                            if (addAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                    AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION)) {
                                List<String> params = new ArrayList<String>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(String.valueOf(FormatUtils.keepDecimals(o2Value, 1)));
                                params.add(String.valueOf(o2SensorInfo.getLowerThreshold()));
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION,
                                        params, true, getSensorHisData(), getSensorAlarmTaskNodeId()));
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION, true);
                            }
                        } else {
                            setAlarmCount(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION, 0);
                            if (getIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION)) {
                                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_OXYGEN_EXCEPTION_RESUME));
                                setIsAlarmReported(AlarmTypeEnum.ROBOT_OXYGEN_LOWER_THAN_THRESHOLD_EXCEPTION, false);
                            }
                        }

                    }

                } else {
                    //气体采集板掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_GAS_SENSOR_BOARD_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_GAS_SENSOR_BOARD_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_GAS_SENSOR_BOARD_DROP_EXCEPTION, true);
                    }
                }
            }

        }
    }

    /**
     * 六合一传感器数据处理
     *
     * @param enable 是否使能
     * @param status 状态
     * @param pm25Value pm2.5值
     * @param pm10Value pm10值
     * @param temp 外部温度
     * @param humidity 外部湿度
     */
    private void processSixInOneDataChange(int enable, int status,int pm25Value,int pm10Value,float temp,float humidity) {
        if (enable  != SensorConstants.STATUS_ENABLED) {
            return;
        }

        //六合一传感器
        if (mSensorManager != null && mSensorManager.cacheInfo().SIX_IN_ONE_INFO != null) {
            SixInOneSensorInfo sixInOneSensorInfo = mSensorManager.cacheInfo().SIX_IN_ONE_INFO;
            HashMap<String, String> valueMap = new HashMap<>();
            valueMap.put(SixInOneSensorConfigConstants.Values.VALUE_PM25, String.valueOf(pm25Value));
            //标准Cicada没有启用PM10
            valueMap.put(SixInOneSensorConfigConstants.Values.VALUE_PM10, String.valueOf(pm10Value));
            valueMap.put(SixInOneSensorConfigConstants.Values.VALUE_TEMPERATURE, String.valueOf(temp));
            valueMap.put(SixInOneSensorConfigConstants.Values.VALUE_HUMIDITY, String.valueOf(humidity));
            updateSensorData(SensorType.SENSOR_TYPE_6IN1, "",
                    sixInOneSensorInfo.getInstallPosition(), String.valueOf(status),
                    sixInOneSensorInfo.getType(), valueMap);

            //使能状态处理及报警
            if(sensorEnableStatus) {
                //粉尘/pm2.5传感器
                if (status == 0) {
                    ULog.e(TAG,
                            "粉尘传感器掉线 : " + getAlarmCount(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION));
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION)) {
                        //粉尘报警器掉线异常
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION, true);
                    }
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION)) {
                        //粉尘报警器掉线异常
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION, true);
                    }
                } else {
                    setAlarmCount(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION, 0);
                    //粉尘报警器掉线异常恢复
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_DUST_SENSOR_DROP_EXCEPTION, false);
                    }
                    setAlarmCount(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION, 0);
                    //粉尘报警器掉线异常恢复
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_SENSOR_DROP_EXCEPTION, false);
                    }

                    if (pm25Value >= sixInOneSensorInfo.getPm25HigherThreshold()) {
                        ULog.e(TAG,
                                "粉尘传感器值超出阈值，已上报： : " + getIsAlarmReported(AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE) + "，次数： " + getAlarmCount(
                                        AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE) +
                                        " threshold " + getRobot().getDustThreshold());

                        if (!isInCleanDeviceArea(mDistance) && addAlarmCount(AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE)) {
                            //粉尘值超过阈值异常
//                        if (getRobot().getDustThreshold() != null) {
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(pm25Value, 1)));
                            params.add(String.valueOf(sixInOneSensorInfo.getPm25HigherThreshold()));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE, true);
//                        }
                        }
                    } else {
                        setAlarmCount(AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE, 0);
                        //粉尘值超过阈值异常恢复
                        if (getIsAlarmReported(AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.DUST_ALARM_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.DUST_ALARM_THRESHOLD_HAVE_VALUE, false);
                        }
                    }

                    if (pm10Value >= sixInOneSensorInfo.getPm10HigherThreshold()) {
                        ULog.e(TAG, "6合1感器 pm10值超出阈值，已上报： : " + getIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION) + "，次数： " + getAlarmCount(
                                AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION) +
                                " threshold " + getRobot().getDustThreshold());

                        if (!isInCleanDeviceArea(mDistance) && addAlarmCount(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                                AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            //粉尘值超过阈值异常
//                        if (getRobot().getDustThreshold() != null) {
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(pm10Value, 1)));
                            params.add(String.valueOf(sixInOneSensorInfo.getPm10HigherThreshold()));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
//                        }
                        }
                    } else {
                        setAlarmCount(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
                        //粉尘值超过阈值异常恢复
                        if (getIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                            RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION_RESUME));
                            setIsAlarmReported(AlarmTypeEnum.ROBOT_PM10_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
                        }
                    }

                    if(sixInOneSensorInfo.getTemperatureHighThreshold() != null && temp >= sixInOneSensorInfo.getTemperatureHighThreshold()){
                        ULog.d(TAG,"六合一传感器,外部温度"+temp+"高于阈值"+sixInOneSensorInfo.getTemperatureHighThreshold());
                        if (addAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION) >=
                                mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION)) {
                            //外部温度超过阈值异常
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(temp, 2)));
                            params.add(String.valueOf(FormatUtils.keepDecimals(sixInOneSensorInfo.getTemperatureHighThreshold(), 2)));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION, false);
                        }
                    }else{
                        setAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION, 0);
                    }

                    if(sixInOneSensorInfo.getTemperatureLowerThreshold() != null && temp <= sixInOneSensorInfo.getTemperatureLowerThreshold()){
                        ULog.d(TAG,"六合一传感器,外部温度"+temp+"低于阈值"+sixInOneSensorInfo.getTemperatureLowerThreshold());
                        if (addAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION) >=
                                mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION)) {
                            //外部温度低于阈值异常
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(temp, 2)));
                            params.add(String.valueOf(FormatUtils.keepDecimals(sixInOneSensorInfo.getTemperatureLowerThreshold(), 2)));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION, false);
                        }
                    }else{
                        setAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION, 0);
                    }

                    //除尘设备附近外部湿度容易被喷水影响 所以不在除尘设备附近检测外部湿度
                    if (!isInCleanDeviceArea(mDistance)){
                        if(sixInOneSensorInfo.getHumidityHigherThreshold() != null && humidity >= sixInOneSensorInfo.getHumidityHigherThreshold()){
                            ULog.d(TAG,"六合一传感器,外部湿度"+humidity+"高于阈值"+sixInOneSensorInfo.getHumidityHigherThreshold());
                            if (addAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION) >=
                                    mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION)) {
                                //外部温度超过阈值异常
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION);
                                List<String> params = new ArrayList<>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(String.valueOf(FormatUtils.keepDecimals(humidity, 2)));
                                params.add(String.valueOf(FormatUtils.keepDecimals(sixInOneSensorInfo.getHumidityHigherThreshold(), 2)));
                                alertEvent.setParams(params);
                                alertEvent.setSensorException(true);
                                alertEvent.setSensorHis(getSensorHisData());
                                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                                RxBus.getInstance().post(alertEvent);
                                setIsAlarmReported(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION, false);
                            }
                        }else{
                            setAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION, 0);
                        }
                    }

                    if(sixInOneSensorInfo.getHumidityLowerThreshold() != null && humidity !=0  && humidity <= sixInOneSensorInfo.getHumidityLowerThreshold()){
                        ULog.d(TAG,"六合一传感器,外部湿度"+humidity+"低于阈值"+sixInOneSensorInfo.getHumidityLowerThreshold());
                        if (addAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION) >=
                                mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION)) {
                            //外部温度超过阈值异常
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(humidity, 2)));
                            params.add(String.valueOf(FormatUtils.keepDecimals(sixInOneSensorInfo.getHumidityLowerThreshold(), 2)));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION, false);
                        }
                    }else{
                        setAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION, 0);
                    }

                }
            }

        }
    }

    /**
     * 外部温湿度传感器数据处理
     * @param status 状态
     * @param temp 外部温度
     * @param humidity 外部湿度
     */
    private void processOutsideTempHumidityDataChange(int enable, int status,float temp, float humidity) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }

        robotOutsideTemperature = temp;

        if (mSensorManager != null) {
            //外部温湿度传感器
            if (mSensorManager.cacheInfo().TEMP_HUMIDITY_INFO != null) {
                TemperatureHumiditySensorInfo tempHumiditySensorInfo = mSensorManager.cacheInfo().TEMP_HUMIDITY_INFO;
                HashMap<String, String> valueMap = new HashMap<>();
                valueMap.put(TemperatureHumiditySensorConfigConstants.Values.TEMPERATURE, String.valueOf(temp));
                valueMap.put(TemperatureHumiditySensorConfigConstants.Values.HUMIDITY, String.valueOf(humidity));

                updateSensorData(SensorType.SENSOR_TYPE_TEMPERATURE_HUMIDITY, "",
                        tempHumiditySensorInfo.getInstallPosition(), String.valueOf(status),
                        tempHumiditySensorInfo.getType(), valueMap);

                if (temperatureSensorState == 1) {
                    if (TemperatureHumiditySensorConfigConstants.InstallPosition.OUTSIDE_NEAR_IR.equals(tempHumiditySensorInfo.getInstallPosition())) {
                        mBotInfoMgr.setOutsideTemp(temp);
                    }
                }
                if (status == 1) {
                    setAlarmCount(AlarmTypeEnum.ROBOT_TEMPERATURE_HUMIDITY_SENSOR_BOARD_DROP_EXCEPTION, 0);
                    if (getIsAlarmReported(AlarmTypeEnum.ROBOT_TEMPERATURE_HUMIDITY_SENSOR_BOARD_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_TEMPERATURE_HUMIDITY_SENSOR_BOARD_DROP_EXCEPTION_RESUME));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_TEMPERATURE_HUMIDITY_SENSOR_BOARD_DROP_EXCEPTION, false);
                    }

                    if(tempHumiditySensorInfo.getTempHighThreshold() != null && temp >= tempHumiditySensorInfo.getTempHighThreshold()){
                        ULog.d(TAG,"外部温湿度传感器,外部温度"+temp+"高于阈值"+tempHumiditySensorInfo.getTempHighThreshold());
                        if (addAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION) >=
                                mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION)) {
                            //外部温度超过阈值异常
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(temp, 2)));
                            params.add(String.valueOf(FormatUtils.keepDecimals(tempHumiditySensorInfo.getTempHighThreshold(), 2)));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION, false);
                        }
                    }else{
                        setAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_HIGHER_EXCEPTION, 0);
                    }

                    if(tempHumiditySensorInfo.getTempLowThreshold() != null && temp <= tempHumiditySensorInfo.getTempLowThreshold()){
                        ULog.d(TAG,"外部温湿度传感器,外部温度"+temp+"低于阈值"+tempHumiditySensorInfo.getTempLowThreshold());
                        if (addAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION) >=
                                mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION)) {
                            //外部温度低于阈值异常
                            AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION);
                            List<String> params = new ArrayList<>();
                            params.add(getSensorAlarmFirstParam());
                            params.add(String.valueOf(FormatUtils.keepDecimals(temp, 2)));
                            params.add(String.valueOf(FormatUtils.keepDecimals(tempHumiditySensorInfo.getTempLowThreshold(), 2)));
                            alertEvent.setParams(params);
                            alertEvent.setSensorException(true);
                            alertEvent.setSensorHis(getSensorHisData());
                            alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                            RxBus.getInstance().post(alertEvent);
                            setIsAlarmReported(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION, false);
                        }
                    }else{
                        setAlarmCount(AlarmTypeEnum.OUTSIDE_TEMPERATURE_LOWER_EXCEPTION, 0);
                    }

                    //除尘设备附近外部湿度容易被喷水影响 所以不在除尘设备附近检测外部湿度
                    if (!isInCleanDeviceArea(mDistance)){
                        if(tempHumiditySensorInfo.getHumidityHighThreshold() != null && humidity >= tempHumiditySensorInfo.getHumidityHighThreshold()){
                            ULog.d(TAG,"外部温湿度传感器,外部湿度"+humidity+"高于阈值"+tempHumiditySensorInfo.getHumidityHighThreshold());
                            if (addAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION) >=
                                    mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION)) {
                                //外部温度超过阈值异常
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION);
                                List<String> params = new ArrayList<>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(String.valueOf(FormatUtils.keepDecimals(humidity, 2)));
                                params.add(String.valueOf(FormatUtils.keepDecimals(tempHumiditySensorInfo.getHumidityHighThreshold(), 2)));
                                alertEvent.setParams(params);
                                alertEvent.setSensorException(true);
                                alertEvent.setSensorHis(getSensorHisData());
                                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                                RxBus.getInstance().post(alertEvent);
                                setIsAlarmReported(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION, false);
                            }
                        }else{
                            setAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_HIGHER_EXCEPTION, 0);
                        }

                        if(tempHumiditySensorInfo.getHumidityLowThreshold() != null && humidity !=0 && humidity <= tempHumiditySensorInfo.getHumidityLowThreshold()){
                            ULog.d(TAG,"外部温湿度传感器,外部湿度"+humidity+"低于阈值"+tempHumiditySensorInfo.getHumidityLowThreshold());
                            if (addAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION) >=
                                    mAlarmManager.getAlarmTriggerCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION)) {
                                //外部温度超过阈值异常
                                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION);
                                List<String> params = new ArrayList<>();
                                params.add(getSensorAlarmFirstParam());
                                params.add(String.valueOf(FormatUtils.keepDecimals(humidity, 2)));
                                params.add(String.valueOf(FormatUtils.keepDecimals(tempHumiditySensorInfo.getHumidityLowThreshold(), 2)));
                                alertEvent.setParams(params);
                                alertEvent.setSensorException(true);
                                alertEvent.setSensorHis(getSensorHisData());
                                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                                RxBus.getInstance().post(alertEvent);
                                setIsAlarmReported(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION, false);
                            }
                        }else{
                            setAlarmCount(AlarmTypeEnum.OUTSIDE_HUMIDITY_LOWER_EXCEPTION, 0);
                        }
                    }
                } else {
                    //掉线
                    if (isNeedAlarmSensorDrop(AlarmTypeEnum.ROBOT_TEMPERATURE_HUMIDITY_SENSOR_BOARD_DROP_EXCEPTION)) {
                        RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_TEMPERATURE_HUMIDITY_SENSOR_BOARD_DROP_EXCEPTION));
                        setIsAlarmReported(AlarmTypeEnum.ROBOT_TEMPERATURE_HUMIDITY_SENSOR_BOARD_DROP_EXCEPTION, true);
                    }
                }
            }
        }

    }

    //内部湿度处理
    private void processInternalHumidityDataChange(int enable, int status, float humidity) {
        if (enable != SensorConstants.STATUS_ENABLED) {
            return;
        }
        getRobot().setInternalHumidity(humidity);


        if (humidity >= getRobotConfigParams().getInternalHumidityThreshold()) {
            ULog.e(TAG, "内部湿度值超出阈值，已上报： : " + getIsAlarmReported(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION) + "，次数： " + getAlarmCount(
                    AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION) +
                    " threshold " + getRobotConfigParams().getInternalHumidityThreshold());

            if (addAlarmCount(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION) >= mAlarmManager.getAlarmTriggerCount(
                    AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                //内部湿度超过阈值异常
                AlarmEvent alertEvent = new AlarmEvent(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION);
                List<String> params = new ArrayList<>();
                params.add(getSensorAlarmFirstParam());
                params.add(String.valueOf(FormatUtils.keepDecimals(humidity, 1)));
                params.add(String.valueOf(getRobotConfigParams().getInternalHumidityThreshold()));
                alertEvent.setParams(params);
                alertEvent.setSensorException(true);
                alertEvent.setSensorHis(getSensorHisData());
                alertEvent.setTaskNodeId(getSensorAlarmTaskNodeId());
                RxBus.getInstance().post(alertEvent);
                setIsAlarmReported(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION, true);
            }
        } else {
            setAlarmCount(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION, 0);
            //内部湿度值超过阈值异常恢复
            if (getIsAlarmReported(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION)) {
                RxBus.getInstance().post(new AlarmEvent(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION_RESUME));
                setIsAlarmReported(AlarmTypeEnum.ROBOT_INTERNAL_HUMIDITY_HIGHER_THAN_THRESHOLD_EXCEPTION, false);
            }
        }
    }

    /**
     * ****************************************************************************************************************
     * ************************************** 数值类传感器数据处理  end    ********************************************
     * ****************************************************************************************************************
     */


    /**
     * 正常用户使用软件急停功能不应该直接调用这个方法 这个方法是机器人内部使用的 如外部用户想软件急停控制机器人 有两种方式
     * 1.可以修改机器人的config字段中的 {@link fun.unifun.library.android.bean.RobotConfigParams.softEmergencyStop}软件急停标志位
     *      和更新软件急停时间{@link fun.unifun.library.android.bean.RobotConfigParams.softEmergencyStopUpdateTime}
     * 2.或者通过 {@link #ctrlSoftEmergencyStop}方法来控制软件急停开或者关
     */
    private void openSoftEmergencyStop(String tag) {
        ULog.d(TAG, "openSoftEmergencyStop:  ====== 开启软件急停 tag:"+tag);
        removeHindranceRetryMsg();
        mCmdAfterRoomOp = null;
        isSoftEmergencyStop = true;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_ROBOT_SOFT_EMERGENCY_STOP_KEY, isSoftEmergencyStop);
        MainApp.softEmergencyStopButton = 1;
        //停止
        stmExecute.executeTaskNonQueue(new StmTask().stopMove("开启软件急停 81"));
        if (mHandler.hasMessages(Msg.WHAT_COKE_OVEN_INSPECT)) {
            mHandler.removeMessages(Msg.WHAT_COKE_OVEN_INSPECT);
        }
    }

    /**
     * {@link #openSoftEmergencyStop}
     */
    private void closeSoftEmergencyStop(String tag) {
    ULog.d(TAG, "closeSoftEmergencyStop:  ====== 关闭软件急停 tag:"+tag);
        isSoftEmergencyStop = false;
        MainApp.softEmergencyStopButton = 0;
        UPreferences.putBoolean(mActivity, UConstants.PREFERENCES_ROBOT_SOFT_EMERGENCY_STOP_KEY, isSoftEmergencyStop);
    }

    public void setStmTarget(int type,String logTag){
        ULog.d(TAG,"setStmTarget type:"+type+"  logTag:"+logTag);
        switch (type){
            case StmTask.TARGET_CHARGER:
            case StmTask.TARGET_CLEAN:
                stmExecute.executeTask(new StmTask().setTarget(type));
                break;
            case StmTask.TARGET_CANCEL:
                if(!SwitchTrackController.NEED_FIND_IN_PLACE_SWITCH_FOR_SWITCH_TRACK_DEVICE && !ElevatorController.NEED_FIND_IN_PLACE_SWITCH_FOR_ELEVATOR_DEVICE) {
                    stmExecute.executeTask(new StmTask().setTarget(type));
                }
                break;
            default:
                break;
        }

    }

    private void setRobotActionCode(int code) {
        //进入阻碍状态时，移除延时退出阻碍消息
        if (RobotActionCode.isHindranceCode(code)) {
            mHandler.removeMessages(Msg.WHAT_QUIT_MOVE_HINDER_STATUS);
        }
        mBotInfoMgr.setRobotActionCode(code);
    }
    public SensorManager getRobotSensorManager(){
        return this.mSensorManager;
    }

    /**
     * 蓝牙控制软件急停时机器人主动修改config字段并上传
     * @param enable
     */
    private void setSoftEmergencyStop(boolean enable,long btSetSoftStopTime,String logTag){
        if(getRobot() != null){
            ULog.d(TAG,"getRobotConfigParams enable:"+enable+" Time:"+btSetSoftStopTime +" logTag:"+logTag);
            UpdateById updateById = new UpdateById();
            Robot robot = new Robot();
            robot.setId(getRobot().getId());
            String configParams = getRobot().getConfigParams();
            RobotConfigParams robotConfigParams = null;
            try{
                robotConfigParams = UGson.getGson().fromJson(configParams, RobotConfigParams.class);
            }catch (Exception e){
                e.getLocalizedMessage();
                ULog.e(TAG,"setSoftEmergencyStop e="+e.getMessage()+" logTag:"+logTag);
            }
            if(robotConfigParams == null){
                ULog.w(TAG,"setSoftEmergencyStop 机器人配置解析失败!"+" logTag:"+logTag);
                return;
            }
            robotConfigParams.setSoftEmergencyStop(enable);
            robotConfigParams.setSoftEmergencyStopUpdateTime(btSetSoftStopTime);
            robot.setConfigParams(UGson.getGson().toJson(robotConfigParams));
            updateById.setRobot(robot);
            RobotServiceImpl.getInstance().getRobotService()
                    .updateRobotById(updateById)
                    .subscribeOn(Schedulers.io())
                    .subscribe(new NextErrorObserver<UpdateById>() {
                        @Override
                        public void onNext(@io.reactivex.rxjava3.annotations.NonNull UpdateById result) {
                            ULog.d(TAG, "setSoftEmergencyStop robot updateById onNext isSuccess=" + result.isSuccess()+" logTag:"+logTag);
                        }

                        @Override
                        public void onError(@io.reactivex.rxjava3.annotations.NonNull Throwable e) {
                            ULog.e(TAG, "setSoftEmergencyStop robot updateById onError e="+e.getMessage()+" logTag:"+logTag);

                        }
                    });
        }else{
            ULog.e(TAG, "获取机器人id失败"+" logTag:"+logTag);
        }
    }

    private void sendAlarmByRgbLensDirty(boolean dirty,String remoteImgUrl,String logtag){
        ULog.d(TAG,"sendAlarmByRgbLensDirty RgbSharpnessChecker dirty:"+dirty+" remoteImgUrl:"+remoteImgUrl+ " logtag:"+logtag);
        UpdateRobotRgbLensDirtyStateAndCheckAlarm update = new UpdateRobotRgbLensDirtyStateAndCheckAlarm();
        update.setRobotId(MainApp.mRobot.getId());
        update.setRgbLensDirtyState(dirty);
        update.setExceptionImgDir(remoteImgUrl);

        //本地存储一个值用来存镜头是否脏了  然后开机的时候加载下缓存  在这个方法的时候改下缓存  在巡检的时候检查下限制下移动
        UPreferences.putBoolean(mActivity, UConstants.KEY_RGB_LENS_DIRTY_STATE, dirty);
        rgbLensDirtyState = dirty;

        RobotServiceImpl.getInstance().getRobotService()
                .updateRobotRgbLensDirtyStateAndCheckAlarm(update)
                .subscribeOn(Schedulers.io())
                .subscribe(new NextErrorObserver<UpdateRobotRgbLensDirtyStateAndCheckAlarm>() {
                    @Override
                    public void onNext(@NonNull UpdateRobotRgbLensDirtyStateAndCheckAlarm updateRobotRgbLensDirtyStateAndCheckAlarm) {
                        ULog.d(TAG,"sendAlarmByRgbLensDirty RgbSharpnessChecker onNext "+updateRobotRgbLensDirtyStateAndCheckAlarm.isSuccess()+" logtag:"+logtag);
                    }

                    @Override
                    public void onError(@NonNull Throwable e) {
                         ULog.d(TAG,"sendAlarmByRgbLensDirty RgbSharpnessChecker onError e:"+e.getMessage() +" logtag:"+logtag);
                    }
                });
    }


    public boolean ctrlSoftEmergencyStop(boolean stop,String logTag){
        if (getRobotConfigParams() == null) {
            return false;
        }
        getRobotConfigParams().setSoftEmergencyStop(stop);
        long btSetSoftStopTime = System.currentTimeMillis();
        getRobotConfigParams().setSoftEmergencyStopUpdateTime(btSetSoftStopTime);
        setSoftEmergencyStop(stop, btSetSoftStopTime, "蓝牙控制更新远程急停状态和时间");//主动更新到服务端 无论成功或失败
        if (stop) {
            openSoftEmergencyStop(logTag);
        } else {
            closeSoftEmergencyStop(logTag);
        }
        return true;
    }

    public void ctrlTestMotorCurrent(boolean open){
        if(open){
            setTestMotorCurrentListener((distance, motorCurrent,motorCurrent2) -> {
                //在回调里面将消息发送给手机端
                //ctrlMap0.put("type", "distance_current_info");
                //ctrlMap0.put("distance", distance);
                //ctrlMap0.put("motor_current", motorCurrent);
            });
        }else{
            setTestMotorCurrentListener(null);
        }
    }

    public boolean ctrlDistanceCurrentLogSwitch(boolean open){
        if(open){
            boolean newFile = false;
            File logFile = new File(UConstants.DIR_MOTOR_CURRENT_LOG);
            ULog.i(TAG, "onDataReceived: " + logFile.getParentFile().exists());
            if (!logFile.getParentFile().exists()) {
                logFile.getParentFile().mkdirs();
            }
            if (!logFile.exists()) {
                try {
                    newFile = logFile.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            } else {
                if (logFile.isDirectory()) {
                    deleteDir(logFile);
                    try {
                        newFile = logFile.createNewFile();
                        newFile = true;
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                } else if (logFile.isFile()) {
                    newFile = true;
                }
            }
            if (!newFile) {
                ULog.d(TAG,"ctrlDistanceCurrentLogSwitch 机器人创建文件失败!");
                return false;
            }
            try {
                printWriter = new PrintWriter(logFile);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            }
            if (printWriter == null) {
                ULog.d(TAG,"ctrlDistanceCurrentLogSwitch 准备写数据失败!");
                return false;
            }
            distanceAndMotorCurrentTestLogSwitch = newFile;
            ULog.i(TAG, "onDataReceived: distance_current_log_switch_open." + distanceAndMotorCurrentTestLogSwitch);
        }else{
            distanceAndMotorCurrentTestLogSwitch = false;
            if (printWriter != null) {
                printWriter.flush();
                printWriter.close();
            }
        }
        return true;
    }

    public void distanceCurrentLogSwitchUpload(){
        if (distanceAndMotorCurrentTestLogSwitch) {
            //TODO 请先关闭日志记录之后再上传日志.
            ULog.i(TAG, "onDataReceived: 请先关闭日志记录之后再上传日志.");

        } else {
            //先判断文件是否存在
            File f = new File(UConstants.DIR_MOTOR_CURRENT_LOG);
            if (!f.exists()) {
                //
                ULog.i(TAG, "onDataReceived: 日志文件不存在！");
                return ;
            }

            if (distanceAndMotorCurrentTestLogUploading) {
                ULog.i(TAG, "onDataReceived: 日志文件正在上传中！");
                return ;
            }

            if (MainApp.uploadFileType == 0) {
                distanceAndMotorCurrentTestLogUploading = true;
                //阿里云
                UOss.getInstance(BaseApplication.getInstance())
                        .upload(UConstants.MOTOR_CURRENT_LOG + dateFormat.format(new Date()) + ".txt",
                                UConstants.DIR_MOTOR_CURRENT_LOG,
                                new UOss.FileUploadCallback() {
                                    @Override
                                    public void onSuccess(String url, String filePath) {
                                        f.delete();
                                        distanceAndMotorCurrentTestLogUploading = false;
                                        ULog.i(TAG, "onDataReceived: 上传日志完成");
                                        //TODO jiaojiaojiao 这是异步的告诉蓝牙管理类
                                    }

                                    public void onFailed(String url, String filePath,
                                                         String msg) {
                                        distanceAndMotorCurrentTestLogUploading = false;
                                        ULog.i(TAG, "onDataReceived: 上传日志失败 msg:"+msg);
                                        //TODO jiaojiaojiao 这是异步的告诉蓝牙管理类
                                    }

                                    @Override
                                    public void onProgress(float progress, long curSize, long totalSize) {
                                    }
                                });

            } else if (MainApp.uploadFileType == 1) {
                distanceAndMotorCurrentTestLogUploading = true;
                //minio
                Minio.getInstance(UrlManager.getPrivateMinioAddr()).upload(f.getAbsolutePath(),
                        UConstants.MOTOR_CURRENT_LOG + dateFormat.format(new Date()) + ".txt",
                        new Minio.RequestCallBack() {
                            @Override
                            public void onSuccess() {
                                f.delete();
                                distanceAndMotorCurrentTestLogUploading = false;
                                ULog.i(TAG, "onDataReceived: 电流上传日志完成");
                                //TODO jiao告诉蓝牙管理类
                            }

                            @Override
                            public void onFail() {
                                distanceAndMotorCurrentTestLogUploading = false;
                                ULog.i(TAG, "onDataReceived: 电流上传日志失败");
                                //TODO jiao告诉蓝牙管理类
                            }
                        });
            }
        }
    }

    public static boolean isStandby() {
        return isSleep;
    }
}